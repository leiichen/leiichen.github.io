<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>偏向锁：</strong></p>
<ul>
<li><strong>适用场景：</strong> 主要针对单线程情况下的锁操作，即在锁的竞争不激烈的情况下。</li>
<li><strong>特点：</strong> 当一个线程获取了偏向锁后，如果再次进入同步块，无需重新获取锁，因为锁已经偏向于该线程。这减少了不必要的锁竞争，提高了性能。</li>
<li>原理：CAS 在对象头和栈帧中存储对象的 ID，如果一直都是同一个线程获取此锁，则完全没有必要再进行额外的 CAS 操作。</li>
</ul>
<p><strong>轻量级锁：</strong></p>
<ul>
<li><strong>适用场景：</strong> 针对线程交替访问同步块的场景，即锁的竞争较为频繁，但竞争的线程少于等于两个。</li>
<li><strong>特点：</strong> 使用CAS（Compare And Swap）操作来尝试获取锁，避免了传统的重量级锁的性能开销。如果CAS成功，当前线程就获得了锁，否则会升级为重量级锁。</li>
<li>原理：将对象头中的 Mark Word 复制到锁记录（Lock Record）空间中，然后线程尝试用 CAS 将对象头中的 Mark Word 替换为指向锁记录（Lock Record）的指针。如果成功，当前线程获得锁。如果失败，JVM 再次检查对象的 Mark Word，是否指向当前对象的栈帧，如果是，说明当前对象已经有了这个对象的锁，直接进入同步代码块即可。如果不是，表示有其他线程竞争锁，当前线程使用自旋来获取锁。</li>
</ul>
<p><strong>自旋：</strong></p>
<p>![image-20240124105626306](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240124105626306.png)</p>
<p>（在大多数应用上，每一个线程占用同步代码块的时间不会很长）当多个线程抢占资源时，没有必要将竞争中的线程挂起又唤醒，而是通过无限循环的方式，不断检测是否能够获取锁。</p>
<p>如果仅仅在等待时间短的情况下，自旋锁表现很好；但如果等待时间长了，循环会耗费大量处理器资源，如果超过等待时间，则升级为重量级锁。</p>
<h3 id="内存重排序"><a href="#内存重排序" class="headerlink" title="内存重排序"></a>内存重排序</h3><ul>
<li><strong>处理器A</strong> 执行以下两个操作：<ol>
<li>写操作：将值<code>1</code>写入变量<code>x</code>。</li>
<li>读操作：读取变量<code>y</code>的值。</li>
</ol>
</li>
<li><strong>处理器B</strong> 执行以下两个操作：<ol>
<li>写操作：将值<code>1</code>写入变量<code>y</code>。</li>
<li>读操作：读取变量<code>x</code>的值。</li>
</ol>
</li>
<li>初始时，假设变量<code>x</code>和<code>y</code>都是<code>0</code>。</li>
</ul>
<p>由于处理器的写缓冲区，这些操作可能会被重新排序。例如：</p>
<ul>
<li><strong>处理器A</strong> 可能先执行了读<code>y</code>的操作，此时<code>y</code>还是<code>0</code>，因为处理器B的写操作还在写缓冲区中，尚未刷新到主内存。</li>
<li>同时，<strong>处理器B</strong> 可能也先执行了读<code>x</code>的操作，此时<code>x</code>也是<code>0</code>，因为处理器A的写操作还在写缓冲区中。</li>
</ul>
<p>写操作可能涉及复杂的内存访问，如缓存未命中时需要更长时间来完成。与此同时，后续的读操作（如果不依赖于写操作的结果）可能可以立即执行，不必等待写操作完成。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><strong>JMM关于synchronized的两条规定（可见性）：</strong></p>
<ul>
<li>线程释放锁时，会把该线程对应的工作内存中的共享变量的值刷新到主内存中。</li>
<li>线程获取锁时，该线程对应的工作内存置为无效，从而使用共享变量时，需要从主内存中重新读取最新的值。</li>
</ul>
<p><code>synchronized</code>既能够保证可见性，又能保证原子性，而<code>volatile</code>只能保证可见性，无法保证原子性。</p>
<p>谈谈可见性定义、实现</p>
<h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>此关键字第一个作用：保证被修饰变量的可见性。保证了所有线程看到的该变量的值都是最新的。</p>
<p><strong>volatile如何实现内存可见性</strong></p>
<p>深入来说：通过加入内存屏障和禁止重排序优化来实现的</p>
<ul>
<li>对<code>volatile</code>变量执行写操作时，会在写操作后加入一条<code>store</code>屏障指令（保证 volatile 变量写操作对后续的普通写操作可见）</li>
<li>对<code>volatile</code>变量执行读操作时，会在读操作前加入一条<code>load</code>屏障指令（这是要保证 volatile 变量读取到的值是最新的）</li>
</ul>
<p><strong>volatile 写-读的内存语义：</strong></p>
<p>当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p>
<p>当读一个 volatile 变量时，JVM 会把该线程对应的本地内存置为无效。线程接下来从主内存中读取共享变量。</p>
<h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>一个操作执行的结果需要对另一个操作可见，那么这两个操作直接必须要存在 happens-before 关系（两个操作间存在 happens-before关系，并不意味着前一个操作就必须要在后一个操作之前执行，只要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一个操作之前）</p>
