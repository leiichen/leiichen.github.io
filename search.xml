<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 有三种方式初始化：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;    Object[] a = c.toArray();    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;            elementData = a;        &#125; <span class="keyword">else</span> &#123;            elementData = Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// replace with empty array.</span>        elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><ul><li>无参方式创建时，初始化为空数组，等到第一个元素 add 时，数组才扩容到默认值 10。</li></ul><p>先从 add 方法入手：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>第一次 add 时，size 为 0，我们进入 ensureCapacityInternal 方法：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>在 calculateCapacity 这个方法中，如果当前数组为空（第一次 add 时），就返回默认容量和最小容量中的较大值作为所需容量。否则直接返回 minCapacity。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="keyword">return</span> minCapacity;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    modCount++;    <span class="comment">// overflow-conscious code</span>    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)        grow(minCapacity);&#125;</code></pre><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    <span class="comment">// overflow-conscious code</span>    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)        newCapacity = minCapacity;    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>到这里为止，我们添加第一个元素，数组容量由 空数组 扩容到容量为 10 的数组。如何扩容的呢？ 核心实现在 grow 方法中，此时 minCapacity &#x3D; 10， newCapacity &#x3D; 0，第一个 if 满足条件，newCapacity 赋值为 10。数组被复制到一个扩容后的新数组。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;  <span class="comment">// 申请一个新的数组</span>    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,                     Math.min(original.length, newLength));    <span class="keyword">return</span> copy;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList扩容机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/Java%E9%9B%86%E5%90%88/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/01/20/Java%E9%9B%86%E5%90%88/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>偏向锁：</strong></p><ul><li><strong>适用场景：</strong> 主要针对单线程情况下的锁操作，即在锁的竞争不激烈的情况下。</li><li><strong>特点：</strong> 当一个线程获取了偏向锁后，如果再次进入同步块，无需重新获取锁，因为锁已经偏向于该线程。这减少了不必要的锁竞争，提高了性能。</li><li>原理：CAS 在对象头和栈帧中存储对象的 ID，如果一直都是同一个线程获取此锁，则完全没有必要再进行额外的 CAS 操作。</li></ul><p><strong>轻量级锁：</strong></p><ul><li><strong>适用场景：</strong> 针对线程交替访问同步块的场景，即锁的竞争较为频繁，但竞争的线程少于等于两个。</li><li><strong>特点：</strong> 使用CAS（Compare And Swap）操作来尝试获取锁，避免了传统的重量级锁的性能开销。如果CAS成功，当前线程就获得了锁，否则会升级为重量级锁。</li><li>原理：将对象头中的 Mark Word 复制到锁记录（Lock Record）空间中，然后线程尝试用 CAS 将对象头中的 Mark Word 替换为指向锁记录（Lock Record）的指针。如果成功，当前线程获得锁。如果失败，JVM 再次检查对象的 Mark Word，是否指向当前对象的栈帧，如果是，说明当前对象已经有了这个对象的锁，直接进入同步代码块即可。如果不是，表示有其他线程竞争锁，当前线程使用自旋来获取锁。</li></ul><p><strong>自旋：</strong></p><p>![image-20240124105626306](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240124105626306.png)</p><p>（在大多数应用上，每一个线程占用同步代码块的时间不会很长）当多个线程抢占资源时，没有必要将竞争中的线程挂起又唤醒，而是通过无限循环的方式，不断检测是否能够获取锁。</p><p>如果仅仅在等待时间短的情况下，自旋锁表现很好；但如果等待时间长了，循环会耗费大量处理器资源，如果超过等待时间，则升级为重量级锁。</p><h3 id="内存重排序"><a href="#内存重排序" class="headerlink" title="内存重排序"></a>内存重排序</h3><ul><li><strong>处理器A</strong> 执行以下两个操作：<ol><li>写操作：将值<code>1</code>写入变量<code>x</code>。</li><li>读操作：读取变量<code>y</code>的值。</li></ol></li><li><strong>处理器B</strong> 执行以下两个操作：<ol><li>写操作：将值<code>1</code>写入变量<code>y</code>。</li><li>读操作：读取变量<code>x</code>的值。</li></ol></li><li>初始时，假设变量<code>x</code>和<code>y</code>都是<code>0</code>。</li></ul><p>由于处理器的写缓冲区，这些操作可能会被重新排序。例如：</p><ul><li><strong>处理器A</strong> 可能先执行了读<code>y</code>的操作，此时<code>y</code>还是<code>0</code>，因为处理器B的写操作还在写缓冲区中，尚未刷新到主内存。</li><li>同时，<strong>处理器B</strong> 可能也先执行了读<code>x</code>的操作，此时<code>x</code>也是<code>0</code>，因为处理器A的写操作还在写缓冲区中。</li></ul><p>写操作可能涉及复杂的内存访问，如缓存未命中时需要更长时间来完成。与此同时，后续的读操作（如果不依赖于写操作的结果）可能可以立即执行，不必等待写操作完成。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><strong>JMM关于synchronized的两条规定（可见性）：</strong></p><ul><li>线程释放锁时，会把该线程对应的工作内存中的共享变量的值刷新到主内存中。</li><li>线程获取锁时，该线程对应的工作内存置为无效，从而使用共享变量时，需要从主内存中重新读取最新的值。</li></ul><p><code>synchronized</code>既能够保证可见性，又能保证原子性，而<code>volatile</code>只能保证可见性，无法保证原子性。</p><p>谈谈可见性定义、实现</p><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>此关键字第一个作用：保证被修饰变量的可见性。保证了所有线程看到的该变量的值都是最新的。</p><p><strong>volatile如何实现内存可见性</strong></p><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的</p><ul><li>对<code>volatile</code>变量执行写操作时，会在写操作后加入一条<code>store</code>屏障指令（保证 volatile 变量写操作对后续的普通写操作可见）</li><li>对<code>volatile</code>变量执行读操作时，会在读操作前加入一条<code>load</code>屏障指令（这是要保证 volatile 变量读取到的值是最新的）</li></ul><p><strong>volatile 写-读的内存语义：</strong></p><p>当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><p>当读一个 volatile 变量时，JVM 会把该线程对应的本地内存置为无效。线程接下来从主内存中读取共享变量。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>一个操作执行的结果需要对另一个操作可见，那么这两个操作直接必须要存在 happens-before 关系（两个操作间存在 happens-before关系，并不意味着前一个操作就必须要在后一个操作之前执行，只要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一个操作之前）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传图片</title>
      <link href="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>今天在使用 typora 写好笔记后，上传至 hexo 服务器，发现图片还是读取的本地路径。通过参考其他人的经验找到一种解决方法。</p><p>1、在 typora 设置中勾选如下选项，作用是图片使用相对路径。</p><p><img src="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20240106172757156.png" alt="image-20240106172757156"></p><p>2、安装插件即可，不需要再设置<code>图片根目录</code>。</p><pre><code class="highlight javascript">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></code></pre><p>至此在浏览器就可以正常显示图片了。（ps: 前提是根目录下的_config.yml文件中的post_asset_folder字段已经设置为true）</p>]]></content>
      
      
      <categories>
          
          <category> 工具大杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2024/01/06/Java%E9%9B%86%E5%90%88/"/>
      <url>/2024/01/06/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231228215407955.png" alt="image-20231228215407955"><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231228215505374.png" alt="image-20231228215505374"></p><p>出现这种情况的原因是 Java 内存模型，线程从主内存复制一份，先放到工作内存，再放到主内存，释放锁，而另一个线程修改的不一样，导致结果不一样。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Collection：集合框架最基础的接口，最顶层的接口</p><p>List：Collection 的子接口，存储有序、可重复的对象，最常用的接口。</p><p>Set：Collection 的子接口，存储有序、唯一（元素不可重复）的对象。</p><p>Map：独立于 Collection 的另外一个接口，最顶层的接口，存储一组键值对象，提供键到值的映射。</p><p>Iterator：输出集合元素的接口，一般适合无序集合，从前往后输出。</p><p>ListIterator：Iterator 的子接口，可以双向输出集合中的元素。</p><p>Enumeration：传统的输出接口，已经被 Iterator 取代。</p><p>SortedSet：Set 的子接口，可以对集合中的元素进行排序。</p><p>SortedMap：Map 子接口，可以对集合中的元素进行排序。</p><p>Queue：队列接口。</p><p>Map Entry：Map 的内部接口，描述 Map 中存储的一组键值对元素。</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>Collection 是集合框架最基础的接口，可以存储一组无序、重复的对象。</p><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List 常用的扩展方法：</p><pre><code class="highlight java">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;  通过下标返回集合中对应位置的元素</code></pre><pre><code class="highlight java">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;  在集合中指定位置存入对象</code></pre><pre><code class="highlight java"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;  查找某个对象在集合中的位置</code></pre><pre><code class="highlight java"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;  返回指定元素最后一次出现的位置</code></pre><pre><code class="highlight java">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;  实例化 ListIterator 接口，用来遍历 List 集合</code></pre><pre><code class="highlight java">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;  通过下标截取 List 集合</code></pre><h3 id="List-接口的实现类"><a href="#List-接口的实现类" class="headerlink" title="List 接口的实现类"></a>List 接口的实现类</h3><p>ArrayList：实现了长度可变的数组，在内存中分配连续空间，所以读取快，增删慢。非线程安全。</p><p>Vector：线程安全，但效率低，实现线程安全直接通过 synchronized 修饰方法来完成。</p><p>Stack：Vector 的子类，实现了栈的数据结构（后进先出）</p><p>ArrayList 和 ListedList 区别：内存中存储的形式不同，ArrayList 采用的是数组的方式，LinkedList 采用的是链表的方式。</p><p>ListedList 实现了 Deque 接口，而 Deque 是 Queue 的子接口，Queue 底层实现了队列的数据结构。</p><p>Queue 的实现类是 AbstractQueue，它是一个抽象类，不能直接实例化，开发中使用 PriorityQueue 类。</p><p>Queue 添加的数据必须是有序的。</p><pre><code class="highlight java"><span class="keyword">package</span> Collection;<span class="keyword">import</span> java.util.AbstractQueue;<span class="keyword">import</span> java.util.PriorityQueue;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();<span class="comment">//        queue.add(&quot;wdcp&quot;);</span><span class="comment">//        queue.add(&quot;hdcp&quot;);</span><span class="comment">//        queue.add(&quot;dcp&quot;);</span>        queue.add(<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">1</span>));        queue.add(<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">2</span>));        System.out.println(queue);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="built_in">this</span>.num = num;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A) o;        <span class="keyword">return</span> <span class="built_in">this</span>.num - a.num;    &#125;&#125;</code></pre><p>Queue 默认给元素进行升序排序。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 集合以散列形式存储数据，所以元素是没有顺序的。</p><p>Set 常用实现类：</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul><p>HashSet 存储一组<strong>无序</strong>（元素存储顺序和遍历顺序不一致）且唯一的对象。</p><p>LinkedHashSet：可以存储<strong>有序（元素存储顺序和遍历顺序一致）</strong>且唯一的元素</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231230210121262.png" alt="image-20231230210121262"></p><p>LinkedHashSet 如何判断两个对象是否相等？</p><p>首先会判断两个对象的 hashCode 是否相等</p><p>什么是 hashCode？将对象的内部信息（内存地址、属性值），通过某种特定规则转换成一个散列值，就是该对象的 hashCode。</p><ul><li>两个不同对象的 hashCode 值可能是相等的。</li><li>hashCode 不相等的对象一定不是同一个对象。</li></ul><p>集合在判断两个对象是否相等的时候，首先会先比较它们的 hashCode，如果不等，肯定不是同一个对象，可以添加。</p><p>如果 hashCode 相等，再判断 equals 进行进一步判断，如果 equals 相等，则两个对象相等。</p><pre><code class="highlight java"><span class="keyword">package</span> Collection;<span class="keyword">import</span> java.util.HashSet;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.LinkedHashSet;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        LinkedHashSet&lt;Object&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();        linkedHashSet.add(<span class="string">&quot;wdcp&quot;</span>);        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);        linkedHashSet.add(b);        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);        linkedHashSet.add(b1);        linkedHashSet.add(<span class="number">1</span>);        System.out.println(linkedHashSet);        System.out.println(b.equals(b1));  <span class="comment">// true，但还是存了两次，set认为它们还是两个对象</span>    &#125;&#125;<span class="keyword">class</span> <span class="title class_">B</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +                <span class="string">&quot;num=&quot;</span> + num +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="built_in">this</span>.num = num;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> B)&#123;            <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) obj;            <span class="keyword">return</span> <span class="built_in">this</span>.num == b.num;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;&#125;</code></pre><h3 id><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h3><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231231144623559.png" alt="image-20231231144623559"></p><p>栈中存储的是变量，引用类型具体的对象（属性）存储再堆中的，再将堆中的对象地址赋值给栈中的变量。 基本数据类型变量的值直接存在栈中。</p><p><strong>&#x3D;&#x3D;：判断的是栈内存中的值。</strong></p><p>引用类型的数据，栈内存中存储的是地址，所以此时 &#x3D;&#x3D; 判断的是引用地址。</p><p>基本数据类型，栈内存中存储的是具体的数值。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>LinkedHashSet 和 TreeSet 都是存储一组有序且唯一的数据，但这里的两个有序有区别的。</p><p>LinkedHashSet 的有序指元素的存储顺序与遍历顺序是一致的。</p><p>TreeSet 的有序是指集合内部自动按照升序排列，无论存入的顺序是什么，遍历一定按照升序输出。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>key-value，数据字典</p><p>List、Set 接口都是 Collection 的子接口，Map 接口是与 Collection 完全独立的另外一个体系。</p><table><thead><tr><th>Set<K> keySet();</K></th><th>取出集合中所有的 key，返回一个 Set</th></tr></thead><tbody><tr><td>Collection<V> values();</V></td><td>取出集合中所有的 values，返回一个 Collection</td></tr><tr><td>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</td><td>将 Map 以 Set 输出</td></tr></tbody></table><h3 id="Map-接口的实现类"><a href="#Map-接口的实现类" class="headerlink" title="Map 接口的实现类"></a>Map 接口的实现类</h3><ul><li>HashMap：存储一组无序，key 不能重复，value 可以重复的元素</li><li>Hashtable：存储一组无序，key 不能重复，value 可以重复的元素。</li><li>TreeMap：存储一组有序，key 不能重复，value 可以重复的元素，可以按照 key 进行排序。</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Map;<span class="keyword">import</span> java.util.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        hashMap.put(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;Hello&quot;</span>);        hashMap.put(<span class="string">&quot;w&quot;</span>, <span class="string">&quot;World&quot;</span>);        hashMap.put(<span class="string">&quot;j&quot;</span>, <span class="string">&quot;Java&quot;</span>);        System.out.println(hashMap);        Set&lt;Object&gt; sets = hashMap.keySet();        Iterator&lt;Object&gt; iterator = sets.iterator();        <span class="keyword">while</span> (iterator.hasNext()) &#123;            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String)iterator.next();            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) hashMap.get(key);            System.out.println(key + <span class="string">&quot;-&quot;</span> + value);        &#125;        Collection&lt;Object&gt; values = hashMap.values();        <span class="keyword">for</span>(Object value: values) &#123;            System.out.println(value);        &#125;    &#125;&#125;</code></pre><p>Hashtable 与 HashMap 用法基本一样，区别是 Hashtable 是线程安全的，但性能较低。HashMap 是非线程安全的，性能较高。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code class="highlight java"><span class="keyword">package</span> Collection.Map;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.TreeMap;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        TreeMap&lt;Object, Object&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;cp&quot;</span>), <span class="string">&quot;cp&quot;</span>);        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;dcp&quot;</span>), <span class="string">&quot;dcp&quot;</span>);        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1</span>, <span class="string">&quot;cpp&quot;</span>), <span class="string">&quot;cpp&quot;</span>);        System.out.println(treeMap);        Set&lt;Object&gt; set = treeMap.keySet();        Iterator&lt;Object&gt; iterator = set.iterator();        <span class="keyword">while</span> (iterator.hasNext()) &#123;            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();            System.out.println(key + <span class="string">&quot;-&quot;</span> + treeMap.get(key));        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String name)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;            <span class="keyword">return</span> <span class="built_in">this</span>.id - user.id;        &#125;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;&#125;</code></pre><p>TreeMap 会对 key 值进行排序，如果是自定义类，则需要重写 compareTo 方法。</p><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p>Collections 不是接口，是工具类，专门提供了一些对集合的操作，方便开发者去使用。</p><p>Collections.reverse(List&lt;?&gt; list) 为什么 Set 不能用 reverse？</p><p>能 reverse 要有顺序，而 Set 无序。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics），是指在类中定义时不指定类中信息的具体类型，而是暂时用一个标识符来替代，当外部实例化对象时再来指定具体的数据类型。</p><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>有一个参数为 ArrayList 的方法，希望这个方法既可以接受泛型是 String 的集合，又可以接受泛型是 Integer 的集合。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240101095510340.png" alt="image-20240101095510340"></p><p>不能这样，要么不写 Object。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240101095643330.png" alt="image-20240101095643330"></p><p>ArrayList&lt;?&gt; 表示可以使用任意的泛型类型对象，这样 test 就具有通用性。</p><h3 id="泛型上限和下限"><a href="#泛型上限和下限" class="headerlink" title="泛型上限和下限"></a>泛型上限和下限</h3><p>上限：表示实例化时具体的数据类型，可以是上限类型的子类或上限类型本身，用 extends 表示。</p><p>下限：表示实例化时具体的数据类型，可以是下限类型的父类或下限类型本身，用 super 表示。</p><p>类名&lt;泛型标识 extends 上限类名&gt;</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        test(<span class="keyword">new</span> <span class="title class_">Time1</span>&lt;Double&gt;());    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Time1&lt;? extends Number&gt; time1)</span>&#123;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(Time1&lt;? <span class="built_in">super</span> String&gt; time1)</span>&#123;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Time1</span>&lt;T&gt; &#123;&#125;</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口<T> </T></p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;    T <span class="title function_">getValue</span><span class="params">()</span>;&#125;</code></pre><p>实现泛型接口有两种方式：</p><ul><li>实现类在定义时继续使用泛型标识</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&#123;    <span class="keyword">private</span> T obj;    <span class="keyword">public</span> <span class="title function_">MyInterfaceImpl</span><span class="params">(T obj)</span> &#123;        <span class="built_in">this</span>.obj = obj;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.obj;    &#125;&#125;</code></pre><ul><li>实现类在定义时直接给出具体的数据类型</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyinterfaceImpl2</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt; &#123;    <span class="keyword">private</span> String obj;    <span class="keyword">public</span> <span class="title function_">MyinterfaceImpl2</span><span class="params">(String obj)</span> &#123;        <span class="built_in">this</span>.obj = obj;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.obj;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MyInterfaceImpl</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>&lt;&gt;(<span class="string">&quot;wdcp&quot;</span>);        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> (String)myInterface.getValue();        System.out.println(val);        <span class="type">MyinterfaceImpl2</span> <span class="variable">myinterfaceImpl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyinterfaceImpl2</span>(<span class="string">&quot;hecp&quot;</span>);        System.out.println(myinterfaceImpl2.getValue());    &#125;&#125;</code></pre><h2 id="Java-实用类"><a href="#Java-实用类" class="headerlink" title="Java 实用类"></a>Java 实用类</h2><ul><li>枚举</li></ul><p>枚举 Enum，是一个有确定值区间的数据结构，本质就是一个类。</p><p>为什么要有枚举？</p><p>因为在描述某些对象的属性时，该属性的值不能随便定义，必须在某个特定的区间取值。</p><p>枚举由一组常量组成的类型，指定一个取值区间，我们只能从该区间取值。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>String 实例化</li></ul><p>1、直接赋值</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;wdcp&quot;</span>;</code></pre><p>2、通过构造函数创建对象</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wdcp&quot;</span>)</code></pre><ul><li>String 常用方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> ： 返回下标所对应的字符<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexof</span><span class="params">(String str)</span> ： 返回 str 在字符串中的下标<span class="keyword">public</span> String[] split(String regex) ： 用指定的字符串对目标分割，返回数组<span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span> ： 转小写<span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span> ： 转大写</code></pre><p>null 和空是两种概念，null 是指对象不存在，</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>String 对象一旦创建，值不能修改（原来的值不能修改，一旦修改就是新的对象，只要一改动，就会创建一个新的对象）。</p><p>修改后会重新开辟内存空间来存储新的内存对象，会修改 String 的引用。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240102111455342.png" alt="image-20240102111455342"></p><p>String 为什么修改后会开辟新的空间创建新对象？不能在原先内存上直接修改吗？</p><p>因为 String 底层是用数组来存值的，数组长度一旦创建就不可修改，导致上述问题。</p><p>StringBuffer 可以解决 String 频繁修改造成资源浪费的问题。</p><p>StringBuffer 底层也是使用数组来存值。</p><ul><li>StringBuffer 数组的默认长度为 16</li><li>使用无参构造，默认长度是 16</li></ul><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103094946726.png" alt="image-20240103094946726"></p><ul><li>使用有参构造，长度是 值的长度 + 16</li></ul><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103095030575.png" alt="image-20240103095030575"></p><p>StringBuffer 一旦创建，默认会有 16 个字节空间去修改，但一旦追加的字符串长度超过 16，如何处理？</p><p>StringBuffer 不会重新开辟一块新的内存空间，而是在原有空间直接扩容，通过调用父类的ensureCapacityInternal() 方法对底层数组扩容，保持引用不变。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103101200174.png" alt="image-20240103101200174"></p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuffer 是线程安全的，效率较低；StringBuilder 是线程不安全的，效率较高。</p><p>读取数据不需要考虑线程安全问题，因为没有隐患。</p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><ul><li>java.util.Date</li></ul><p>Date 对象表示当前的系统时间</p><pre><code class="highlight java"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);<span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date);System.out.println(format);</code></pre><ul><li>java.util.Calendar</li></ul><p>Calendar 用来完成日期数据的逻辑运算</p><p>运算思路：</p><p>1、将日期数据传给 Calendar（Calendar 提供了很多静态常量，专门记录日期数据）</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103174705206.png" alt="image-20240103174705206"></p><p>2、调用相关方法完成计算</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103174845642.png" alt="image-20240103174845642"></p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Date;<span class="keyword">import</span> java.text.SimpleDateFormat;<span class="keyword">import</span> java.util.Calendar;<span class="keyword">import</span> java.util.Date;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 计算今天所在的周是 2024 年第几周</span><span class="comment">//        Calendar calendar = Calendar.getInstance();</span><span class="comment">//        calendar.set(Calendar.YEAR, 2024);</span><span class="comment">//        calendar.set(Calendar.MONTH, 0);  // 1月从0开始</span><span class="comment">//        calendar.set(Calendar.DAY_OF_MONTH, 3);</span><span class="comment">//        int week = calendar.get(Calendar.WEEK_OF_YEAR);</span><span class="comment">//        System.out.println(week);</span>        <span class="comment">// 今天之后的63天是几月几号</span>        <span class="comment">// 先算出今天是一年中的第几天</span>        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();        calendar.set(Calendar.YEAR, <span class="number">2024</span>);        calendar.set(Calendar.MONTH, <span class="number">0</span>);        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>);        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_YEAR);        day += <span class="number">63</span>;        calendar.set(Calendar.DAY_OF_YEAR, day);        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(time);        System.out.println(format);        calendar.set(Calendar.DAY_OF_YEAR, calendar.get(Calendar.DAY_OF_YEAR)-<span class="number">63</span>);        time = calendar.getTime();        System.out.println(simpleDateFormat.format(time));    &#125;&#125;</code></pre><h2 id="输入输出-IO-流"><a href="#输入输出-IO-流" class="headerlink" title="输入输出 IO 流"></a>输入输出 IO 流</h2><p>File 类</p><p>java.io.File，使用该类的构造函数可以创建文件对象。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103202800556.png" alt="image-20240103202800556"></p><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><ul><li>按照单位分，分为字节流和字符流</li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>按照方向可分为输入字节流和输出字节流</p><p>InputStream 和 OutputSteam</p><p>InputStream 常用方法</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105142945713.png" alt="image-20240105142945713"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>字节流是单位时间内处理一个字节的数据（输入+输出）</p><p>字符流是单位时间内处理一个字符的数据（输入+输出）</p><p>字符流：</p><ul><li>输入字符流 Reader</li><li>输出字符流 Writer</li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>是一个抽象类</p><p>Readable 的作用？</p><p>可以将数据以字符的形式读入缓冲区</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105152250368.png" alt="image-20240105152250368"></p><p>InputStream（字节输入流）   Reader（字符输入流）</p><p>InputStreamReader 的功能是将字节输入流转化为字符输入流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="comment">// 字符流</span>        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span> ((tmp = reader.read()) != -<span class="number">1</span>) &#123;            System.out.println(tmp);        &#125;        reader.close();        System.out.println(<span class="string">&quot;-----------&quot;</span>);        <span class="comment">// 字节流</span>        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        tmp = <span class="number">0</span>;        <span class="keyword">while</span> ((tmp = inputStream.read()) != -<span class="number">1</span>) &#123;            System.out.println(tmp);        &#125;        inputStream.close();    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderTest2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];        <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> inputStream.read(bytes);        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> reader.read(chars);        System.out.println(<span class="string">&quot;字节流长度是&quot;</span> + length2);        System.out.println(<span class="string">&quot;字符流长度是&quot;</span> + length);        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;            System.out.println(aChar);        &#125;    &#125;&#125;</code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105162047833.png" alt="image-20240105162047833"></p><p>Appendable 接口可以将 char 类型的数据读入到数据缓冲区</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/copy.txt&quot;</span>);        writer.write(<span class="string">&quot;你好，wdcp&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);        writer.flush();        writer.close();    &#125;&#125;</code></pre><h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105170347820.png" alt="image-20240105170347820"></p><pre><code class="highlight java"><span class="comment">// 基础管道</span><span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);<span class="comment">// 处理流</span><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);<span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStreamReader.read(chars);inputStreamReader.close();<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, length);System.out.println(str);</code></pre><pre><code class="highlight java"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;你好，世界&quot;</span>;<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/0.txt&quot;</span>);<span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);writer.write(s);writer.flush();writer.close();</code></pre><h4 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h4><p>无论是字节流还是字符流，使用的时候都会频繁访问硬盘，对硬盘是一种损伤，同时效率不高，如何解决？</p><p>可以使用缓存流，缓存流自带缓冲区，可以一次性从硬盘中读取部分数据存入缓存区，再写入内存。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240106093901882.png" alt="image-20240106093901882"></p><p>缓存流属于处理流，如何区分处理流和节点流？</p><p>1、节点流使用的时候可以直接对接到文件对象 File</p><p>2、处理流使用的时候不能直接对接到文件对象 File</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240106094816585.png" alt="image-20240106094816585"></p><p>缓存流又可以分为字节缓存流和字符缓存流，再细分可以分为字节输入缓存流和字节输出缓存流、字符输入缓存流和字符输出缓存流。</p><p>字符输入缓存流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="keyword">while</span> ((tmp = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;            System.out.println(tmp);        &#125;        bufferedReader.close();        reader.close();    &#125;&#125;</code></pre><p>字符输出缓存流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">import</span> java.io.Writer;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);        bufferedWriter.write(<span class="string">&quot;wdcppppp&quot;</span>);        bufferedWriter.flush();        bufferedWriter.close();        writer.close();    &#125;&#125;</code></pre><p>输入流没有 flush 方法，但不代表它没有缓存流，输出流是有 flush 方法，在关闭缓存流之前，需要调用 flush 方法。</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化：将内存中的对象输出到硬盘文件中保存。</p><p>反序列化：从文件中读取数据并还原成内存中的对象。 </p><p>序列化 </p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Serializable;<span class="keyword">import</span> java.io.FileOutputStream;<span class="keyword">import</span> java.io.ObjectOutputStream;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">22</span>);        <span class="comment">// user 对象写入文件</span>        <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;</span>);        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);        objectOutputStream.writeObject(user);        objectOutputStream.flush();        objectOutputStream.close();        outputStream.close();    &#125;&#125;</code></pre><h2 id="IO-流的应用"><a href="#IO-流的应用" class="headerlink" title="IO 流的应用"></a>IO 流的应用</h2><p>IO 流就是完成文件传输的（上传文件：上传头像、朋友圈，文件下载：CSDN 下载源代码）</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Serializable;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;<span class="comment">//        FileInputStream inputStream = new FileInputStream(&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;);</span><span class="comment">//        FileOutputStream outputStream = new FileOutputStream(&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;);</span><span class="comment">//        int tmp = 0;</span><span class="comment">//        while ((tmp = inputStream.read()) != -1) &#123;</span><span class="comment">//            outputStream.write(tmp);</span><span class="comment">//        &#125;</span><span class="comment">//        outputStream.close();</span><span class="comment">//        inputStream.close();</span>        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;</span>);        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user2.txt&quot;</span>);        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;            bufferedWriter.write(str);            num++;        &#125;        System.out.println(num);        bufferedWriter.flush();        bufferedWriter.close();        bufferedReader.close();        writer.close();        reader.close();    &#125;&#125;</code></pre><p>对于音频、图片，只能用字节流读取</p><p>文本类型的数据可以用字符流、字节流读取</p>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2023/12/15/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/15/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架两大核心机制-IOC、AOP"><a href="#Spring框架两大核心机制-IOC、AOP" class="headerlink" title="Spring框架两大核心机制(IOC、AOP)"></a>Spring框架两大核心机制(IOC、AOP)</h2><ul><li>IOC（控制反转）&#x2F; DI （依赖注入）</li><li>AOP （面向切面编程）</li></ul><p>Spring是一个企业级的开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p><p>MVC：Struts2、Spring MVC</p><p>ORMapping：Hibernate、Mybatis、Spring Data</p><p>什么是控制反转：对象由调用者主动new出来。而在Spring中创建对象由IOC容器创建，再推送给调用者，整个流程完成反转，就称作控制反转。</p><h2 id="如何使用IOC"><a href="#如何使用IOC" class="headerlink" title="如何使用IOC"></a>如何使用IOC</h2><ul><li>创建Maven工程，添加pom.xml依赖</li></ul><pre><code class="highlight java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;<span class="number">5.3</span><span class="number">.29</span>&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li><p>创建实体类Student</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;&#125;</code></pre></li><li><p>传统的开发方式  手动new</p></li><li><p>通过IOC创建对象，在XML配置文件中添加需要管理的对象</p></li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><ul><li>从IOC中获取对象</li></ul><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) applicationContext.getBean(<span class="string">&quot;student&quot;</span>);System.out.println(student);</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>通过配置<code>bean</code>标签完成对象的管理</p><ul><li>id : 对象名</li><li>class：对象的模版类（所有交给IOC构建的对象都要有无参构造，因为Spring底层是通过反射机制创建对象的，反射机制调用的是无参构造）</li></ul></li><li><p>成员变量通过<code>property</code> 标签完成赋值</p><ul><li><code>name</code>：成员变量名</li><li><code>value</code>：成员变量的值（基本数据类型，Spring可以直接赋值，其他类型不能通过value赋值）</li><li><code>ref</code>：将IOC中的另外一个bean赋值给当前变量（DI 依赖注入）</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ul><li>读取配置文件，解析XML</li><li>通过反射机制实例化配置文件中所配置的所有bean。</li></ul><h3 id="通过运行时类获取bean"><a href="#通过运行时类获取bean" class="headerlink" title="通过运行时类获取bean"></a>通过运行时类获取bean</h3><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);System.out.println(st);</code></pre><p>这种方式存在问题，配置文件中一个数据类型对象只能有一个实例，因为是通过Class中获取的，Class中数据类型是一样的。</p><h3 id="通过有参构造创建对象"><a href="#通过有参构造创建对象" class="headerlink" title="通过有参构造创建对象"></a>通过有参构造创建对象</h3><ul><li><p>在实体类中创建有参函数</p></li><li><p>配置文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="给bean注入集合"><a href="#给bean注入集合" class="headerlink" title="给bean注入集合"></a>给bean注入集合</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span> &gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="scope作用域"><a href="#scope作用域" class="headerlink" title="scope作用域"></a>scope作用域</h3><p>Spring管理的bean是根据bean来生成的，表示bean的作用域，共4种，默认是singleton。</p><ul><li>singleton：单例，表示通过Spring容器获取的bean是唯一的。</li><li>prototype：原型，表示通过Spring容器获取的bean是不同的。</li><li>request：请求，表示在一次HTTP请求内有效。</li><li>session：会话，表示在一个用户会话内有效。</li></ul><p>request 和 session 只适用于Web项目，大多数情况下，使用单例和原型较多。</p><p>request模式在加载配置文件时就创建了xml中所有的bean。</p><p>prototype模式当业务代码获取IOC容器中的bean时，Spring才去调用无参构造创建对应的bean。</p><h3 id="Spring的继承"><a href="#Spring的继承" class="headerlink" title="Spring的继承"></a>Spring的继承</h3><p>与JAVA中的继承不同，JAVA是类层面的继承，子类可以继承父类的结构和信息；Spring是对象层面的继承，子对象可以继承父对象的属性值。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lala&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;student2&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><ul><li>不同类型的对象某些情况也是可以继承的，需要子对象的属性包含父对象的属性。</li></ul><h3 id="Spring的依赖"><a href="#Spring的依赖" class="headerlink" title="Spring的依赖"></a>Spring的依赖</h3><p>与继承类似，依赖也是描述bean和bean之间的一种关系，配置依赖后，被依赖的bean先创建，再创建依赖的bean。如A依赖于B，则先创建B，再创建A。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.User&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="Spring的-p-命名空间"><a href="#Spring的-p-命名空间" class="headerlink" title="Spring的 p 命名空间"></a>Spring的 p 命名空间</h3><p>p 命名空间是对IOC &#x2F; DI的简化操作，使用 p 命名空间可以更加方便的完成bean的配置以及bean之间的依赖注入。</p><h3 id="Spring的工厂方法"><a href="#Spring的工厂方法" class="headerlink" title="Spring的工厂方法"></a>Spring的工厂方法</h3><p>IOC通过工厂模式创建 bean 的方式有两种：</p><ul><li>静态工厂模式</li><li>实例工厂方法</li></ul><p>静态工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.AllArgsConstructor;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> lombok.NoArgsConstructor;<span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructor</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCarFactory</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Car&gt; carMap;    <span class="keyword">static</span> &#123;        carMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        carMap.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大G&quot;</span>));        carMap.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;宝马&quot;</span>));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> carMap.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java">&lt;!--配置静态工厂创建bean--&gt;    &lt;bean id=<span class="string">&quot;car&quot;</span> class=<span class="string">&quot;com.study.factory.StaticCarFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;        &lt;constructor-arg value=<span class="string">&quot;1&quot;</span>&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>实例工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCarFactory</span> &#123;    <span class="keyword">private</span> Map&lt;Long, Car&gt; map;    <span class="keyword">public</span> <span class="title function_">InstanceCarFactory</span><span class="params">()</span> &#123;        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大奔&quot;</span>));        map.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;沃尔沃&quot;</span>));    &#125;    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> map.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-factory.xml&quot;</span>);<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) applicationContext.getBean(<span class="string">&quot;car2&quot;</span>);System.out.println(car);</code></pre><pre><code class="highlight java">&lt;!--实例工厂创建bean--&gt;&lt;bean id=<span class="string">&quot;carFactory&quot;</span> class=<span class="string">&quot;com.study.factory.InstanceCarFactory&quot;</span>&gt;&lt;/bean&gt;&lt;bean id=<span class="string">&quot;car2&quot;</span> class=<span class="string">&quot;com.study.entity.Car&quot;</span> factory-bean=<span class="string">&quot;carFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;    &lt;constructor-arg value=<span class="string">&quot;2&quot;</span>&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="IOC自动装载（Autowire）"><a href="#IOC自动装载（Autowire）" class="headerlink" title="IOC自动装载（Autowire）"></a>IOC自动装载（Autowire）</h3><p>IOC负责创建对象，DI完成对象的依赖注入，通过配置property标签的 ref 属性完成，同时Spring提供了更加简便的依赖注入方式：自动装载，不需要手动配置property，IOC容器会自动选择 bean 完成注入。</p><p>自动装载有两种方式：</p><ul><li>byName：通过属性名自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><ul><li>byType：通过属性的类型自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><p>byType需要注意，如果同时存在两个及以上的bean时，会抛出异常。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP：Aspect Oriented Programming 面向切面编程</p><p>AOP的优点：</p><ul><li>降低模块的耦合度</li><li>使系统更容易扩展</li><li>更好的代码服用</li><li>非业务代码更加集中，便于统一管理</li><li>业务代码更加简洁，不掺杂其他代码影响</li></ul><p>AOP是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定对象上的编程思想就是面向切面编程。将不同方法的同一位置抽象成一个切面对象，对该切面对象进行编程就是AOP。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>创建Maven工程，pom.xml添加</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre></blockquote><ul><li>创建一个计算器接口，创建加减乘除方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;add方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;sub方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;mul方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;div方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用AOP可以进行优化，如何实现AOP？使用动态代理的方式来实现。</p><p>给业务代码找一个代理，打印日志信息的工作交给代理来做，这样的话业务代码只需关注自身业务即可。</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.utils;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Method;<span class="keyword">import</span> java.lang.reflect.Proxy;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  <span class="comment">// 这不是代理类，这个类帮助我们去创建动态代理类</span>  <span class="comment">// 接收委托对象</span>  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 返回代理对象</span>  <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object object)</span> &#123;      <span class="built_in">this</span>.object = object;      <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="built_in">this</span>);  &#125;  <span class="meta">@Override</span>  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;      <span class="comment">// 这里将业务代码和日志代码进行解耦</span>      System.out.println(method.getName() + <span class="string">&quot;方法的参数是&quot;</span> + Arrays.toString(args));      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.object, args);  <span class="comment">// 业务代码</span>      System.out.println(method.getName() + <span class="string">&quot;的结果是&quot;</span> + res);      <span class="keyword">return</span> res;  &#125;&#125;</code></pre><p>以上是通过动态代理实现AOP的过程，不好理解，Spring框架对AOP进行了封装，使用Spring框架可以用面向对象的思想实现AOP。</p><p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring 框架底层会根据切面类以及目标类生成一个代理对象。</p><p>LoggerAspect</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.aop;<span class="keyword">import</span> org.aspectj.lang.JoinPoint;<span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="keyword">import</span> org.aspectj.lang.annotation.Before;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Arrays;<span class="meta">@Aspect</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerAspect</span> &#123;    <span class="comment">// 非业务代码</span>    <span class="meta">@Before(&quot;execution(public int com.study.impl.CalImpl.*(..))&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;        <span class="comment">// 获取方法名</span>        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();        <span class="comment">// 获取参数</span>        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());        System.out.println(name + <span class="string">&quot;方法的参数是&quot;</span> + args);    &#125;&#125;</code></pre><p>LoggerAspect两个注解：</p><ul><li>@Aspect 表示该类是切面类</li><li>@Component 将该类的对象注入到 IOC 容器</li></ul><p>具体方法处添加的注解：</p><ul><li>@Before 表示方法执行的具体位置和时机</li></ul><p>CalImpl 也需要添加 @Component，交给 IOC 管理</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.impl;<span class="keyword">import</span> com.study.utils.Cal;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>Spring.xml 也需要配置 AOP</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 自动扫描 --&gt;</span>        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 使Aspect注解生效 为目标类自动生成代理对象--&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p><code>context:component-scan</code> 将 <code>com.study</code> 包中所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类添加到 IOC 容器中，让 IOC 管理它的对象。</p><p><code>aop:aspectj-autoproxy</code> 让Spring框架结合切面类和目标类自动生成动态代理对象。</p><ul><li>切面：横切关注点被模块化的抽象对象。</li><li>通知：切面对象完成的工作。（非业务代码）</li><li>目标：被通知的对象，即被横切的对象。</li><li>代理：切面、通知、目标混合之后的对象。</li><li>连接点：通知要插入代码的具体位置。</li><li>切点：AOP 通过切点定位到连接点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
