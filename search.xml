<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker</title>
      <link href="/2024/03/19/Docker/"/>
      <url>/2024/03/19/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-和-虚拟机的区别"><a href="#Docker-和-虚拟机的区别" class="headerlink" title="Docker 和 虚拟机的区别"></a>Docker 和 虚拟机的区别</h2><p>虚拟机需要启动完整的系统，内核、工具等</p><p>Docker 是容器的一种实现方式，镜像是一个模板，容器是模板的实例。</p><p><img src="/2024/03/19/Docker/image-20240319140809181.png" alt="image-20240319140809181"></p><p>查看本地镜像：docker images</p><p>查看正在运行的容器：docker ps</p><p>运行一个容器：docker run –name some-nginx -d -p 8080:80 nginx:1.22</p><p>查看容器的信息：docker inspect 容器名</p><pre><code class="highlight plaintext">将容器连接到网络：docker network (dis)connect 网络名 容器名 之后访问容器 docker run -it --rm mysql:5.7 mysql -h172.17.0.2 -uroot -p=》 docker run -it --rm --network 网络名 mysql:5.7 mysql -hsome-mysql -uroot -p</code></pre><h2 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h2><p><img src="/2024/03/19/Docker/image-20240319153237440.png" alt="image-20240319153237440"></p><p>创建一个卷：docker volume create 卷名</p><h2 id="Docker-部署前后端分离项目-若依"><a href="#Docker-部署前后端分离项目-若依" class="headerlink" title="Docker 部署前后端分离项目-若依"></a>Docker 部署前后端分离项目-若依</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1、创建 mysql 容器</p><pre><code class="highlight linux">docker run -d \  --name mysql \  -p 3307:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=1314 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \   # 映射路径  --network ruoyi    \  mysql:8.0.19</code></pre><p>在启动 mysql 容器后，运行中内存会很大，需要在进入容器内为其配置文件中设置参数：</p><p>&#x2F;etc&#x2F;mysql&#x2F;conf.d 目录执行 vim docker.cnf</p><pre><code class="highlight plaintext">performance_schema_max_table_instances=400  table_definition_cache=400    performance_schema=off    table_open_cache=64    innodb_buffer_pool_chunk_size=64M    innodb_buffer_pool_size=64M</code></pre><p>2、创建 redis 容器</p><pre><code class="highlight linux">docker run  \--name redis \-p 6380:6379 \-v /root/redis/conf:/usr/local/etc/redis \-v /root/redis/data:/data \-d \--network ruoyi   \redis:6.0.8 \redis-server /usr/local/etc/redis/redis.conf</code></pre><p>3、创建 nginx 容器</p><pre><code class="highlight linux">docker run -d \  --name nginx \  -p 81:80 \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \  --network ruoyi  \  nginx:1.22</code></pre><p>由于 nginx 的配置文件容器出错，我们可以先创建一个 nginx 容器复制其配置文件，再删除它。</p><pre><code class="highlight plaintext"># 复制配置docker cp nginx:/etc/nginx/nginx.conf /root/nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d /root/nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html /root/nginx/</code></pre><p>4、部署后端 Dokcerfile</p><pre><code class="highlight linux"># 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 挂载目录VOLUME /home/ruoyi# 创建目录RUN mkdir -p /home/ruoyi# 指定路径WORKDIR /home/ruoyi# 拷贝jar包COPY /root/ruoyi-admin.jar /home/ruoyi/app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</code></pre><p>5、创建项目镜像</p><pre><code class="highlight linux">docker build -t ruoyi:1.0 -f /root/Dockerfile .</code></pre><p>6、创建项目容器</p><pre><code class="highlight linux">docker run -d \--name ruoyi  \-p 8081:8081  \-v /root/ruoyi/uploadPath:/home/ruoyi/uploadPath \--network \ruoyi  \ruoyi:1.0</code></pre><p>7、最后运行容器</p><pre><code class="highlight plaintext">docker run -d \-p 81:80 \-p 443:443 \--name nginx \--restart=always \--network ruoyi \-e TZ=&quot;Asia/Shanghai&quot; \-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /root/nginx/conf/conf.d:/etc/nginx/conf.d \-v /root/nginx:/var/log/nginx \-v /root/nginx/html:/usr/share/nginx/html \-v /root/nginx/cert:/etc/nginx/cert \nginx:1.22</code></pre><p>现在可以通过 服务器id : nginx端口 访问界面了！</p><p><img src="/2024/03/19/Docker/image-20240322095418176.png" alt="image-20240322095418176"></p><p>其中容易出错的点是配置 nginx 时，其配置文件对于后端的映射。</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网小记</title>
      <link href="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><p>TCP：面向连接、可靠、面向字节流</p><p>UDP：无连接、不可靠、面向报文</p><p>TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多</p><p>应用场景：</p><p>TCP：FTP 文件传输、HTTP &#x2F; HTTPS</p><p>UDP：实时应用、游戏</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/image-20240316164317006.png" alt="image-20240316164317006"></p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong>。</p><p><strong>第一次握手：</strong>客户端首先也创建传输运输块，向服务器发出连接请求报文，将标志位 SYN 置为 1，选择一个初始序列号 seq&#x3D;x。SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。</p><p><strong>第二次握手：</strong>服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态。</p><p>第三次握手：TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立。</p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传代码</title>
      <link href="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><blockquote><p>git log：查看提交记录（作者、邮箱）</p><p>git status：查看哪些文件被提交</p><p>git ls-files：查看暂存区的内容 默认是mixed，也就是回退时保留工作区文件，但移除暂存区文件</p><p>git reflog：查看历史记录</p><p>git reset 回退分支</p><p>git diff：比较工作区和暂存区的差别  –cached 比较暂存区和版本库的差异</p><p>git rm：将文件从工作区和暂存区都删除    –cached：把文件从暂存区删除，但保留在工作区</p><p>git checkout – filename    从暂存区恢复文件到工作区</p><p>git commit -am “”  一个命令同时添加到暂存区和提交到本地仓库</p></blockquote><p>.gitignore：忽略加入暂存区的文件</p><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><pre><code class="highlight plaintext">cd .sshssh-keygen -t rsa -b 4096</code></pre><p>git remote -v：查看本地仓库所对应的远程仓库的别名和地址</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建分支：git branch dev</p><p>切换分支：git switch dev</p><p>合并分支：git merge dev 把 dev 分支合并到 main 分支中</p><p><img src="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/image-20240318164945891.png" alt="image-20240318164945891"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/12/JVM%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312160432882.png" alt="image-20240312160432882"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：加载类的信息到JVM中。当 Java 程序需要使用某个类时，类加载子系统负责找到对应的.class文件，并将其加载到JVM的方法区中。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>加载：将.class文件的二进制字节流读入内存。将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p><p>验证：确保该类的字节码文件中所包含的信息是否符合当前虚拟机的要求。</p><p>准备：为静态变量分配内存，并设置一个初始值。除了被final修饰的类变量，该类型会在编译期就已经被分配并确定。</p><p>解析</p><p>初始化：为静态变量、静态代码块进行真正初始化</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 在尝试加载一个类时，系统首先判断这个类是否被加载过，已经加载的类直接返回，否则才会尝试加载。类加载器会先委托给它的父加载器去尝试加载这个类，一直到达顶层的类（Bootstrap）只有在父加载器无法加载该类时（找不到对应的类），子加载器才会尝试去加载。</p><h2 id="native、方法区"><a href="#native、方法区" class="headerlink" title="native、方法区"></a>native、方法区</h2><p>方法区：存放已加载的类的信息，常量、静态变量 等。方法区是线程共享的内存区域，它在JVM启动的时候被创建，并且随着类的加载而动态扩展。方法区中包含着常量池。native 关键字的方法会调用底层 C 语言的库，会进入本地方法库，进而调用本地方法接口，</p><h2 id="JVM-虚拟机栈"><a href="#JVM-虚拟机栈" class="headerlink" title="JVM 虚拟机栈"></a>JVM 虚拟机栈</h2><p>每个Java虚拟机线程都有一个私有的Java栈，与线程同时创建。Java栈中保存着帧信息，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>局部变量表、操作数栈、动态链接、方法返回地址。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312192522896.png" alt="image-20240312192522896"></p><p>GC 垃圾回收，主要是在伊甸园区和养老区</p><ul><li><p>新生代：诞生、成长、死亡的地方。分为伊甸园区、From、To 幸存区（0,1）。</p></li><li><p>老年代</p></li></ul><p>大多数情况下，对象在新生代中 Eden 区分配。当Eden区满了之后，会触发一次Minor GC（也就是轻GC）。新生代中的存活对象是从Eden区和当前正在使用的一个Survivor区（我们可以称之为From区）复制到另一个Survivor区（我们可以称之为To区）。复制过程完成后，Eden区和From区将被清空。如果Survivor区容不下Eden区的所有存活对象，那么部分或者全部存活对象将直接被晋升到老年代。</p><p><strong>由于这个互换，保证了在每次垃圾收集结束后，总有一个Survivor区（to）是空的，这是为了下次垃圾收集时有空间来存放从Eden和另一个Survivor（from）区复制过来的存活对象。</strong></p><p>在survivor中，相同年龄的所有对象大小大于survivor的一半空间。年龄大于或等于该年龄的对象可以进入老年代。</p><p>在 jdk8 后，永远存储区改了个名字（元空间）：这个区域在本地内存，存储的是 java 运行时的一些环境或类信息。这个区域不存在垃圾回收。方法区在元空间</p><p>非堆内存：方法区、元空间</p><ul><li>JDK 1.8 之后，无永久代，替代为元空间，不存在于 JVM，使用的是本地内存。</li></ul><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312200859515.png" alt="image-20240312200859515"></p><h2 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h2><p>GC 的算法有哪些？标记清楚法、引用计数法</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。问题：效率不高、标记清楚后会产生大量内存碎片。</li><li>复制算法：按照容量把堆内存划分二个大小相等的内存区域（From、To），当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础小记</title>
      <link href="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指不同的子类对同一种行为有不同的表现形式。多态包括编译时多态（重载）和运行时多态（重写）。重载：方法名相同，参数列表不同（参数个数、类型、顺序），返回值、访问修饰符也可以不同。</p><h3 id="String-的不可变"><a href="#String-的不可变" class="headerlink" title="String 的不可变"></a>String 的不可变</h3><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173405251.png" alt="image-20240222173405251"></p><p>修改 s 变量时，不在原来的地址上修改，而是指向新的引用地址。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173659994.png" alt="image-20240222173659994"></p><p>value 用 final 修饰，指的是 value 变量的引用不能更改，不能指向其他地址。</p><p>但数组本身是可以修改值的，这并不会对其地址有影响。</p><ul><li>设计成不可变，可以使用字符串常量池。</li></ul><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？</h3><p>1 个或 2 个。一、如果字符串常量池中没有字符串对象 “abc” 的引用，则它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222170700469.png" alt="image-20240222170700469"></p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><blockquote><p>对于 String &#x3D; “abc”，如果常量池中有 “abc” 字符串对象，就直接指向它；否则会在常量池中创建一个 “abc” 字符串对象。</p></blockquote><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><p>三种方式：重写 clone() 方法、<strong>通过序列化实现</strong>、<strong>利用反射方式实现</strong></p><h2 id="String-类型的变量和常量用-“-”-运算符发生了什么？"><a href="#String-类型的变量和常量用-“-”-运算符发生了什么？" class="headerlink" title="String 类型的变量和常量用 “+” 运算符发生了什么？"></a>String 类型的变量和常量用 “+” 运算符发生了什么？</h2><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;<span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;System.out.println(str3 == str4);<span class="comment">//false</span>System.out.println(str3 == str5);<span class="comment">//true</span>System.out.println(str4 == str5);<span class="comment">//false</span></code></pre><ul><li><p>对于 String str3 &#x3D; “str” + “ing”;<code>编译器会优化成</code>String str3 &#x3D; “string”;</p></li><li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p></li></ul><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</code></pre><p>String str &#x3D; “abc” + new String(“def”); 创建了几个对象？（假设常量池中没有缓存）</p><p>这会被优化为 </p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>);<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;abc&quot;</span>).append(s).toString();</code></pre><p>创建了 5 个对象  new StringBuilder() -&gt; “abc” -&gt; “def” -&gt; new String() -&gt; toString()</p><h2 id="先执行-return-还是-finally"><a href="#先执行-return-还是-finally" class="headerlink" title="先执行 return 还是 finally"></a>先执行 return 还是 finally</h2><p>return 在 finally 前：先执行 finally ，再执行该 return；</p><p>finally 内含有 return 时，直接执行其 return 后结束；</p><p>return 在 finally 后，执行完 finally 后再执行 return。</p><h2 id="final-可以加在哪里，有什么作用"><a href="#final-可以加在哪里，有什么作用" class="headerlink" title="final 可以加在哪里，有什么作用"></a>final 可以加在哪里，有什么作用</h2><p>类：这个类不能被继承，<code>final</code> 类中的所有成员方法都隐式地指定为 <code>final</code>，但是字段不自动成为 <code>final</code>。</p><p>方法：这个方法不能被子类覆盖或重写。</p><p>变量：该变量的值一旦被初始化之后就不能被改变。对于基本数据类型，它的值不能被改变。对于引用类型，它的引用不能改变，但对引用的对象本身是可以修改的。</p><h2 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h2><p>每个线程都有一个私有的本地内存，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。如果线程间需要通信，必须通过主内存来进行。<img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240313145809511.png" alt="image-20240313145809511"></p><h2 id="Java-的锁"><a href="#Java-的锁" class="headerlink" title="Java 的锁"></a>Java 的锁</h2><p>分为本地锁和分布式锁。</p><p>在单机（单 JVM）情况下，线程之间共用一个 JVM，只要使用线程锁就可以解决并发问题。但在分布式情况下，线程 A 与 线程 B 可能不在一个 JVM 下，我们需要分布式锁。</p><p>常用的本地锁：synchronized 和 lock。</p><h3 id="synchronized-底层原理："><a href="#synchronized-底层原理：" class="headerlink" title="synchronized 底层原理："></a>synchronized 底层原理：</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);        &#125;    &#125;&#125;</code></pre><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240314143223478.png" alt="image-20240314143223478"></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><h3 id="锁的如何升级的"><a href="#锁的如何升级的" class="headerlink" title="锁的如何升级的"></a>锁的如何升级的</h3><p><strong>偏向锁：</strong>当线程第一次获得锁，通过 CAS 修改对象头中的锁标志位，这就是偏向锁。只适用于只有一个线程访问同步区域的场景。线程在后续访问时检测 Mark Word 里是否存储着指向当前线程的偏向锁。</p><p><strong>轻量级锁：</strong>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁。在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。</p><p><strong>重量级锁：</strong>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><h3 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h3><ul><li><p>volatile 只能修饰变量，synchronized 可以修饰方法，代码块，类</p></li><li><p>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程。</p></li><li><p>volatile读相当于获取了一个锁（读取了从主存中最新的值，防止读到过期数据），volatile写相当于释放了一个锁（立即将更改的值写入主存，防止其它线程读到过期数据）。<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p></li><li><p>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</p></li></ul><h3 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h3><p>ReentrantLock 需要手动获取锁、释放锁。</p><p>二者都是可重入锁。</p><p>synchronized 是 JVM 实现的，ReentrantLock 是 API 实现的。</p><p>ReentrantLock 是可中断的，可以指定是否为非公平锁。</p><h3 id="AQS-是什么"><a href="#AQS-是什么" class="headerlink" title="AQS 是什么"></a>AQS 是什么</h3><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。以 <code>ReentrantLock</code> 为例，<code>state</code> 初始值为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（<code>state</code> 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p><p>Cookies 和 Session 的区别</p><p>1、当用户第一次登录成功后，服务器会创建一个 Session，并为这个 Session 创建唯一的 SessionID。Session 保存在服务器端，保存了用户的状态信息。</p><p>2、服务器将这个唯一的 SessionID 存储到一个 Cookies 中，并通过 HTTP 响应将该 Cookies 发生给用户的 Web 浏览器。</p><p>3、用户的浏览器会保存这个 Cookies，后续请求都会携带此 Cookies 发送回服务器。</p><p>4、服务器会读取 Cookies 中的 SessionID，通过它找到 Session 数据，里面包含了用户的状态信息，如登录凭证、购物车内存等。</p><p>5、当用户退出登录或 Session 过期后，服务器会销毁 Session 数据。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>池化思想：线程池、字符串常量池、数据库连接池</p><p>提高资源的利用率</p><p>1、手动创建线程对象</p><p>2、执行任务</p><p>3、执行完毕，释放线程对象</p><p>线程池在系统中开辟一块区域，存放一些待命的线程，这些线程会等待任务的到来。一旦有任务需要执行，线程池会从这些待命的线程中选取一个来执行任务，任务执行完毕后，线程会返回线程池等待下一次的任务分配。</p><p><strong>资源重用</strong>：手动创建线程的话用完就销毁了，线程池显著降低了线程创建和销毁所带来的资源消耗。</p><p><strong>提高响应速度</strong>：由于线程池已经预先存在，任务到达可以立即执行，不需要等待线程创建。</p><p><strong>控制并发数</strong>：线程池可以有效地控制并发执行的任务数量，通过设置线程池的核心线程数、最大线程数以及队列大小等参数，根据系统的承载能力限制并发级别。</p><h3 id="线程池的7个参数和工作原理"><a href="#线程池的7个参数和工作原理" class="headerlink" title="线程池的7个参数和工作原理"></a>线程池的7个参数和工作原理</h3><pre><code class="highlight java"><span class="type">int</span> corePoolSize,    <span class="comment">// 核心线程数，创建后不会被回收</span><span class="type">int</span> maximumPoolSize,   <span class="comment">// 最大线程数，当核心线程数已满、最大线程数未满，就创建一个新线程</span><span class="type">long</span> keepAliveTime,  <span class="comment">// 空闲线程存活时间，当可被回收的线程大于keepAliveTime被回收</span>TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 工作队列，当提交的任务超过核心线程数，再提交的任务就放到工作队列</span>ThreadFactory threadFactory,  <span class="comment">// 线程工厂，可以设定线程名、线程编号等</span>RejectedExecutionHandler handler <span class="comment">// 拒绝策略</span></code></pre><h3 id="怎么关闭线程池？"><a href="#怎么关闭线程池？" class="headerlink" title="怎么关闭线程池？"></a>怎么关闭线程池？</h3><p>shutdown()：会在当前运行的线程执行完任务后关闭它们。</p><p>shutdownNow()：会试图停止所有正在执行的任务，并返回还没有开始执行的任务。并不保证每个任务都能成功停止，因为这个方法本质是对线程池每个线程调用了 interrupt() 方法来尝试取消线程的执行，但中断一个线程是非强制性的，也就是它只是给线程发送了一个取消的信号，而线程能否响应，怎样响应是取决于线程本身的。</p><h2 id="Java-线程通信的主要方式"><a href="#Java-线程通信的主要方式" class="headerlink" title="Java 线程通信的主要方式"></a>Java 线程通信的主要方式</h2><p><strong>volatile关键字</strong>：</p><ul><li>所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存</li><li>所有volatile修饰的变量在使用之前必须重新读取主内存的值</li></ul><p><strong>等待&#x2F;通知机制</strong>：等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h3><ul><li>安全性：HashMap 是线程不安全的，HashTable 是线程安全的</li><li>HashMap 可以使用null作为key，Hashtable则不允许null作为key</li><li>扩容：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:<code>capacity</code> *<code>2</code><strong>，Hashtable扩容时是容量翻倍+1即:</strong><code>capacity</code>* <code>(2+1)</code>。</li></ul><h3 id="HashMap-1-7-和-1-8"><a href="#HashMap-1-7-和-1-8" class="headerlink" title="HashMap 1.7 和 1.8"></a>HashMap 1.7 和 1.8</h3><p>1.7 底层是数组加链表，1.8底层是数组+链表+红黑树。</p><p>当 put 一个 Node 时，会计算 key 的 hashcode， 再通过将 hashcode 与 (n - 1) 进行与运算，有两种情况：</p><p>1、数组索引的元素是空的，这种情况很简单，直接将元素放进去就好了。</p><p>2、已经有元素占据了索引位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。<strong>如果两者相等则直接覆盖</strong>，<strong>如果不等则在原元素下面使用链表的结构存储该元素</strong></p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240320110614657.png" alt="image-20240320110614657"></p><p>当链表的元素个数达到8并且数组长度超过64的时候使用链表存储就转变成了使用红黑树存储。</p><p>HashMap中有两个重要的参数：<strong>初始容量大小和加载因子</strong>。初始容量大小为 16，默认加载因子为 0.75。</p><h3 id="为什么-HashMap-不安全"><a href="#为什么-HashMap-不安全" class="headerlink" title="为什么 HashMap 不安全?"></a>为什么 HashMap 不安全?</h3><ul><li>JDK1.7 HashMap线程不安全体现在：死循环、数据丢失</li><li>JDK1.8 HashMap线程不安全体现在：数据覆盖</li></ul><p>JDK 1.8：假设两个线程A、B都在进行put操作，并且hash函数计算出的插入下标是相同的，当线程A执行完第六行代码后由于时间片耗尽导致被挂起，而线程B得到时间片后在该下标处插入了元素，完成了正常的插入，然后线程A获得时间片，由于之前已经进行了hash碰撞的判断，所有此时不会再进行判断，而是直接进行插入，这就导致了线程B插入的数据被线程A覆盖了，从而线程不安全。</p><h3 id="线程安全的-List"><a href="#线程安全的-List" class="headerlink" title="线程安全的 List"></a>线程安全的 List</h3><p>CopyonWriteArraylist：读写、读读都不互斥，只有写写互斥。多个线程可以同时读。</p><pre><code class="highlight java"><span class="comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 加锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 获取原来的数组</span>        Object[] elements = getArray();        <span class="comment">// 原来数组的长度</span>        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;        <span class="comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);        <span class="comment">// 元素放在新数组末尾</span>        newElements[len] = e;        <span class="comment">// array指向新数组</span>        setArray(newElements);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">// 解锁</span>        lock.unlock();    &#125;&#125;</code></pre><p>也就是对数组进行增加元素时，会复制出一份新的数组，并将元素加到新的数组。</p><p>对数组进行修改时，会分段复制，index 前的和 index 后的分别复制到新数组。</p><h1 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h1><h2 id="介绍下-Spring-IOC-和-Spring-Aop"><a href="#介绍下-Spring-IOC-和-Spring-Aop" class="headerlink" title="介绍下 Spring IOC 和 Spring Aop"></a>介绍下 Spring IOC 和 Spring Aop</h2><p>ioc 是控制反转，ioc 可以看作一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系。</p><p>aop 是面向切面编程，当类中的方法有大量冗余的且与业务无关的代码，我们可以将它们通过注解方式抽离出来，让开发者只关心业务逻辑。</p><h2 id="Spring-常见的一些模块"><a href="#Spring-常见的一些模块" class="headerlink" title="Spring 常见的一些模块"></a>Spring 常见的一些模块</h2><p>Spring Core：供 ioc 容器</p><p>Spring AOP</p><p>Spring DAO：JDBC的抽象层</p><p>Spring ORM：实体关系映射</p><p>Spring Web</p><p>Spring Web MVC</p><h4 id="Spring-Test：单元测试"><a href="#Spring-Test：单元测试" class="headerlink" title="Spring Test：单元测试"></a>Spring Test：单元测试</h4><h2 id="动态获取spring容器里面的bean"><a href="#动态获取spring容器里面的bean" class="headerlink" title="动态获取spring容器里面的bean"></a>动态获取spring容器里面的bean</h2><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);</code></pre><h2 id="Autowired-和-Resource"><a href="#Autowired-和-Resource" class="headerlink" title="@Autowired 和 @Resource"></a>@Autowired 和 @Resource</h2><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</p><h2 id="Spring-三级缓存解决循环依赖"><a href="#Spring-三级缓存解决循环依赖" class="headerlink" title="Spring 三级缓存解决循环依赖"></a>Spring 三级缓存解决循环依赖</h2><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h2><p>#{} 方式是先用占位符代替参数将SQL语句先进行预编译，再将参数中的内容替换进来。由于SQL语句已经被预编译过，其SQL意图将无法通过非法的参数内容实现更改，其参数中的内容，无法变为SQL命令的一部分。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="join-和-left-join"><a href="#join-和-left-join" class="headerlink" title="join 和 left  join"></a>join 和 left  join</h2><p>JOIN：返回两个表中都有匹配的行</p><p>left JOIN：返回左表的所有行，如果在右表没有为 null。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试常见知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 有三种方式初始化：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;    Object[] a = c.toArray();    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;            elementData = a;        &#125; <span class="keyword">else</span> &#123;            elementData = Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// replace with empty array.</span>        elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><ul><li>无参方式创建时，初始化为空数组，等到第一个元素 add 时，数组才扩容到默认值 10。</li></ul><p>先从 add 方法入手：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>第一次 add 时，size 为 0，我们进入 ensureCapacityInternal 方法：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>在 calculateCapacity 这个方法中，如果当前数组为空（第一次 add 时），就返回默认容量和最小容量中的较大值作为所需容量。否则直接返回 minCapacity。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="keyword">return</span> minCapacity;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    modCount++;    <span class="comment">// overflow-conscious code</span>    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)        grow(minCapacity);&#125;</code></pre><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    <span class="comment">// overflow-conscious code</span>    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)        newCapacity = minCapacity;    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>到这里为止，我们添加第一个元素，数组容量由 空数组 扩容到容量为 10 的数组。如何扩容的呢？ 核心实现在 grow 方法中，此时 minCapacity &#x3D; 10， newCapacity &#x3D; 0，第一个 if 满足条件，newCapacity 赋值为 10。数组被复制到一个扩容后的新数组。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;  <span class="comment">// 申请一个新的数组</span>    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,                     Math.min(original.length, newLength));    <span class="keyword">return</span> copy;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList扩容机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/01/20/Java%E9%9B%86%E5%90%88/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/01/20/Java%E9%9B%86%E5%90%88/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>偏向锁：</strong></p><ul><li><strong>适用场景：</strong> 主要针对单线程情况下的锁操作，即在锁的竞争不激烈的情况下。</li><li><strong>特点：</strong> 当一个线程获取了偏向锁后，如果再次进入同步块，无需重新获取锁，因为锁已经偏向于该线程。这减少了不必要的锁竞争，提高了性能。</li><li>原理：CAS 在对象头和栈帧中存储对象的 ID，如果一直都是同一个线程获取此锁，则完全没有必要再进行额外的 CAS 操作。</li></ul><p><strong>轻量级锁：</strong></p><ul><li><strong>适用场景：</strong> 针对线程交替访问同步块的场景，即锁的竞争较为频繁，但竞争的线程少于等于两个。</li><li><strong>特点：</strong> 使用CAS（Compare And Swap）操作来尝试获取锁，避免了传统的重量级锁的性能开销。如果CAS成功，当前线程就获得了锁，否则会升级为重量级锁。</li><li>原理：将对象头中的 Mark Word 复制到锁记录（Lock Record）空间中，然后线程尝试用 CAS 将对象头中的 Mark Word 替换为指向锁记录（Lock Record）的指针。如果成功，当前线程获得锁。如果失败，JVM 再次检查对象的 Mark Word，是否指向当前对象的栈帧，如果是，说明当前对象已经有了这个对象的锁，直接进入同步代码块即可。如果不是，表示有其他线程竞争锁，当前线程使用自旋来获取锁。</li></ul><p><strong>自旋：</strong></p><p>![image-20240124105626306](..&#x2F;..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20240124105626306.png)</p><p>（在大多数应用上，每一个线程占用同步代码块的时间不会很长）当多个线程抢占资源时，没有必要将竞争中的线程挂起又唤醒，而是通过无限循环的方式，不断检测是否能够获取锁。</p><p>如果仅仅在等待时间短的情况下，自旋锁表现很好；但如果等待时间长了，循环会耗费大量处理器资源，如果超过等待时间，则升级为重量级锁。</p><h3 id="内存重排序"><a href="#内存重排序" class="headerlink" title="内存重排序"></a>内存重排序</h3><ul><li><strong>处理器A</strong> 执行以下两个操作：<ol><li>写操作：将值<code>1</code>写入变量<code>x</code>。</li><li>读操作：读取变量<code>y</code>的值。</li></ol></li><li><strong>处理器B</strong> 执行以下两个操作：<ol><li>写操作：将值<code>1</code>写入变量<code>y</code>。</li><li>读操作：读取变量<code>x</code>的值。</li></ol></li><li>初始时，假设变量<code>x</code>和<code>y</code>都是<code>0</code>。</li></ul><p>由于处理器的写缓冲区，这些操作可能会被重新排序。例如：</p><ul><li><strong>处理器A</strong> 可能先执行了读<code>y</code>的操作，此时<code>y</code>还是<code>0</code>，因为处理器B的写操作还在写缓冲区中，尚未刷新到主内存。</li><li>同时，<strong>处理器B</strong> 可能也先执行了读<code>x</code>的操作，此时<code>x</code>也是<code>0</code>，因为处理器A的写操作还在写缓冲区中。</li></ul><p>写操作可能涉及复杂的内存访问，如缓存未命中时需要更长时间来完成。与此同时，后续的读操作（如果不依赖于写操作的结果）可能可以立即执行，不必等待写操作完成。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p><strong>JMM关于synchronized的两条规定（可见性）：</strong></p><ul><li>线程释放锁时，会把该线程对应的工作内存中的共享变量的值刷新到主内存中。</li><li>线程获取锁时，该线程对应的工作内存置为无效，从而使用共享变量时，需要从主内存中重新读取最新的值。</li></ul><p><code>synchronized</code>既能够保证可见性，又能保证原子性，而<code>volatile</code>只能保证可见性，无法保证原子性。</p><p>谈谈可见性定义、实现</p><h3 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h3><p>此关键字第一个作用：保证被修饰变量的可见性。保证了所有线程看到的该变量的值都是最新的。</p><p><strong>volatile如何实现内存可见性</strong></p><p>深入来说：通过加入内存屏障和禁止重排序优化来实现的</p><ul><li>对<code>volatile</code>变量执行写操作时，会在写操作后加入一条<code>store</code>屏障指令（保证 volatile 变量写操作对后续的普通写操作可见）</li><li>对<code>volatile</code>变量执行读操作时，会在读操作前加入一条<code>load</code>屏障指令（这是要保证 volatile 变量读取到的值是最新的）</li></ul><p><strong>volatile 写-读的内存语义：</strong></p><p>当写一个 volatile 变量时，JVM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><p>当读一个 volatile 变量时，JVM 会把该线程对应的本地内存置为无效。线程接下来从主内存中读取共享变量。</p><h3 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h3><p>一个操作执行的结果需要对另一个操作可见，那么这两个操作直接必须要存在 happens-before 关系（两个操作间存在 happens-before关系，并不意味着前一个操作就必须要在后一个操作之前执行，只要求前一个操作对后一个操作可见，且前一个操作按顺序排在后一个操作之前）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传图片</title>
      <link href="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>今天在使用 typora 写好笔记后，上传至 hexo 服务器，发现图片还是读取的本地路径。通过参考其他人的经验找到一种解决方法。</p><p>1、在 typora 设置中勾选如下选项，作用是图片使用相对路径。</p><p><img src="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20240106172757156.png" alt="image-20240106172757156"></p><p>2、安装插件即可，不需要再设置<code>图片根目录</code>。</p><pre><code class="highlight javascript">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></code></pre><p>至此在浏览器就可以正常显示图片了。（ps: 前提是根目录下的_config.yml文件中的post_asset_folder字段已经设置为true）</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合</title>
      <link href="/2024/01/06/Java%E9%9B%86%E5%90%88/"/>
      <url>/2024/01/06/Java%E9%9B%86%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231228215407955.png" alt="image-20231228215407955"><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231228215505374.png" alt="image-20231228215505374"></p><p>出现这种情况的原因是 Java 内存模型，线程从主内存复制一份，先放到工作内存，再放到主内存，释放锁，而另一个线程修改的不一样，导致结果不一样。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>Collection：集合框架最基础的接口，最顶层的接口</p><p>List：Collection 的子接口，存储有序、可重复的对象，最常用的接口。</p><p>Set：Collection 的子接口，存储有序、唯一（元素不可重复）的对象。</p><p>Map：独立于 Collection 的另外一个接口，最顶层的接口，存储一组键值对象，提供键到值的映射。</p><p>Iterator：输出集合元素的接口，一般适合无序集合，从前往后输出。</p><p>ListIterator：Iterator 的子接口，可以双向输出集合中的元素。</p><p>Enumeration：传统的输出接口，已经被 Iterator 取代。</p><p>SortedSet：Set 的子接口，可以对集合中的元素进行排序。</p><p>SortedMap：Map 子接口，可以对集合中的元素进行排序。</p><p>Queue：队列接口。</p><p>Map Entry：Map 的内部接口，描述 Map 中存储的一组键值对元素。</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>Collection 是集合框架最基础的接口，可以存储一组无序、重复的对象。</p><h2 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h2><p>List 常用的扩展方法：</p><pre><code class="highlight java">E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>;  通过下标返回集合中对应位置的元素</code></pre><pre><code class="highlight java">E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span>;  在集合中指定位置存入对象</code></pre><pre><code class="highlight java"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(Object o)</span>;  查找某个对象在集合中的位置</code></pre><pre><code class="highlight java"><span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(Object o)</span>;  返回指定元素最后一次出现的位置</code></pre><pre><code class="highlight java">ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span>;  实例化 ListIterator 接口，用来遍历 List 集合</code></pre><pre><code class="highlight java">List&lt;E&gt; <span class="title function_">subList</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span>;  通过下标截取 List 集合</code></pre><h3 id="List-接口的实现类"><a href="#List-接口的实现类" class="headerlink" title="List 接口的实现类"></a>List 接口的实现类</h3><p>ArrayList：实现了长度可变的数组，在内存中分配连续空间，所以读取快，增删慢。非线程安全。</p><p>Vector：线程安全，但效率低，实现线程安全直接通过 synchronized 修饰方法来完成。</p><p>Stack：Vector 的子类，实现了栈的数据结构（后进先出）</p><p>ArrayList 和 ListedList 区别：内存中存储的形式不同，ArrayList 采用的是数组的方式，LinkedList 采用的是链表的方式。</p><p>ListedList 实现了 Deque 接口，而 Deque 是 Queue 的子接口，Queue 底层实现了队列的数据结构。</p><p>Queue 的实现类是 AbstractQueue，它是一个抽象类，不能直接实例化，开发中使用 PriorityQueue 类。</p><p>Queue 添加的数据必须是有序的。</p><pre><code class="highlight java"><span class="keyword">package</span> Collection;<span class="keyword">import</span> java.util.AbstractQueue;<span class="keyword">import</span> java.util.PriorityQueue;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PriorityQueueTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        PriorityQueue&lt;Object&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();<span class="comment">//        queue.add(&quot;wdcp&quot;);</span><span class="comment">//        queue.add(&quot;hdcp&quot;);</span><span class="comment">//        queue.add(&quot;dcp&quot;);</span>        queue.add(<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">1</span>));        queue.add(<span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">2</span>));        System.out.println(queue);    &#125;&#125;<span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="keyword">public</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="built_in">this</span>.num = num;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> (A) o;        <span class="keyword">return</span> <span class="built_in">this</span>.num - a.num;    &#125;&#125;</code></pre><p>Queue 默认给元素进行升序排序。</p><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>Set 集合以散列形式存储数据，所以元素是没有顺序的。</p><p>Set 常用实现类：</p><ul><li>HashSet</li><li>LinkedHashSet</li><li>TreeSet</li></ul><p>HashSet 存储一组<strong>无序</strong>（元素存储顺序和遍历顺序不一致）且唯一的对象。</p><p>LinkedHashSet：可以存储<strong>有序（元素存储顺序和遍历顺序一致）</strong>且唯一的元素</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231230210121262.png" alt="image-20231230210121262"></p><p>LinkedHashSet 如何判断两个对象是否相等？</p><p>首先会判断两个对象的 hashCode 是否相等</p><p>什么是 hashCode？将对象的内部信息（内存地址、属性值），通过某种特定规则转换成一个散列值，就是该对象的 hashCode。</p><ul><li>两个不同对象的 hashCode 值可能是相等的。</li><li>hashCode 不相等的对象一定不是同一个对象。</li></ul><p>集合在判断两个对象是否相等的时候，首先会先比较它们的 hashCode，如果不等，肯定不是同一个对象，可以添加。</p><p>如果 hashCode 相等，再判断 equals 进行进一步判断，如果 equals 相等，则两个对象相等。</p><pre><code class="highlight java"><span class="keyword">package</span> Collection;<span class="keyword">import</span> java.util.HashSet;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.LinkedHashSet;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        LinkedHashSet&lt;Object&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();        linkedHashSet.add(<span class="string">&quot;wdcp&quot;</span>);        <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);        linkedHashSet.add(b);        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(<span class="number">1</span>);        linkedHashSet.add(b1);        linkedHashSet.add(<span class="number">1</span>);        System.out.println(linkedHashSet);        System.out.println(b.equals(b1));  <span class="comment">// true，但还是存了两次，set认为它们还是两个对象</span>    &#125;&#125;<span class="keyword">class</span> <span class="title class_">B</span> &#123;    <span class="keyword">private</span> <span class="type">int</span> num;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;B&#123;&quot;</span> +                <span class="string">&quot;num=&quot;</span> + num +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="built_in">this</span>.num = num;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;        <span class="keyword">if</span>(<span class="built_in">this</span> == obj)&#123;            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> B)&#123;            <span class="type">B</span> <span class="variable">b</span> <span class="operator">=</span> (B) obj;            <span class="keyword">return</span> <span class="built_in">this</span>.num == b.num;        &#125;        <span class="keyword">return</span> <span class="literal">false</span>;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="number">1</span>;    &#125;&#125;</code></pre><h3 id><a href="#" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h3><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20231231144623559.png" alt="image-20231231144623559"></p><p>栈中存储的是变量，引用类型具体的对象（属性）存储再堆中的，再将堆中的对象地址赋值给栈中的变量。 基本数据类型变量的值直接存在栈中。</p><p><strong>&#x3D;&#x3D;：判断的是栈内存中的值。</strong></p><p>引用类型的数据，栈内存中存储的是地址，所以此时 &#x3D;&#x3D; 判断的是引用地址。</p><p>基本数据类型，栈内存中存储的是具体的数值。</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>LinkedHashSet 和 TreeSet 都是存储一组有序且唯一的数据，但这里的两个有序有区别的。</p><p>LinkedHashSet 的有序指元素的存储顺序与遍历顺序是一致的。</p><p>TreeSet 的有序是指集合内部自动按照升序排列，无论存入的顺序是什么，遍历一定按照升序输出。</p><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>key-value，数据字典</p><p>List、Set 接口都是 Collection 的子接口，Map 接口是与 Collection 完全独立的另外一个体系。</p><table><thead><tr><th>Set<K> keySet();</K></th><th>取出集合中所有的 key，返回一个 Set</th></tr></thead><tbody><tr><td>Collection<V> values();</V></td><td>取出集合中所有的 values，返回一个 Collection</td></tr><tr><td>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</td><td>将 Map 以 Set 输出</td></tr></tbody></table><h3 id="Map-接口的实现类"><a href="#Map-接口的实现类" class="headerlink" title="Map 接口的实现类"></a>Map 接口的实现类</h3><ul><li>HashMap：存储一组无序，key 不能重复，value 可以重复的元素</li><li>Hashtable：存储一组无序，key 不能重复，value 可以重复的元素。</li><li>TreeMap：存储一组有序，key 不能重复，value 可以重复的元素，可以按照 key 进行排序。</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Map;<span class="keyword">import</span> java.util.*;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        HashMap&lt;Object, Object&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        hashMap.put(<span class="string">&quot;h&quot;</span>, <span class="string">&quot;Hello&quot;</span>);        hashMap.put(<span class="string">&quot;w&quot;</span>, <span class="string">&quot;World&quot;</span>);        hashMap.put(<span class="string">&quot;j&quot;</span>, <span class="string">&quot;Java&quot;</span>);        System.out.println(hashMap);        Set&lt;Object&gt; sets = hashMap.keySet();        Iterator&lt;Object&gt; iterator = sets.iterator();        <span class="keyword">while</span> (iterator.hasNext()) &#123;            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> (String)iterator.next();            <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> (String) hashMap.get(key);            System.out.println(key + <span class="string">&quot;-&quot;</span> + value);        &#125;        Collection&lt;Object&gt; values = hashMap.values();        <span class="keyword">for</span>(Object value: values) &#123;            System.out.println(value);        &#125;    &#125;&#125;</code></pre><p>Hashtable 与 HashMap 用法基本一样，区别是 Hashtable 是线程安全的，但性能较低。HashMap 是非线程安全的，性能较高。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><pre><code class="highlight java"><span class="keyword">package</span> Collection.Map;<span class="keyword">import</span> java.util.Iterator;<span class="keyword">import</span> java.util.Set;<span class="keyword">import</span> java.util.TreeMap;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeMapTest1</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        TreeMap&lt;Object, Object&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">3</span>, <span class="string">&quot;cp&quot;</span>), <span class="string">&quot;cp&quot;</span>);        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">2</span>, <span class="string">&quot;dcp&quot;</span>), <span class="string">&quot;dcp&quot;</span>);        treeMap.put(<span class="keyword">new</span> <span class="title class_">User</span>(-<span class="number">1</span>, <span class="string">&quot;cpp&quot;</span>), <span class="string">&quot;cpp&quot;</span>);        System.out.println(treeMap);        Set&lt;Object&gt; set = treeMap.keySet();        Iterator&lt;Object&gt; iterator = set.iterator();        <span class="keyword">while</span> (iterator.hasNext()) &#123;            <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();            System.out.println(key + <span class="string">&quot;-&quot;</span> + treeMap.get(key));        &#125;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +                <span class="string">&quot;id=&quot;</span> + id +                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +                <span class="string">&#x27;&#125;&#x27;</span>;    &#125;    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(Integer id, String name)</span> &#123;        <span class="built_in">this</span>.id = id;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;            <span class="keyword">return</span> <span class="built_in">this</span>.id - user.id;        &#125;        <span class="keyword">return</span> <span class="number">0</span>;    &#125;&#125;</code></pre><p>TreeMap 会对 key 值进行排序，如果是自定义类，则需要重写 compareTo 方法。</p><h3 id="Collections-工具类"><a href="#Collections-工具类" class="headerlink" title="Collections 工具类"></a>Collections 工具类</h3><p>Collections 不是接口，是工具类，专门提供了一些对集合的操作，方便开发者去使用。</p><p>Collections.reverse(List&lt;?&gt; list) 为什么 Set 不能用 reverse？</p><p>能 reverse 要有顺序，而 Set 无序。</p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型（Generics），是指在类中定义时不指定类中信息的具体类型，而是暂时用一个标识符来替代，当外部实例化对象时再来指定具体的数据类型。</p><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>有一个参数为 ArrayList 的方法，希望这个方法既可以接受泛型是 String 的集合，又可以接受泛型是 Integer 的集合。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240101095510340.png" alt="image-20240101095510340"></p><p>不能这样，要么不写 Object。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240101095643330.png" alt="image-20240101095643330"></p><p>ArrayList&lt;?&gt; 表示可以使用任意的泛型类型对象，这样 test 就具有通用性。</p><h3 id="泛型上限和下限"><a href="#泛型上限和下限" class="headerlink" title="泛型上限和下限"></a>泛型上限和下限</h3><p>上限：表示实例化时具体的数据类型，可以是上限类型的子类或上限类型本身，用 extends 表示。</p><p>下限：表示实例化时具体的数据类型，可以是下限类型的父类或下限类型本身，用 super 表示。</p><p>类名&lt;泛型标识 extends 上限类名&gt;</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        test(<span class="keyword">new</span> <span class="title class_">Time1</span>&lt;Double&gt;());    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Time1&lt;? extends Number&gt; time1)</span>&#123;    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">(Time1&lt;? <span class="built_in">super</span> String&gt; time1)</span>&#123;    &#125;&#125;<span class="keyword">class</span> <span class="title class_">Time1</span>&lt;T&gt; &#123;&#125;</code></pre><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>接口<T> </T></p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MyInterface</span>&lt;T&gt; &#123;    T <span class="title function_">getValue</span><span class="params">()</span>;&#125;</code></pre><p>实现泛型接口有两种方式：</p><ul><li>实现类在定义时继续使用泛型标识</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceImpl</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&#123;    <span class="keyword">private</span> T obj;    <span class="keyword">public</span> <span class="title function_">MyInterfaceImpl</span><span class="params">(T obj)</span> &#123;        <span class="built_in">this</span>.obj = obj;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.obj;    &#125;&#125;</code></pre><ul><li>实现类在定义时直接给出具体的数据类型</li></ul><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyinterfaceImpl2</span> <span class="keyword">implements</span> <span class="title class_">MyInterface</span>&lt;String&gt; &#123;    <span class="keyword">private</span> String obj;    <span class="keyword">public</span> <span class="title function_">MyinterfaceImpl2</span><span class="params">(String obj)</span> &#123;        <span class="built_in">this</span>.obj = obj;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> String <span class="title function_">getValue</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="built_in">this</span>.obj;    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> Collection.Generics;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInterfaceTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">MyInterfaceImpl</span> <span class="variable">myInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>&lt;&gt;(<span class="string">&quot;wdcp&quot;</span>);        <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> (String)myInterface.getValue();        System.out.println(val);        <span class="type">MyinterfaceImpl2</span> <span class="variable">myinterfaceImpl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyinterfaceImpl2</span>(<span class="string">&quot;hecp&quot;</span>);        System.out.println(myinterfaceImpl2.getValue());    &#125;&#125;</code></pre><h2 id="Java-实用类"><a href="#Java-实用类" class="headerlink" title="Java 实用类"></a>Java 实用类</h2><ul><li>枚举</li></ul><p>枚举 Enum，是一个有确定值区间的数据结构，本质就是一个类。</p><p>为什么要有枚举？</p><p>因为在描述某些对象的属性时，该属性的值不能随便定义，必须在某个特定的区间取值。</p><p>枚举由一组常量组成的类型，指定一个取值区间，我们只能从该区间取值。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><ul><li>String 实例化</li></ul><p>1、直接赋值</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;wdcp&quot;</span>;</code></pre><p>2、通过构造函数创建对象</p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;wdcp&quot;</span>)</code></pre><ul><li>String 常用方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> ： 返回下标所对应的字符<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexof</span><span class="params">(String str)</span> ： 返回 str 在字符串中的下标<span class="keyword">public</span> String[] split(String regex) ： 用指定的字符串对目标分割，返回数组<span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span> ： 转小写<span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span> ： 转大写</code></pre><p>null 和空是两种概念，null 是指对象不存在，</p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>String 对象一旦创建，值不能修改（原来的值不能修改，一旦修改就是新的对象，只要一改动，就会创建一个新的对象）。</p><p>修改后会重新开辟内存空间来存储新的内存对象，会修改 String 的引用。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240102111455342.png" alt="image-20240102111455342"></p><p>String 为什么修改后会开辟新的空间创建新对象？不能在原先内存上直接修改吗？</p><p>因为 String 底层是用数组来存值的，数组长度一旦创建就不可修改，导致上述问题。</p><p>StringBuffer 可以解决 String 频繁修改造成资源浪费的问题。</p><p>StringBuffer 底层也是使用数组来存值。</p><ul><li>StringBuffer 数组的默认长度为 16</li><li>使用无参构造，默认长度是 16</li></ul><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103094946726.png" alt="image-20240103094946726"></p><ul><li>使用有参构造，长度是 值的长度 + 16</li></ul><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103095030575.png" alt="image-20240103095030575"></p><p>StringBuffer 一旦创建，默认会有 16 个字节空间去修改，但一旦追加的字符串长度超过 16，如何处理？</p><p>StringBuffer 不会重新开辟一块新的内存空间，而是在原有空间直接扩容，通过调用父类的ensureCapacityInternal() 方法对底层数组扩容，保持引用不变。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103101200174.png" alt="image-20240103101200174"></p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuffer 是线程安全的，效率较低；StringBuilder 是线程不安全的，效率较高。</p><p>读取数据不需要考虑线程安全问题，因为没有隐患。</p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><ul><li>java.util.Date</li></ul><p>Date 对象表示当前的系统时间</p><pre><code class="highlight java"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();<span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd HH:mm&quot;</span>);<span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date);System.out.println(format);</code></pre><ul><li>java.util.Calendar</li></ul><p>Calendar 用来完成日期数据的逻辑运算</p><p>运算思路：</p><p>1、将日期数据传给 Calendar（Calendar 提供了很多静态常量，专门记录日期数据）</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103174705206.png" alt="image-20240103174705206"></p><p>2、调用相关方法完成计算</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103174845642.png" alt="image-20240103174845642"></p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Date;<span class="keyword">import</span> java.text.SimpleDateFormat;<span class="keyword">import</span> java.util.Calendar;<span class="keyword">import</span> java.util.Date;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="comment">// 计算今天所在的周是 2024 年第几周</span><span class="comment">//        Calendar calendar = Calendar.getInstance();</span><span class="comment">//        calendar.set(Calendar.YEAR, 2024);</span><span class="comment">//        calendar.set(Calendar.MONTH, 0);  // 1月从0开始</span><span class="comment">//        calendar.set(Calendar.DAY_OF_MONTH, 3);</span><span class="comment">//        int week = calendar.get(Calendar.WEEK_OF_YEAR);</span><span class="comment">//        System.out.println(week);</span>        <span class="comment">// 今天之后的63天是几月几号</span>        <span class="comment">// 先算出今天是一年中的第几天</span>        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();        calendar.set(Calendar.YEAR, <span class="number">2024</span>);        calendar.set(Calendar.MONTH, <span class="number">0</span>);        calendar.set(Calendar.DAY_OF_MONTH, <span class="number">3</span>);        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_YEAR);        day += <span class="number">63</span>;        calendar.set(Calendar.DAY_OF_YEAR, day);        <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> calendar.getTime();        <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);        <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(time);        System.out.println(format);        calendar.set(Calendar.DAY_OF_YEAR, calendar.get(Calendar.DAY_OF_YEAR)-<span class="number">63</span>);        time = calendar.getTime();        System.out.println(simpleDateFormat.format(time));    &#125;&#125;</code></pre><h2 id="输入输出-IO-流"><a href="#输入输出-IO-流" class="headerlink" title="输入输出 IO 流"></a>输入输出 IO 流</h2><p>File 类</p><p>java.io.File，使用该类的构造函数可以创建文件对象。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240103202800556.png" alt="image-20240103202800556"></p><h3 id="IO-流"><a href="#IO-流" class="headerlink" title="IO 流"></a>IO 流</h3><ul><li>按照单位分，分为字节流和字符流</li></ul><h4 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h4><p>按照方向可分为输入字节流和输出字节流</p><p>InputStream 和 OutputSteam</p><p>InputStream 常用方法</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105142945713.png" alt="image-20240105142945713"></p><h4 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h4><p>字节流是单位时间内处理一个字节的数据（输入+输出）</p><p>字符流是单位时间内处理一个字符的数据（输入+输出）</p><p>字符流：</p><ul><li>输入字符流 Reader</li><li>输出字符流 Writer</li></ul><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><p>是一个抽象类</p><p>Readable 的作用？</p><p>可以将数据以字符的形式读入缓冲区</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105152250368.png" alt="image-20240105152250368"></p><p>InputStream（字节输入流）   Reader（字符输入流）</p><p>InputStreamReader 的功能是将字节输入流转化为字符输入流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="comment">// 字符流</span>        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span> ((tmp = reader.read()) != -<span class="number">1</span>) &#123;            System.out.println(tmp);        &#125;        reader.close();        System.out.println(<span class="string">&quot;-----------&quot;</span>);        <span class="comment">// 字节流</span>        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        tmp = <span class="number">0</span>;        <span class="keyword">while</span> ((tmp = inputStream.read()) != -<span class="number">1</span>) &#123;            System.out.println(tmp);        &#125;        inputStream.close();    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileInputStream;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReaderTest2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];        <span class="type">int</span> <span class="variable">length2</span> <span class="operator">=</span> inputStream.read(bytes);        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> reader.read(chars);        System.out.println(<span class="string">&quot;字节流长度是&quot;</span> + length2);        System.out.println(<span class="string">&quot;字符流长度是&quot;</span> + length);        <span class="keyword">for</span> (<span class="type">char</span> aChar : chars) &#123;            System.out.println(aChar);        &#125;    &#125;&#125;</code></pre><h4 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h4><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105162047833.png" alt="image-20240105162047833"></p><p>Appendable 接口可以将 char 类型的数据读入到数据缓冲区</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriterTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/copy.txt&quot;</span>);        writer.write(<span class="string">&quot;你好，wdcp&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);        writer.flush();        writer.close();    &#125;&#125;</code></pre><h4 id="处理流"><a href="#处理流" class="headerlink" title="处理流"></a>处理流</h4><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240105170347820.png" alt="image-20240105170347820"></p><pre><code class="highlight java"><span class="comment">// 基础管道</span><span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);<span class="comment">// 处理流</span><span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream);<span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> inputStreamReader.read(chars);inputStreamReader.close();<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars, <span class="number">0</span>, length);System.out.println(str);</code></pre><pre><code class="highlight java"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;你好，世界&quot;</span>;<span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/0.txt&quot;</span>);<span class="type">OutputStreamWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(outputStream);writer.write(s);writer.flush();writer.close();</code></pre><h4 id="缓存流"><a href="#缓存流" class="headerlink" title="缓存流"></a>缓存流</h4><p>无论是字节流还是字符流，使用的时候都会频繁访问硬盘，对硬盘是一种损伤，同时效率不高，如何解决？</p><p>可以使用缓存流，缓存流自带缓冲区，可以一次性从硬盘中读取部分数据存入缓存区，再写入内存。</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240106093901882.png" alt="image-20240106093901882"></p><p>缓存流属于处理流，如何区分处理流和节点流？</p><p>1、节点流使用的时候可以直接对接到文件对象 File</p><p>2、处理流使用的时候不能直接对接到文件对象 File</p><p><img src="/2024/01/06/Java%E9%9B%86%E5%90%88/image-20240106094816585.png" alt="image-20240106094816585"></p><p>缓存流又可以分为字节缓存流和字符缓存流，再细分可以分为字节输入缓存流和字节输出缓存流、字符输入缓存流和字符输出缓存流。</p><p>字符输入缓存流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer2</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);        <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="keyword">while</span> ((tmp = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;            System.out.println(tmp);        &#125;        bufferedReader.close();        reader.close();    &#125;&#125;</code></pre><p>字符输出缓存流</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.File;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">import</span> java.io.Writer;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Buffer4</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">Writer</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/File/2.txt&quot;</span>);        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);        bufferedWriter.write(<span class="string">&quot;wdcppppp&quot;</span>);        bufferedWriter.flush();        bufferedWriter.close();        writer.close();    &#125;&#125;</code></pre><p>输入流没有 flush 方法，但不代表它没有缓存流，输出流是有 flush 方法，在关闭缓存流之前，需要调用 flush 方法。</p><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化：将内存中的对象输出到硬盘文件中保存。</p><p>反序列化：从文件中读取数据并还原成内存中的对象。 </p><p>序列化 </p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Serializable;<span class="keyword">import</span> java.io.FileOutputStream;<span class="keyword">import</span> java.io.ObjectOutputStream;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">22</span>);        <span class="comment">// user 对象写入文件</span>        <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;</span>);        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);        objectOutputStream.writeObject(user);        objectOutputStream.flush();        objectOutputStream.close();        outputStream.close();    &#125;&#125;</code></pre><h2 id="IO-流的应用"><a href="#IO-流的应用" class="headerlink" title="IO 流的应用"></a>IO 流的应用</h2><p>IO 流就是完成文件传输的（上传文件：上传头像、朋友圈，文件下载：CSDN 下载源代码）</p><pre><code class="highlight java"><span class="keyword">package</span> Collection.Serializable;<span class="keyword">import</span> java.io.BufferedReader;<span class="keyword">import</span> java.io.BufferedWriter;<span class="keyword">import</span> java.io.FileReader;<span class="keyword">import</span> java.io.FileWriter;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;<span class="comment">//        FileInputStream inputStream = new FileInputStream(&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;);</span><span class="comment">//        FileOutputStream outputStream = new FileOutputStream(&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;);</span><span class="comment">//        int tmp = 0;</span><span class="comment">//        while ((tmp = inputStream.read()) != -1) &#123;</span><span class="comment">//            outputStream.write(tmp);</span><span class="comment">//        &#125;</span><span class="comment">//        outputStream.close();</span><span class="comment">//        inputStream.close();</span>        <span class="type">FileReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user.txt&quot;</span>);        <span class="type">FileWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;/Users/lei/Java/java-base/src/main/java/Collection/Serializable/user2.txt&quot;</span>);        <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);        <span class="type">BufferedWriter</span> <span class="variable">bufferedWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(writer);        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;        <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;            bufferedWriter.write(str);            num++;        &#125;        System.out.println(num);        bufferedWriter.flush();        bufferedWriter.close();        bufferedReader.close();        writer.close();        reader.close();    &#125;&#125;</code></pre><p>对于音频、图片，只能用字节流读取</p><p>文本类型的数据可以用字符流、字节流读取</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 集合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
