<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>线程池</title>
      <link href="/2024/04/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/04/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在 Java 中的线程池中，在核心线程数已满的情况下，为什么要先判断等待队列是否已满，未满放到队列中。而不是先判断最大线程数是否已满？    线程池的目的应该尽可能创建多个线程。</p></blockquote><p>原因有很多，可能等待队列充当了个缓存区，允许系统在流量高峰时有更多弹性，避免不必要的资源消耗。</p><p>另外，在 <a href="https://zhuanlan.zhihu.com/p/92632090">https://zhuanlan.zhihu.com/p/92632090</a> 中也提到了这点，每当需要创建线程时，都会调用 addWorker() 方法，在这个方法中需要获取锁，而多个线程获取锁会造成资源的争抢。如果在最大线程数未满的情况下，直接创建新的线程，这样每次都需要多获取一次锁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Quartz定时任务</title>
      <link href="/2024/04/12/Quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <url>/2024/04/12/Quartz%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js</title>
      <link href="/2024/04/11/Vue-js/"/>
      <url>/2024/04/11/Vue-js/</url>
      
        <content type="html"><![CDATA[<p>本文讲解 Vue.js 的工作原理。</p><blockquote><p>在创建一个 Vue 实例时，通过会配合 Vue Router 和 Vuex 来管理路由和状态，并且会注册全局组件。</p></blockquote><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><p>当数据变化了，Vue.js 提供了计算属性（computed）和监听器（watch）来处理数据的变化。</p><blockquote><p>computed：当第一次使用计算属性时，会计算并缓存结果。后续再使用计算属性时，如果使用到的变量没有发生变化，就直接返回缓存。</p><p>watch：监听器与 data 中的属性同名，当属性的值发生改变时，监听器被触发执行。（如用户登录表单监听）</p></blockquote><p>如果数据频繁变化，用 watch。</p><p>如果数据频繁被使用，但其依赖的变量很少变化，用 computed。</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>一个页面可以被划分为多个组件，在不同的页面中可能要重用这些组件。</p><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>七个生命周期钩子：</p><blockquote><p>created：在 Vue 实例创建后调用，但在模版渲染之前。</p><p>mounted：在 Vue 实例挂载到 DOM 上后调用。</p></blockquote><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2024/04/09/IO/"/>
      <url>/2024/04/09/IO/</url>
      
        <content type="html"><![CDATA[<p>从传输方式看，Java 的 IO 分为 字符流和字节流。</p><p>字符流：InputStream、OutputStream</p><p>字节流：Reader、Writer</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中异常机制</title>
      <link href="/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/image-20240409150132405.png" alt="image-20240409150132405"></p><blockquote><p>Error：一般是 JVM 出现了问题，如空间不足等。</p></blockquote><blockquote><p>Exception：异常分为运行时异常 (RunTimeException) 和编译时异常。</p></blockquote><p>Checked Exception 受检查异常：编译器要求处理，除了 RunTimeException 及其子类，其他 Exception 都是 受检查异常。</p><p>UnChecked Exception 不受检查异常：包括 RunTimeException及其子类 和 Error。</p><p>RunTimeException 及其子类</p><ul><li>NullPointerException</li><li>ArithmeticException 算术错误</li><li>ArrayIndexOutOfBoundsException 数组越界</li><li>IllegalArgumentException 参数类型异常</li></ul><h2 id="执行的顺序"><a href="#执行的顺序" class="headerlink" title="执行的顺序"></a>执行的顺序</h2><p>当 try 捕获到异常，且 catch 中也有处理该异常的情况：try 按顺序执行，当执行到某一条语句出现异常时，程序将跳到 catch 语句块中找到对应的处理代码块，处理完后执行 finally 的代码即结束。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记项目上线</title>
      <link href="/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/"/>
      <url>/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="前后端分离的线上域名部署"><a href="#前后端分离的线上域名部署" class="headerlink" title="前后端分离的线上域名部署"></a>前后端分离的线上域名部署</h2><p>背景：基于 SpringBoot 与 Vue 的前后端分离项目，前台页面有两个：分别是前台展示页面、后台管理页面。</p><p>对于后端而言需要注意的点：数据库改成服务器 IP，中间件的地址（redis、elasticsearch、rabbitmq等）。设置好后就可以打包成 jar 包，放到服务器目录中，在宝塔中有个很方便的点是选择 jar 包后自动填充执行命令，一键部署。<img src="/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/image-20240407212903208.png" alt="image-20240407212903208"></p><p>后端部署完毕后，如何判断部署成功呢？其实可以借助 Postman 等工具测试个接口，看能否得到响应数据。或者直接在浏览器上输入 GET 请求地址，得到响应后说明后端可以正常访问。</p><p>两个前端部署：如果要用域名部署，最好先用 IP:端口 部署好后，再在宝塔的域名管理添加域名就可以了。前台-web页面默认的 publicPath: ‘&#x2F;‘，而后台管理页面是 publicPath: ‘&#x2F;admin’。因此二者放到服务器文件夹后，只需建一个站点，在配置文件（nginx）中如下配置：</p><pre><code class="highlight nginx"><span class="section">location</span><span class="regexp"> ^~</span> /admin&#123;<span class="attribute">alias</span> /www/wwwroot/blog-admin/dist;<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;&#125;<span class="section">location</span> /&#123;<span class="attribute">root</span> /www/wwwroot/blog-web/dist;<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的锁</title>
      <link href="/2024/04/06/Java%E7%9A%84%E9%94%81/"/>
      <url>/2024/04/06/Java%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>这是一种广义上的概念。悲观锁认为在自己使用数据的时候中一定有其他的线程来修改数据，因此在获取数据前都会上锁。像 Lock 的实现类、synchronized 都是悲观锁。</p><p>乐观锁则无所谓的态度，认为不会有其他线程来修改，因此不会上锁，只是在更新数据时判断这个数据在自己使用的时候，有没有别的线程修改过。常用的算法是 CAS 算法。</p><p>从上面我们得出结论：悲观锁用于写较多的场景，乐观锁用于读较多的场景。</p><p>CAS 是一个原子操作，因此不需要对其加锁。其包含三个操作数：内存位置V、预期原值A、新值B。首先得到内存位置的原值R，如果R &#x3D;&#x3D; A，则可以将A更新为B。否则取消。</p><h2 id="为什么有自旋锁？"><a href="#为什么有自旋锁？" class="headerlink" title="为什么有自旋锁？"></a>为什么有自旋锁？</h2><p>阻塞或唤醒一个线程需要切换上下文，这花费的时间可能比用户代码执行的时间还长。而且许多同步场景中，同步资源的锁定时间很长，不妨让线程等一等，不用挂起，这就是自旋。而且当今多核CPU，完全可以让一个核等一会，其他核去忙。</p><p>如果等待时间很短，则自旋很好。但如果时间很长，一直自旋也会让CPU白白消耗资源，于是自旋有个上限，默认是10次。</p><h2 id="Synchronized-锁原理分析"><a href="#Synchronized-锁原理分析" class="headerlink" title="Synchronized 锁原理分析"></a>Synchronized 锁原理分析</h2><p>monitorenter 和 monitorexit 指令。每个对象在同一时间只能与一个 monitor 关联，而一个 monitor 在同一时间只能被一个线程获得。当一个对象获取 monitor 时，会发生以下几种情况：1、 monitor 计数器为0，对象一旦获得锁则 monitor 加一。2、monitor 不为0，判断该线程是否为重入锁，是的话计数器加一，否则线程会被堵塞。</p><p>由于 monitorenter 和 monitorexit 是依赖于底层的操作系统实现的，这会将用户态变为内核态，影响性能。</p><h2 id="volatile-详解"><a href="#volatile-详解" class="headerlink" title="volatile 详解"></a>volatile 详解</h2><p>对修饰了 volatile 变量修改时，JVM 会向处理器插入一条 lock 前缀指令，具体如下：</p><ul><li><p>将当前处理器缓存的值立即刷新到主存</p></li><li><p>将其他处理器的缓存值置为无效</p></li></ul><p>因此，其他处理器在发现本地缓存失效时，会重新到主存中读取该值，也就是最新的值。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>概念：对象头 Mark Word：有 HashCode、GC Age、锁标记位。</p><p>当一个线程尝试获取轻量级锁时，会先在自己的栈帧中创建一个锁记录(Lock Record)，然后使用 CAS 将 Mark Word 拷贝到锁记录中，并且将 Mark Word 更新为指向 Lock Record 的指针。如果失败，看是否指向已经是当前栈帧，是的话已经获取锁了，否则会自旋。</p><h2 id="synchronized-和-Lock-的区别"><a href="#synchronized-和-Lock-的区别" class="headerlink" title="synchronized 和 Lock 的区别"></a>synchronized 和 Lock 的区别</h2><p>1、synchronized 是关键字，是基于 JVM 实现的，使用监视器锁 monitor 。Lock 是一个接口，它的实现类如 ReentrantLock 使用 AQS 作为同步机制。</p><p>2、使用 synchronized 时，JVM 会自动加锁释放锁。而 Lock 时需要调用方法，在 finally 块中释放锁。</p><p>3、获取锁的状态：Lock 提供了 tryLock 方法，可以获取锁状态，还可以设置超时时间。</p><p>4、Lock 支持中断。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 的两个核心：资源 state、未获取到资源的等待队列 CLH。</p><p>流程如下：</p><p>1、t1 时刻，线程 a 持有资源 state（持有资源的线程在 head 节点）</p><p>2、t1 时刻，线程 b 尝试获取锁失败，则封装为 Node 节点并插入 CLH 队列队尾。</p><p>3、挂起 b 线程，并告知 a 线程释放锁时通知下 b。</p><p>4、t2 时刻，a 线程释放锁并通知 b。</p><p>5、t3 时刻，b 尝试获取锁。</p><p>来看看 ReentrantLock 公平锁的tryAcquire：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="comment">//获取当前线程</span>    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();    <span class="comment">//获取AQS中的state</span>    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();    <span class="comment">//如果state等于0说明此时没有线程占有锁</span>    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;        <span class="comment">//hasQueuedPredecessors 判断有没有别的线程排在了当前线程的前面。</span>        <span class="comment">//此方法返回true，代表当前线程需要排队，返回false，表示当前线程不用排队</span>        <span class="comment">//不用排队的话 直接cas尝试将state占位己有</span>        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(<span class="number">0</span>, acquires)) &#123;            <span class="comment">//设置AQS中的独占线程字段 为当前线程</span>            setExclusiveOwnerThread(current);            <span class="comment">//返回true 代表获取锁成功</span>            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;    <span class="comment">//如果state不是0 则判断当前占有锁的线程是否是当前线程，如果是，</span>    <span class="comment">//表示此线程重入抢锁，对state进行+1 </span>    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);        setState(nextc);        <span class="comment">//重入线程，只需将state+1， head信息不需要变，也不许要到等待队列排队，</span>        <span class="comment">//直接返回true加锁成功</span>        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">//抢锁失败 返回false</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>非公平锁就是少了 hasQueuedPredecessors 的判断。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型机制</title>
      <link href="/2024/04/06/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/06/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>泛型就是为了方法的复用，不必再搞个方法重载了，其实就是为了跳过方法重载，因为方法重载冗余代码太多。</p><h2 id="证明泛型擦除"><a href="#证明泛型擦除" class="headerlink" title="证明泛型擦除"></a>证明泛型擦除</h2><p>泛型擦除在编译阶段发生。</p><pre><code class="highlight java">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list1.add(<span class="string">&quot;a&quot;</span>);ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list2.add(<span class="number">1</span>);System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></code></pre><h2 id="通过反射绕过编译类型检查"><a href="#通过反射绕过编译类型检查" class="headerlink" title="通过反射绕过编译类型检查"></a>通过反射绕过编译类型检查</h2><pre><code class="highlight java">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list1.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list1, <span class="string">&quot;wd&quot;</span>);System.out.println(list1.get(<span class="number">0</span>));</code></pre><p>反射得到 可以接收Object类型的add方法，invoke调用此方法。</p><h2 id="泛型的编译期检查"><a href="#泛型的编译期检查" class="headerlink" title="泛型的编译期检查"></a>泛型的编译期检查</h2><p>泛型的检查是在编译之前的，如果是在编译之后，在执行下面这段代码时应该是能加入的：</p><pre><code class="highlight java">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  list.add(<span class="string">&quot;123&quot;</span>);  list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></code></pre><p>但报错，说明是在编译之前的。</p><h2 id="类型检查是检查什么？"><a href="#类型检查是检查什么？" class="headerlink" title="类型检查是检查什么？"></a>类型检查是检查什么？</h2><p>检查的是引用。</p><pre><code class="highlight java">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span>list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span>list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String </span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker容器中的vim</title>
      <link href="/2024/03/30/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84vim/"/>
      <url>/2024/03/30/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84vim/</url>
      
        <content type="html"><![CDATA[<p>在 docker 容器中没有安装 vim 编辑器，需要使用 apt 命令安装，在更新 apt 软件包时遇到了一些坑，便记录下来。</p><p>遇到的坑主要是使用 apt 安装 vim 时，使用镜像为 163 的，总是报 ‘E: Sub-process &#x2F;usr&#x2F;bin&#x2F;dpkg returned an error code (1)’ 错误，后来重新换了个阿里云的源解决了问题。</p><p>cd &#x2F;etc&#x2F;apt 里面有个 sources.list，执行下面代码使用阿里云镜像源。</p><pre><code class="highlight plaintext">echo &quot;&quot; &gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&quot; &gt;&gt; sources.list</code></pre><p>如果出现了 The following signatures couldn’t be verified because the public key is not available，则按照下面代码执行</p><pre><code class="highlight plaintext">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 此处为错误信息的字符串</code></pre><p>之后执行 apt-get update、apt-get install vim 都成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub搜索trick</title>
      <link href="/2024/03/28/GitHub%E6%90%9C%E7%B4%A2trick/"/>
      <url>/2024/03/28/GitHub%E6%90%9C%E7%B4%A2trick/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub-精确搜索"><a href="#GitHub-精确搜索" class="headerlink" title="GitHub 精确搜索"></a>GitHub 精确搜索</h2><pre><code class="highlight markdown"><span class="section"># 按照项目名/仓库名搜索</span>in:name xxx<span class="section"># 按照README搜索</span>in:readme xxx<span class="section"># 按照 description 搜索</span>in:description xxx<span class="section"># stars数大于xxx</span>stars:&gt;xxx<span class="section"># 编程语言为xxx</span>language:xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习</title>
      <link href="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="ES-核心概念"><a href="#ES-核心概念" class="headerlink" title="ES 核心概念"></a>ES 核心概念</h2><p>ElasticSearch：简称 es，分布式全文搜索引擎。实时的存储、检索数据。</p><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240329152019163.png" alt="image-20240329152019163"></p><p>索引就是数据库，文档就是一条条数据</p><blockquote><p>倒排索引</p></blockquote><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240329153835659.png" alt="image-20240329153835659"></p><p>将文章中的标签都取出来，有该标签的文章则记录下来。以后查询时，只需要查看标签，获取掉对应的文章，过滤掉无关的文章。</p><h2 id="IK-分词器"><a href="#IK-分词器" class="headerlink" title="IK 分词器"></a>IK 分词器</h2><p>IK 提供了两个分词算法：ik_smart 和 ik_max_word，前者为最少切分，后者为最细粒度切分。</p><p>ik_smart 会讲句子切分成词语，词语不会彼此重叠。</p><p>ik_max_word 会按细粒度切分，也就是前后只要能组成词语就切分，不在乎是否重叠。</p><h2 id="Rest-分格"><a href="#Rest-分格" class="headerlink" title="Rest 分格"></a>Rest 分格</h2><h3 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h3><blockquote><p>基础测试</p></blockquote><p>1、创建一个索引</p><pre><code class="highlight plaintext">PUT /索引名/类型名/文档id&#123;键值对形式&#125;</code></pre><p>添加数据</p><pre><code class="highlight json">PUT /test3/_doc/<span class="number">1</span><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wdcp&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;birth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2001-01-05&quot;</span><span class="punctuation">&#125;</span></code></pre><p>更新数据</p><pre><code class="highlight json"># 使用 POST 更新数据<span class="punctuation">,</span> 使用_updatePOST /test3/_doc/<span class="number">1</span>/_update<span class="punctuation">&#123;</span>  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大盘&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>如果不使用 _update，改动一个数据需要把其他的值也写上，否则更新后为空。</p><h3 id="关于文档的基本操作-重点"><a href="#关于文档的基本操作-重点" class="headerlink" title="关于文档的基本操作(重点)"></a>关于文档的基本操作(重点)</h3><blockquote><p>基本操作</p></blockquote><pre><code class="highlight json">GET test3/_doc/_search?q=name<span class="punctuation">:</span>大盘</code></pre><p>模糊查询</p><pre><code class="highlight json'">GET test3/_doc/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;:&#123;      &quot;name&quot;: &quot;大盘&quot;    &#125;  &#125;&#125;</code></pre><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330155320334.png" alt="image-20240330155320334"></p><ul><li>gt 大于</li><li>gte 大于等于</li><li>lt 小于</li></ul><blockquote><p>精确查询</p></blockquote><p>term 是通过倒排索引精确的查找！</p><p><strong>关于分词：</strong></p><ul><li>term</li><li>match：会进行分词，再查询</li></ul><p><strong>两个类型 text keyword</strong></p><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330161850615.png" alt="image-20240330161850615"></p><p>对于 keyword，查询时不会被分词，因此只有全局匹配才查到。对于 text 会被分词。</p><blockquote><p>高亮</p></blockquote><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330162859502.png" alt="image-20240330162859502"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL复盘</title>
      <link href="/2024/03/23/SQL%E5%A4%8D%E7%9B%98/"/>
      <url>/2024/03/23/SQL%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><blockquote><p> 存储大量文本数据：text、mediumtext、longtext</p></blockquote><p>分别可以存储 $2^{16}-1$ 、$2^{24}-1$ 、$2^{32}-1$ 个字符。</p><blockquote><p>金额计算：用 decimal(M, N)     M：最大存几位数(不包括小数点)   N：小数点后的位数</p></blockquote><p>如 decimal(5, 2)  存储范围是 -999.99 - 999.99。</p><blockquote><p> 日期数据类型：Date、DateTime、<strong>timestamp</strong></p></blockquote><p>计算两个日期之间的时间差：TIMEDIFF</p><p>DateTime 可以显示到秒级别。</p><p>timestamp 和时区有关。</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote><p>outer join：分别 left join 和 right join。</p></blockquote><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><blockquote><p>UNION：将两个或多个的查询结果组合起来，并消除重复的行。</p><p>UNION ALL：包含重复的行。</p></blockquote><p>组合查询的规则：</p><ul><li>多个查询的字段类型、个数需要相同。</li><li>对于 order by，需要放到最后一条 select 之后。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2024/03/19/Docker/"/>
      <url>/2024/03/19/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-和-虚拟机的区别"><a href="#Docker-和-虚拟机的区别" class="headerlink" title="Docker 和 虚拟机的区别"></a>Docker 和 虚拟机的区别</h2><p>虚拟机需要启动完整的系统，内核、工具等</p><p>Docker 是容器的一种实现方式，镜像是一个模板，容器是模板的实例。</p><p><img src="/2024/03/19/Docker/image-20240319140809181.png" alt="image-20240319140809181"></p><p>查看本地镜像：docker images</p><p>查看正在运行的容器：docker ps</p><p>运行一个容器：docker run –name some-nginx -d -p 8080:80 nginx:1.22</p><p>查看容器的信息：docker inspect 容器名</p><pre><code class="highlight plaintext">将容器连接到网络：docker network (dis)connect 网络名 容器名 之后访问容器 docker run -it --rm mysql:5.7 mysql -h172.17.0.2 -uroot -p=》 docker run -it --rm --network 网络名 mysql:5.7 mysql -hsome-mysql -uroot -p</code></pre><h2 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h2><p><img src="/2024/03/19/Docker/image-20240319153237440.png" alt="image-20240319153237440"></p><p>创建一个卷：docker volume create 卷名</p><h2 id="Docker-部署前后端分离项目-若依"><a href="#Docker-部署前后端分离项目-若依" class="headerlink" title="Docker 部署前后端分离项目-若依"></a>Docker 部署前后端分离项目-若依</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1、创建 mysql 容器</p><pre><code class="highlight linux">docker run -d \  --name mysql \  -p 3307:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=1314 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \   # 映射路径  --network ruoyi    \  mysql:8.0.19</code></pre><p>在启动 mysql 容器后，运行中内存会很大，需要在进入容器内为其配置文件中设置参数：</p><p>&#x2F;etc&#x2F;mysql&#x2F;conf.d 目录执行 vim docker.cnf</p><pre><code class="highlight plaintext">performance_schema_max_table_instances=400  table_definition_cache=400    performance_schema=off    table_open_cache=64    innodb_buffer_pool_chunk_size=64M    innodb_buffer_pool_size=64M</code></pre><p>2、创建 redis 容器</p><pre><code class="highlight linux">docker run  \--name redis \-p 6380:6379 \-v /root/redis/conf:/usr/local/etc/redis \-v /root/redis/data:/data \-d \--network ruoyi   \redis:6.0.8 \redis-server /usr/local/etc/redis/redis.conf</code></pre><p>3、创建 nginx 容器</p><pre><code class="highlight linux">docker run -d \  --name nginx \  -p 81:80 \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \  --network ruoyi  \  nginx:1.22</code></pre><p>由于 nginx 的配置文件容器出错，我们可以先创建一个 nginx 容器复制其配置文件，再删除它。</p><pre><code class="highlight plaintext"># 复制配置docker cp nginx:/etc/nginx/nginx.conf /root/nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d /root/nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html /root/nginx/</code></pre><p>4、部署后端 Dokcerfile</p><pre><code class="highlight linux"># 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 挂载目录VOLUME /home/ruoyi# 创建目录RUN mkdir -p /home/ruoyi# 指定路径WORKDIR /home/ruoyi# 拷贝jar包COPY /root/ruoyi-admin.jar /home/ruoyi/app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</code></pre><p>5、创建项目镜像</p><pre><code class="highlight linux">docker build -t ruoyi:1.0 -f /root/Dockerfile .</code></pre><p>6、创建项目容器</p><pre><code class="highlight linux">docker run -d \--name ruoyi  \-p 8081:8081  \-v /root/ruoyi/uploadPath:/home/ruoyi/uploadPath \--network \ruoyi  \ruoyi:1.0</code></pre><p>7、最后运行容器</p><pre><code class="highlight plaintext">docker run -d \-p 81:80 \-p 443:443 \--name nginx \--restart=always \--network ruoyi \-e TZ=&quot;Asia/Shanghai&quot; \-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /root/nginx/conf/conf.d:/etc/nginx/conf.d \-v /root/nginx:/var/log/nginx \-v /root/nginx/html:/usr/share/nginx/html \-v /root/nginx/cert:/etc/nginx/cert \nginx:1.22</code></pre><p>现在可以通过 服务器id : nginx端口 访问界面了！</p><p><img src="/2024/03/19/Docker/image-20240322095418176.png" alt="image-20240322095418176"></p><p>其中容易出错的点是配置 nginx 时，其配置文件对于后端的映射。</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网小记</title>
      <link href="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><p>TCP：面向连接、可靠、面向字节流</p><p>UDP：无连接、不可靠、面向报文</p><p>TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多</p><p>应用场景：</p><p>TCP：FTP 文件传输、HTTP &#x2F; HTTPS</p><p>UDP：实时应用、游戏</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/image-20240316164317006.png" alt="image-20240316164317006"></p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong>。</p><p><strong>第一次握手：</strong>客户端首先也创建传输运输块，向服务器发出连接请求报文，将标志位 SYN 置为 1，选择一个初始序列号 seq&#x3D;x。SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。</p><p><strong>第二次握手：</strong>服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态。</p><p>第三次握手：TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立。</p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传代码</title>
      <link href="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><blockquote><p>git log：查看提交记录（作者、邮箱）</p><p>git status：查看哪些文件被提交</p><p>git ls-files：查看暂存区的内容 默认是mixed，也就是回退时保留工作区文件，但移除暂存区文件</p><p>git reflog：查看历史记录</p><p>git reset 回退分支</p><p>git diff：比较工作区和暂存区的差别  –cached 比较暂存区和版本库的差异</p><p>git rm：将文件从工作区和暂存区都删除    –cached：把文件从暂存区删除，但保留在工作区</p><p>git checkout – filename    从暂存区恢复文件到工作区</p><p>git commit -a -m “”  一个命令同时添加到暂存区和提交到本地仓库</p></blockquote><p>.gitignore：忽略加入暂存区的文件</p><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><pre><code class="highlight plaintext">cd .sshssh-keygen -t rsa -b 4096</code></pre><p>git remote -v：查看本地仓库所对应的远程仓库的别名和地址</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建分支：git branch dev</p><p>切换分支：git switch dev</p><p>合并分支：git merge dev 把 dev 分支合并到 main 分支中</p><p><img src="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/image-20240318164945891.png" alt="image-20240318164945891"></p><h2 id="Git-clone-协议"><a href="#Git-clone-协议" class="headerlink" title="Git clone 协议"></a>Git clone 协议</h2><p>SSH 协议、HTTPS 协议</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点</title>
      <link href="/2024/03/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2024/03/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><pre><code class="highlight sql"><span class="keyword">SELECT</span> p.prod_name, <span class="built_in">Sum</span>(o.quantity) <span class="keyword">AS</span> quant_sold<span class="keyword">FROM</span> Products p,  OrderItems o<span class="keyword">WHERE</span> p.prod_id <span class="operator">=</span> o.prod_id<span class="keyword">GROUP</span> <span class="keyword">BY</span> p.prod_name（这里不能用 p.prod_id，会报错）</code></pre><p>这里不能用 p.prod_id 是因为当使用 group by 语句时，select 子句中的非聚合列必须出现在 group by 中。</p><h2 id="B-树和B树的区别"><a href="#B-树和B树的区别" class="headerlink" title="B+树和B树的区别"></a>B+树和B树的区别</h2><ul><li><p>B+ 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</p></li><li><p>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p></li></ul><p>B+ 树只有叶子存放数据：一方面，查找数据时要到叶子才能找到；另一方面，由于非叶子结点不存放数据，只存放索引，降低了树的高度。</p><h2 id="InnoDB-物理结构"><a href="#InnoDB-物理结构" class="headerlink" title="InnoDB 物理结构"></a>InnoDB 物理结构</h2><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后根据主键到主键索引中检索获得数据记录。</li></ul><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><blockquote><p>按物理存储分：主键索引、二级索引</p><p>按字段个数分：单列索引、联合索引</p></blockquote><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p>从左开始向右匹配，当遇到范围查询时就停止匹配。<strong>范围查询的字段还是可以用联合索引的。</strong></p><p>先对第一个字段进行排序，再对第二个字段排序。</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span></code></pre><p>这里的 a 和 b 都用到了联合索引。虽然在 a &gt; 1 这个条件中，b 字段的值是无序的。但在 a &#x3D; 1 条件中，b 字段的值是有序的。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_table <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">8</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span></code></pre><p>同上，a &#x3D; 2 或 a &#x3D; 8 时，b 字段的值是有序的。</p><h3 id="什么时候用到索引？"><a href="#什么时候用到索引？" class="headerlink" title="什么时候用到索引？"></a>什么时候用到索引？</h3><p>1、字段有唯一性限制的，如商品 ID。</p><p>2、出现在 where、group by、order by 中的字段</p><blockquote><p>不需要索引：</p><p>如果一个字段经常被修改，就不建议对其创建索引，因为修改数据时索引也需要修改。</p><p>表中数据比较少的情况。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/12/JVM%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312160432882.png" alt="image-20240312160432882"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>加载、验证、准备、解析、初始化</p><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><ul><li>线程私有：Java虚拟栈、程序计数器、本地方法栈</li><li>线程共享：方法区、堆内存</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 在尝试加载一个类时，系统首先判断这个类是否被加载过，已经加载的类直接返回，否则才会尝试加载。类加载器会将加载任务先委托给它的父加载器去尝试加载这个类，一直到达顶层的类（Bootstrap）只有在父加载器无法加载该类时（找不到对应的类），子加载器才会尝试去加载。</p><h2 id="JVM-虚拟机栈"><a href="#JVM-虚拟机栈" class="headerlink" title="JVM 虚拟机栈"></a>JVM 虚拟机栈</h2><p>每个Java虚拟机线程都有一个私有的Java栈，与线程同时创建。Java栈中保存着帧信息，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>局部变量表、操作数栈、动态链接、方法返回地址。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312192522896.png" alt="image-20240312192522896"></p><p>GC 垃圾回收，主要是在伊甸园区和养老区</p><ul><li><p>新生代：诞生、成长、死亡的地方。分为伊甸园区、From、To 幸存区（0,1）。</p></li><li><p>老年代</p></li></ul><h3 id="晋升到老年代"><a href="#晋升到老年代" class="headerlink" title="晋升到老年代"></a>晋升到老年代</h3><p>在程序运行过程中，新生代GC会反复发生，长寿对象会在S0和S1之间反复交换，年龄也会越来越大，当对象达到年龄上限时，会被晋升到老年代。这个年龄上限默认是15。大对象会跨过年轻代直接分配到老年代。如果在Survivor空间中相同年龄对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象会直接进入老年代。</p><p>在survivor中，相同年龄的所有对象大小大于survivor的一半空间。年龄大于或等于该年龄的对象可以进入老年代。</p><p>在 jdk8 后，永远存储区改了个名字（元空间）：这个区域在本地内存，存储的是 java 运行时的一些环境或类信息。这个区域不存在垃圾回收。方法区在元空间</p><p>非堆内存：方法区、元空间</p><ul><li>JDK 1.8 之后，无永久代，替代为元空间，不存在于 JVM，使用的是本地内存。</li></ul><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312200859515.png" alt="image-20240312200859515"></p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li><p>标记-清除：将存活的对象进行标记，然后清除未标记的对象。（会产生内存碎片）<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407112632893.png" alt="image-20240407112632893"></p></li><li><p>标记-整理：让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407112759472.png" alt="image-20240407112759472"></p></li><li><p>复制算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存满了就将存活对象复制到另一块，再把使用过的内存空间一次性清理。<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407113408523.png" alt="image-20240407113408523"></p></li><li><p>分代收集：将内存划分为几块，如堆分为新生代和老年代。</p></li></ul><p>新生代一般使用复制算法进行垃圾会输。复制算法将新生代分为 Eden区和两个幸存区（From 区、To 区）。当 Eden 区满时，触发 Minor GC，将存活对象移动到一个幸存区，然后清空 Eden 区。这个过程循环反复，直到一个幸存区满了，再触发 Minor GC，将 Eden 区和 From 区的存活对象移到另一个幸存区，清空这个幸存区。</p><p>老年代一般采用标记-清除-整理算法。</p><h2 id="GC-过程"><a href="#GC-过程" class="headerlink" title="GC 过程"></a>GC 过程</h2><p>新创建的对象大多分配在 Eden 区，此时两个幸存区 0 和 1 几乎为空。随着时间推移，Eden 区放不下了，此时发生轻 GC：首先通过可达性分析算法找到可达对象；被标记的可达对象会被转移到 0 区，此时存活对象年龄加 1；清除 Eden 区所有对象。</p><p>当 Eden 区再次满时，再次发生 GC，此时 0 区已经有对象，还是通过可达性分析找到可达对象，将 Eden 区和 0 区中的可达对象转移到 1 区，年龄加一；将 Eden 区和 0 区的所有对象清除。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ实战</title>
      <link href="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/"/>
      <url>/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-整合-RabbitMQ-注意："><a href="#SpringBoot-整合-RabbitMQ-注意：" class="headerlink" title="SpringBoot 整合 RabbitMQ 注意："></a>SpringBoot 整合 RabbitMQ 注意：</h2><p>端口 15672：这是 RabbitMQ 管理界面的默认端口，这个端口可以对 RabbitMQ 后台管理。</p><p>端口 5672：这是 RabbitMQ 默认的 AMQP 协议端口。客户端通常使用这个端口与 RabbitMQ 服务器建立连接进行消息传递操作。</p><p>在配置文件 application.yml 进行 RabbitMQ 配置时，连接端口是 5672。</p><h2 id="Work-模型"><a href="#Work-模型" class="headerlink" title="Work 模型"></a>Work 模型</h2><p>多个消费者绑定到一个队列，加快消息处理速度。在消费者服务中，可以配置 prefetch 控制消费者预取的消费数量，处理完一条才处理剩余的，类似负载均衡。</p><h2 id="为什么需要交换机？"><a href="#为什么需要交换机？" class="headerlink" title="为什么需要交换机？"></a>为什么需要交换机？</h2><p>交换机可以实现生产者预消费者解耦，生产者无需关心消息会发送到哪个队列、被哪个消费者消费。生产者只需面向交换机，消费者只需面向队列。</p><h2 id="fanout-交换机"><a href="#fanout-交换机" class="headerlink" title="fanout 交换机"></a>fanout 交换机</h2><p>fanout 交换机会将所有接收到的消息广播给所有与之绑定的队列。</p><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309175129139.png" alt="image-20240309175129139"></p><h2 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h2><p>可以指定交换机与哪个队列进行绑定。</p><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309180620965.png" alt="image-20240309180620965"></p><h2 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h2><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309192215485.png" alt="image-20240309192215485"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的应用</title>
      <link href="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-在项目中的应用"><a href="#Redis-在项目中的应用" class="headerlink" title="Redis 在项目中的应用"></a>Redis 在项目中的应用</h1><p>热点数据的缓存、限时业务( 验证码 )、计数器</p><h2 id="1、做缓存"><a href="#1、做缓存" class="headerlink" title="1、做缓存"></a>1、做缓存</h2><p><strong>删除缓存还是更新缓存</strong>：删除缓存。更新缓存有两个问题：在更新了数据库之后，但还没来得及更新缓存，此时用户访问的是脏数据；相比之下，删除缓存机制会将缓存删除，当下次访问时，从数据库查找最新的数据并更新缓存。此外，如果数据频繁更新，缓存也要频繁更新，只有最后一次更新才有效，这就导致性能开销，很多都是无效更新。</p><p><strong>先操作缓存，还是先操作数据库？</strong> 先操作数据库，再删除缓存。如果先删除缓存，再操作数据库，在多线程情况下，线程 A 删除缓存后，数据库更新很慢；在数据库未更新完成时，线程 B 趁虚而入，读取数据库的脏数据并写入缓存。而先更新数据库，再删除缓存，出现数据不一致的概率小。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240227211712815.png" alt="image-20240227211712815"></p><p>一般有两种情况：</p><ul><li>缓存中的数据或数据库中的数据被误删除了。</li><li>恶意攻击</li></ul><p>设置空值。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>某个热点数据过期了，此时有大量请求同时查询这个数据，这些请求就直接打到数据库上，给数据库带来巨大的冲击。</p><p>解决方案：1、互斥锁   2、设计逻辑过期</p><p><strong>互斥锁实现逻辑：</strong>先根据 key 在缓存中查找，找到直接返回。如果是空值，说明发生了缓存穿透，返回空。这里起初用的是自定义的锁：SETNX。只有当 key 不存在时才会成功，如下</p><pre><code class="highlight java"><span class="comment">//    private boolean tryLock(String key) &#123;</span><span class="comment">//        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><span class="comment">//        return BooleanUtil.isTrue(aBoolean);</span><span class="comment">//    &#125;</span><span class="comment">//    private void unLock(String key) &#123;</span><span class="comment">//        stringRedisTemplate.delete(key);</span><span class="comment">//    &#125;</span></code></pre><p>如果获取锁失败，休眠一段时间，重新查询。获取锁成功后，在数据库查询，如果未查到则发生了缓存穿透，插入空值。如果查到了则存入 redis，最后释放锁。</p><p><strong>互斥锁解决缓存击穿主要在于先让一个线程获取锁，将其他线程阻止在外，此线程在数据库查询一次后存入缓存，外面的线程就可以从缓存中取数据，不用都来访问数据库。</strong></p><p><strong>逻辑过期实现逻辑：</strong>缓存过期策略意思是在商品中添加一个逻辑过期时间字段，在查询之前就预加载到了缓存，如果没有查到，说明该商品不是活动商品。如果查到的话，将其转化为对应的 Bean 对象，判断其逻辑时间是否过期（缓存过期时间在当前时间之后则尚未过期），如果未过期直接返回这个对象；否则需要开启独立线程获取锁查询数据库，并重新写入缓存，而主线程直接返回旧的缓存 </p><p><strong>这样做是为了保证响应速度，缓存数据虽然可能稍微落后于数据库的最新数据，但是在大多数情况下，这个小小的延迟并不会影响系统的功能和用户的体验。逻辑过期一定要先进行数据预热，将我们热点数据加载到缓存中。</strong></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的缓存在同一时间失效或 redis 服务宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p><p>解决方案：</p><ul><li><p>避免将大量数据设置为同一个缓存时间（加个随机数）。</p></li><li><p>互斥锁</p></li></ul><h2 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SET 命令有个 NX 选项，用来实现分布式锁。当 key 不存在时，插入成功；存在则插入失败。</p><p>解锁时为了区分当前线程是否为获取锁的线程，需要先判断，再释放锁。这是两个操作，需要 Lua 脚本保证解锁的原子性。</p><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p>为什么会发生超卖问题？多个线程在同时执行时，对库存的判断和扣减并不是原子性操作，可能导致同一时刻多个线程判断库存都是足够的，然后都执行了扣减库存的操作，从而导致超卖。</p><p>解决方案：</p><p>悲观锁：认为一定会有线程安全问题，每次操作数据库前都要获取锁。常见的悲观锁有：<code>synchronized</code>、<code>lock</code>。</p><p>乐观锁：认为不一定会有线程安全问题，因此不加锁，只是更新数据时区判断有没有其他线程对数据做了修改。常见的有版本号、CAS。</p><p>CAS：首先读取当前的值，在执行 SQL 时，将要修改的字段值与读取的值进行比较，如果不同，说明这期间有其他线程修改了。说明有其他线程涉入修改，于是当前线程放弃修改。</p><p>但在项目中修改库存时，按理说只要库存大于 0 就可以减一，但在并发操作下用了 CAS 后，很多个请求都没有执行 SQL，为什么？ 举个例子：库存初始为 100，线程1和线程2先后查询到库存为 100，线程1先买，库存减一，此时为 99。线程2此时买，发现库存不为原来查询的 100，就不更新了。改进：只要库存大于0，就可以更改。</p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><p>上面的超卖问题是针对单体项目的，也就是单个用户进行购买，但实际需求中是一个用户只能限购一单，如何实现呢？</p><p>起初是多加了个判断：判断当前用户是否在数据库表中有记录了，有说明已经下过单了，但这样还是会一个人下多个单，为什么？还是并发问题，多个线程可能同时判断当前用户未下过单，于是同时操作数据库减库存。我们需要的是判断和操作数据库是一个原子操作。</p><p>单体模式下的解决方案：使用悲观锁，锁的是用户的 id.toString().intern()，不能直接锁 id，每次得到 id 都是新的对象，intern() 表示从常量池中寻找与字符串值一致的对象，这样就能保证同一用户请求时，只有一个用户进入锁中。但这种方式锁住的是当前 JVM 中的对象，集群下有多个 JVM，因此我们需要分布式锁。</p><p>我们通过 nginx 的负载均衡启动 2 台服务器模拟，本地锁 synchronized 会失效，我们需要使用分布式锁。分布式锁的实现用 redis 的 setnx 实现，也就是我们自定义锁替换掉 synchronized。但还有几个问题，1、多个线程如何判断释放的锁是否是自己的呢？</p><p>这里可以给锁拼接上 uuid，增加锁标识的复杂性，释放锁时需要先判断锁存在，再删除锁。但这里又有问题了，如果判断锁存在后单还没删除，发生了堵塞，有其他线程获取了锁，此时前线程堵塞完成，又把锁释放了。</p><p>这里我们将判断锁和释放锁打包为 lua 脚本，具有原子性。</p><p>但我们自定义的锁总有缺陷，如锁不可重入等，我们使用 Redssion 框架。</p><h3 id="Redission-原理"><a href="#Redission-原理" class="headerlink" title="Redission 原理"></a>Redission 原理</h3><p><strong>可重入锁</strong>：用 hash 结构存储   key：锁   field：线程标识   value：重入次数。</p><p><strong>锁重试：</strong>释放时间如果没有指定，则设置为看门狗（30s），执行 lua 脚本：如果当前线程第一次来，记录标识，锁重入次数为 1；如果已经存在锁标识了，那么锁重入次数加 1；否则返回剩余时间。这是一个异步的过程，函数结束后返回，如果得到 null，获取锁成功，否则计算剩余时间，如果小于 0，则剩余时间不够获取锁失败；否则等待一个订阅（其他线程释放锁的信号），得到订阅后才会再次获取锁，在等待过程中如果等待时间大于剩余时间，则取消订阅，返回 false。</p><p><strong>自动续约：</strong>获取锁成功后，判断是否设置了释放时间，没有的话默认是 -1，如果第一次来，添加个定时任务：10s 后更新有效期为 30s，永不过期。释放锁时才会取消。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240308205339316.png" alt="image-20240308205339316"></p><h2 id="3、lua脚本异步操作"><a href="#3、lua脚本异步操作" class="headerlink" title="3、lua脚本异步操作"></a>3、lua脚本异步操作</h2><p>之前的业务是判断库存后通过分布式锁实现一人一单，这是串行操作，效率不高，其实判断库存、一人一单与操作数据库可以隔离开，如果用户有资格下单，就可以返回订单号了，用户不需要等待数据库操作完成即可获得反馈。</p><p>此外，我们在保存优惠券时就可以把优惠券信息存入缓存，在查询用户是否有资格下单时，直接从缓存中查库存就好，并且将购买的用户写入缓存，避开了直接访问数据库。</p><h2 id="4、Sorted-Set-维护点赞排行榜"><a href="#4、Sorted-Set-维护点赞排行榜" class="headerlink" title="4、Sorted Set 维护点赞排行榜"></a>4、Sorted Set 维护点赞排行榜</h2><h1 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h1><h2 id="Zset的底层如何实现"><a href="#Zset的底层如何实现" class="headerlink" title="Zset的底层如何实现"></a>Zset的底层如何实现</h2><p>使用 <strong>ziplist</strong>（压缩链表）和 <strong>skiplist</strong>（跳表）两种。</p><p>当保存的元素少于 128 个，且保存的所有元素都小于 64 字节 -&gt; 使用 ziplist。</p><ul><li><strong>ziplist</strong></li></ul><p>每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。压缩列表内的集合元素按分值从小到大的顺序进行排列。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240317150803917.png" alt="image-20240317150803917"></p><ul><li><h5 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h5></li></ul><p>skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳表。</p><p><strong>跳表我们完全可以理解为在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为O(log n)</strong></p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240317151640081.png" alt="image-20240317151640081"></p><p>为什么用跳表而不用平衡树、红黑树、B+ 树？</p><p>AVG 每次插入、删除之后要保证左右子数的平衡</p><p>B+ 树：</p><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>AOF日志 和 RDB快照</p><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>记录的是命令，将写命令以追加的方式写入文件</p><h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p>记录某一瞬间的实际数据。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis的应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal在多线程下的应用</title>
      <link href="/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal-是什么"><a href="#ThreadLocal-是什么" class="headerlink" title="ThreadLocal 是什么"></a>ThreadLocal 是什么</h2><p>ThreadLocal 叫本地线程变量，该变量对其他线程是透明的，也就是每个线程往 ThreadLocal 中读写时是线程隔离的。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在项目中，可以将 ThreadLocal 定义为一个类，定义写、读方法，比如在涉及用户登录的项目中，可以如下定义</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;UserDTO&gt; tl = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(UserDTO user)</span>&#123;    tl.set(user);&#125;<span class="keyword">public</span> <span class="keyword">static</span> UserDTO <span class="title function_">getUser</span><span class="params">()</span>&#123;    <span class="keyword">return</span> tl.get();&#125;<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeUser</span><span class="params">()</span>&#123;    tl.remove();&#125;</code></pre><p>前端的请求触发拦截器，在拦截器中从 ThreadLocal 取出用户对象，如果不存在，则用户未登录。</p><h2 id="为什么要使用-ThreadLocal"><a href="#为什么要使用-ThreadLocal" class="headerlink" title="为什么要使用 ThreadLocal"></a>为什么要使用 ThreadLocal</h2><p>在多线程下，比如用户登录场景，每个线程可能代表一个不同的用户，此时需要为每个线程（用户）保存一些状态信息，如用户id、登录状态等。这些信息应该是线程间隔离的，互不影响。</p><p>传统的方式是将每个请求都带上用户信息，比较笨拙。有了 ThreadLocal 后，只要在拦截器里从请求头获取到 token，保存到<code>ThreadLocal</code>中，那么在后续的处理过程中，只需要从<code>ThreadLocal</code>中取出用户信息即可。</p><h2 id="项目中具体如何实现通过-ThreadLocal-校验用户是否登录"><a href="#项目中具体如何实现通过-ThreadLocal-校验用户是否登录" class="headerlink" title="项目中具体如何实现通过 ThreadLocal 校验用户是否登录"></a>项目中具体如何实现通过 ThreadLocal 校验用户是否登录</h2><p>ps：有这样一个需求，当用户已经登录时，访问主页（主页是不需要用户登录即可访问），这样并不会触发拦截器（在MvcConfig中进行配置拦截路径），而现在的拦截器中逻辑是只有被拦截到，才会刷新令牌有效期。</p><p>解决方案：设置两个拦截器，第一个只是对登录用户令牌的刷新，并保存到 ThreadLocal，若用户未登录直接放行；第二个拦截器中从 ThreadLocal 中取用户，以此进行拦截。</p><p>前端：当用户未登录时，访问被后端拦截的请求时，会收到后端拦截器的 true 或 false，前端对每个 response 进行了拦截，如下：</p><p><img src="/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/image-20240307171423351.png" alt="image-20240307171423351"></p><p>意思是当用户未登录，就跳转到登录界面。</p><h2 id="ThreadLocal-内存泄露问题："><a href="#ThreadLocal-内存泄露问题：" class="headerlink" title="ThreadLocal 内存泄露问题："></a>ThreadLocal 内存泄露问题：</h2><pre><code class="highlight java"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalMap</span> &#123;    <span class="comment">/**</span><span class="comment">     * The entries in this hash map extend WeakReference, using</span><span class="comment">     * its main ref field as the key (which is always a</span><span class="comment">     * ThreadLocal object).  Note that null keys (i.e. entry.get()</span><span class="comment">     * == null) mean that the key is no longer referenced, so the</span><span class="comment">     * entry can be expunged from table.  Such entries are referred to</span><span class="comment">     * as &quot;stale entries&quot; in the code that follows.</span><span class="comment">     */</span>    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; &#123;        <span class="comment">/** The value associated with this ThreadLocal. */</span>        Object value;        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;            <span class="built_in">super</span>(k);            value = v;        &#125;    &#125;</code></pre><p>可以看到，<code>ThreadLocal</code>实例<code>k</code>传递给了<code>WeakReference</code>的构造函数，这样就创建了一个指向<code>ThreadLocal</code>实例的弱引用。因此，在垃圾回收时，key 会被清理掉，而 value 还在，就可能发生内存泄露。因此，使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法。</p><h2 id="ThreadLocal-底层原理"><a href="#ThreadLocal-底层原理" class="headerlink" title="ThreadLocal 底层原理"></a>ThreadLocal 底层原理</h2><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;        map.set(<span class="built_in">this</span>, value);    &#125; <span class="keyword">else</span> &#123;        createMap(t, value);    &#125;&#125;<span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);    <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;            <span class="keyword">return</span> result;        &#125;    &#125;    <span class="keyword">return</span> setInitialValue();&#125;ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;    <span class="keyword">return</span> t.threadLocals;&#125;</code></pre><p>每个线程中 都有一个 <strong><code>ThreadLocalMap</code><strong>数据结构，每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了</strong>线程隔离</strong>。</p><p>在 ThreadLocalMap 中，初始化了一个 16 大小的 Entry 数组，Entry对象用来保存每一个key-value键值对，但key永远都是ThreadLocal对象。也就是把自己（ThreadLocal）当作 key，放进了ThreadLoalMap 中。</p><p><img src="/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/image-20240308110338325.png" alt="image-20240308110338325"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2024/02/23/MybatisPlus/"/>
      <url>/2024/02/23/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h2 id="MybatisPlus-快速入门"><a href="#MybatisPlus-快速入门" class="headerlink" title="MybatisPlus 快速入门"></a>MybatisPlus 快速入门</h2><p>1、pom.xml 中引入 MybatisPlus 依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p>2、创建实体类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、创建 Mapper 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;&#125;</code></pre><p>4、启动类需要添加 @MapperScan(“mapper所在的包”)</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> org.junit.jupiter.api.Test;<span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> java.util.List;<span class="meta">@SpringBootTest</span><span class="meta">@MapperScan(&quot;com.ai.mybatisplus.mapper&quot;)</span><span class="keyword">class</span> <span class="title class_">StudentMapperTest</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> StudentMapper studentMapper;    <span class="meta">@Test</span>    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;        studentMapper.selectList(<span class="literal">null</span>).forEach(System.out::println);    &#125;&#125;</code></pre><p>5、配置</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span><span class="attr">mybatis-plus:</span>  <span class="attr">configuration:</span>    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><blockquote><p>@TableName</p></blockquote><p>映射数据库的表名</p><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@TableName(value = &quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><blockquote><p>@TableId  主键映射</p></blockquote><p>type 设置主键类型，主键的生成策略</p><pre><code class="highlight java">AUTO(<span class="number">0</span>),数据库自增NONE(<span class="number">1</span>),MP set 主键，雪花算法实现INPUT(<span class="number">2</span>),需要开发者手动赋值ASSIGN_ID(<span class="number">3</span>),MP 分配 ID：Long、Integer、String<span class="title function_">ASSIGN_UUID</span><span class="params">(<span class="number">4</span>)</span>;分配一个 uuid：String</code></pre><blockquote><p>@TableField  其他字段映射</p></blockquote><p>exist 表示是否为数据库字段，如果实体类中的成员变量在数据库中没有对应字段，则可以使用 exist，VO、DTO。</p><p>select 表示是否查询该字段</p><p>fill 表示是否自动化填充，将对象存入数据库时，由 MP 自动给某些字段赋值，例如订单 create_time, update_time。</p><ul><li>如果数据库字段名是 create_time，则在 JavaBean 中 变量名为 createTime，MP 会自动二者进行绑定。</li></ul><p>1、给表添加创建、更新时间</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="meta">@TableName(value = &quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="meta">@TableId(type = IdType.AUTO)</span>    <span class="keyword">private</span> Long id;    <span class="meta">@TableField(select = false)</span>    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;    <span class="meta">@TableField(fill = FieldFill.INSERT)</span>    <span class="keyword">private</span> Date createTime;    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>    <span class="keyword">private</span> Date updateTime;    <span class="meta">@TableField(exist = false)</span>    <span class="keyword">private</span> String gender;&#125;</code></pre><p>2、创建自动填充的处理器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.handler;<span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;<span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Date;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);    &#125;&#125;</code></pre><p>3、测试</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    student.setName(<span class="string">&quot;奥尼尔&quot;</span>);    student.setScore(<span class="number">99d</span>);    student.setBirthday(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;2024-02-23&quot;</span>));    studentMapper.insert(student);&#125;<span class="meta">@Test</span><span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectById(<span class="string">&quot;1760860280444715012&quot;</span>);    student.setScore(<span class="number">80d</span>);    studentMapper.updateById(student);</code></pre><blockquote><p>@Version</p></blockquote><p>标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据时，会以 version 为条件，当条件成立才修改成功。</p><p>线程 1：update … set version &#x3D; 2 where version &#x3D; 1</p><p>线程 2：update … set version &#x3D; 2 where version &#x3D; 1</p><p>代码测试：</p><p>1、数据库表添加 version 字段，默认值为1</p><p>2、实体类添加 version 成员变量，并且添加 @Version</p><p>3、注册配置类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.config;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());        <span class="keyword">return</span> mybatisPlusInterceptor;    &#125;&#125;</code></pre><blockquote><p>@EnumValue</p></blockquote><p>通用枚举类注解，将数据库字段映射成实体类的枚举成员变量</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumStatus</span> &#123;    WORK(<span class="number">1</span>, <span class="string">&quot;上班&quot;</span>),    REST(<span class="number">0</span>, <span class="string">&quot;休息&quot;</span>);    <span class="meta">@EnumValue</span>    <span class="keyword">private</span> Integer code;    <span class="keyword">private</span> String msg;    EnumStatus(Integer code, String msg) &#123;        <span class="built_in">this</span>.code = code;        <span class="built_in">this</span>.msg = msg;    &#125;&#125;</code></pre><p>在实体类添加字段</p><pre><code class="highlight java"><span class="keyword">private</span> EnumStatus status;</code></pre><p>application.yml</p><blockquote></blockquote><pre><code class="highlight yml"><span class="attr">mybatis-plus:</span>  <span class="attr">configuration:</span>    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span>  <span class="attr">type-enums-package:</span> <span class="string">com.ai.mybatisplus.enums</span></code></pre><blockquote><p>@TableLogic</p></blockquote><p>映射逻辑删除</p><p>1、数据表添加 deleted 字段</p><p>2、实体类添加注解</p><pre><code class="highlight java"><span class="meta">@TableLogic</span><span class="keyword">private</span> Integer deleted;</code></pre><p>3、application.yml 添加配置</p><pre><code class="highlight yml"><span class="attr">global-config:</span>  <span class="attr">db-config:</span>    <span class="attr">logic-delete-value:</span> <span class="number">1</span>    <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code class="highlight java"><span class="comment">//        studentMapper.selectBatchIds(Arrays.asList(7, 8)).forEach(System.out::println);</span>        <span class="comment">// Map 只能做等值判断，逻辑判断用 Wrapper</span><span class="comment">//        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><span class="comment">//        map.put(&quot;id&quot;, 7);</span><span class="comment">//        studentMapper.selectByMap(map);</span>        <span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();        wrapper.eq(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>);<span class="comment">//        System.out.println(studentMapper.selectCount(wrapper));</span>        <span class="comment">// 将查询的结果封装到Map中</span><span class="comment">//        studentMapper.selectMaps(wrapper).forEach(System.out::println);</span>        <span class="comment">// 分页查询</span><span class="comment">//        Page&lt;Student&gt; page = new Page&lt;&gt;(1, 2);</span><span class="comment">//        Page&lt;Student&gt; result = studentMapper.selectPage(page, null);</span><span class="comment">//        System.out.println(result.getSize());</span><span class="comment">//        System.out.println(result.getTotal());</span><span class="comment">//        result.getRecords().forEach(System.out::println);</span><span class="comment">//        Page&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(1, 2);</span><span class="comment">//        Page&lt;Map&lt;String, Object&gt;&gt; result = studentMapper.selectMapsPage(page, null);</span><span class="comment">//        result.getRecords().forEach(System.out::println);</span>        <span class="comment">// 拿到主键</span><span class="comment">//        studentMapper.selectObjs(null).forEach(System.out::println);</span>        <span class="comment">// 查询一条数据</span>        System.out.println(studentMapper.selectOne(wrapper));</code></pre><ul><li>分页查询</li></ul><p>1、添加分页拦截器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.config;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();        <span class="comment">// 乐观锁</span>        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());        <span class="comment">// 分页</span>        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());        <span class="keyword">return</span> mybatisPlusInterceptor;    &#125;&#125;</code></pre><p>2、测试</p><pre><code class="highlight java"><span class="comment">// 分页查询</span>Page&lt;Student&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);Page&lt;Student&gt; result = studentMapper.selectPage(page, <span class="literal">null</span>);System.out.println(result.getSize());System.out.println(result.getTotal());result.getRecords().forEach(System.out::println);</code></pre><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><pre><code class="highlight java"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();student.setName(<span class="string">&quot;奥尼尔&quot;</span>);student.setScore(<span class="number">99d</span>);student.setBirthday(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;2024-02-23&quot;</span>));studentMapper.insert(student);</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="highlight java"><span class="comment">//        studentMapper.deleteById(4L);</span>        <span class="comment">//        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><span class="comment">//        map.put(&quot;id&quot;, 4);</span><span class="comment">//        studentMapper.deleteByMap(map);</span></code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><pre><code class="highlight java"><span class="comment">//        Student student = studentMapper.selectById(&quot;4&quot;);</span><span class="comment">//        student.setName(&quot;麻子&quot;);</span><span class="comment">//        studentMapper.updateById(student);</span>        QueryWrapper&lt;Student&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();        wrapper.eq(<span class="string">&quot;score&quot;</span>, <span class="number">90</span>);        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectById(<span class="number">1</span>);        student.setScore(<span class="number">96d</span>);        studentMapper.update(student, wrapper);</code></pre><h2 id="自定义SQL、多表关联"><a href="#自定义SQL、多表关联" class="headerlink" title="自定义SQL、多表关联"></a>自定义SQL、多表关联</h2><p>productVo:  将两个表的信息整合到 vo 里，由于 vo 不能对应数据库的表，因此不能使用 @FieldValue() 等注解。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVo</span> &#123;    <span class="keyword">private</span> Integer category;    <span class="keyword">private</span> Integer count;    <span class="keyword">private</span> String description;    <span class="keyword">private</span> Long studentId;    <span class="keyword">private</span> String studentName;&#125;</code></pre><p>studentMapper  添加自定义 SQL 语句，多表关联。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.ProductVo;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;    <span class="meta">@Select(&quot;select p.*, name studentName from product p, student s where p.student_id = s.id and s.id = #&#123;id&#125;&quot;)</span>    List&lt;ProductVo&gt; <span class="title function_">productList</span><span class="params">(Integer id)</span>;&#125;</code></pre><h2 id="MyBatisPlus-自动生成"><a href="#MyBatisPlus-自动生成" class="headerlink" title="MyBatisPlus 自动生成"></a>MyBatisPlus 自动生成</h2><p>根据数据表自动生成实体类、Mapper、Service、ServiceImpl、Controller</p><p>1、pom.xml 导入MyBatis Plus Generator</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础小记</title>
      <link href="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指不同的子类对同一种行为有不同的表现形式。多态包括编译时多态（重载）和运行时多态（重写）。重载：方法名相同，参数列表不同（参数个数、类型、顺序），返回值、访问修饰符也可以不同。</p><h3 id="String-的不可变"><a href="#String-的不可变" class="headerlink" title="String 的不可变"></a>String 的不可变</h3><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173405251.png" alt="image-20240222173405251"></p><p>修改 s 变量时，不在原来的地址上修改，而是指向新的引用地址。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173659994.png" alt="image-20240222173659994"></p><p>value 用 final 修饰，指的是 value 变量的引用不能更改，不能指向其他地址。</p><p>但数组本身是可以修改值的，这并不会对其地址有影响。</p><ul><li>设计成不可变，可以使用字符串常量池。</li></ul><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？</h3><p>1 个或 2 个。一、如果字符串常量池中没有字符串对象 “abc” 的引用，则它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222170700469.png" alt="image-20240222170700469"></p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><blockquote><p>对于 String &#x3D; “abc”，如果常量池中有 “abc” 字符串对象，就直接指向它；否则会在常量池中创建一个 “abc” 字符串对象。</p></blockquote><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><p>三种方式：重写 clone() 方法、<strong>通过序列化实现</strong>、<strong>利用反射方式实现</strong></p><h2 id="可以不重写-hashcode-吗？"><a href="#可以不重写-hashcode-吗？" class="headerlink" title="可以不重写 hashcode 吗？"></a>可以不重写 hashcode 吗？</h2><p>不可以，如果两个对象通过 equals 判断是相等的，但哈希码不同，当用作哈希表的键时，可能不能正常工作。例如，当向 HashSet 中添加两个逻辑上相等的对象时，本应该只有一个呗存储，但因为哈希码不同，被存储了两次。这就违反了 Set 集合中唯一性的约束。</p><h2 id="String-类型的变量和常量用-“-”-运算符发生了什么？"><a href="#String-类型的变量和常量用-“-”-运算符发生了什么？" class="headerlink" title="String 类型的变量和常量用 “+” 运算符发生了什么？"></a>String 类型的变量和常量用 “+” 运算符发生了什么？</h2><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;<span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;System.out.println(str3 == str4);<span class="comment">//false</span>System.out.println(str3 == str5);<span class="comment">//true</span>System.out.println(str4 == str5);<span class="comment">//false</span></code></pre><ul><li><p>对于 String str3 &#x3D; “str” + “ing”;<code>编译器会优化成</code>String str3 &#x3D; “string”;</p></li><li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p></li></ul><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</code></pre><p>String str &#x3D; “abc” + new String(“def”); 创建了几个对象？（假设常量池中没有缓存）</p><p>这会被优化为 </p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>);<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;abc&quot;</span>).append(s).toString();</code></pre><p>创建了 5 个对象  new StringBuilder() -&gt; “abc” -&gt; “def” -&gt; new String() -&gt; toString()</p><h2 id="final-可以加在哪里，有什么作用"><a href="#final-可以加在哪里，有什么作用" class="headerlink" title="final 可以加在哪里，有什么作用"></a>final 可以加在哪里，有什么作用</h2><p>类：这个类不能被继承，<code>final</code> 类中的所有成员方法都隐式地指定为 <code>final</code>，但是字段不自动成为 <code>final</code>。</p><p>方法：这个方法不能被子类覆盖或重写。</p><p>变量：该变量的值一旦被初始化之后就不能被改变。对于基本数据类型，它的值不能被改变。对于引用类型，它的引用不能改变，但对引用的对象本身是可以修改的。</p><h2 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h2><p>每个线程都有一个私有的本地内存，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。如果线程间需要通信，必须通过主内存来进行。<img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240313145809511.png" alt="image-20240313145809511"></p><h2 id="Java-的锁"><a href="#Java-的锁" class="headerlink" title="Java 的锁"></a>Java 的锁</h2><p>分为本地锁和分布式锁。</p><p>在单机（单 JVM）情况下，线程之间共用一个 JVM，只要使用线程锁就可以解决并发问题。但在分布式情况下，线程 A 与 线程 B 可能不在一个 JVM 下，我们需要分布式锁。</p><p>常用的本地锁：synchronized 和 lock。</p><h3 id="synchronized-底层原理："><a href="#synchronized-底层原理：" class="headerlink" title="synchronized 底层原理："></a>synchronized 底层原理：</h3><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);        &#125;    &#125;&#125;</code></pre><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240314143223478.png" alt="image-20240314143223478"></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。除了正常出口的 monitorexit，还在异常处理代码里插入了 monitorexit。</p><p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><h3 id="锁的如何升级的"><a href="#锁的如何升级的" class="headerlink" title="锁的如何升级的"></a>锁的如何升级的</h3><p><strong>偏向锁：</strong>当线程第一次获得锁，通过 CAS 修改对象头中的锁标志位，这就是偏向锁。只适用于只有一个线程访问同步区域的场景。线程在后续访问时检测 Mark Word 里是否存储着指向当前线程的偏向锁。</p><p><strong>轻量级锁：</strong>轻量级锁是指当锁是偏向锁的时候，却被另外的线程所访问，此时偏向锁就会升级为轻量级锁。在轻量级锁状态下继续锁竞争，没有抢到锁的线程将自旋，即不停地循环判断锁是否能够被成功获取。</p><p><strong>重量级锁：</strong>如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁。当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起（而不是忙等），等待将来被唤醒。</p><h3 id="volatile-和-synchronized"><a href="#volatile-和-synchronized" class="headerlink" title="volatile 和 synchronized"></a>volatile 和 synchronized</h3><ul><li><p>volatile 只能修饰变量，synchronized 可以修饰方法，代码块，类</p></li><li><p>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程。</p></li><li><p>volatile读相当于获取了一个锁（读取了从主存中最新的值，防止读到过期数据），volatile写相当于释放了一个锁（立即将更改的值写入主存，防止其它线程读到过期数据）。<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</p></li><li><p>synchronized既能够保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。</p></li></ul><h2 id="Cookies-和-Session-的区别"><a href="#Cookies-和-Session-的区别" class="headerlink" title="Cookies 和 Session 的区别"></a>Cookies 和 Session 的区别</h2><p>1、当用户第一次登录成功后，服务器会创建一个 Session，并为这个 Session 创建唯一的 SessionID。Session 保存在服务器端，保存了用户的状态信息。</p><p>2、服务器将这个唯一的 SessionID 存储到一个 Cookies 中，并通过 HTTP 响应将该 Cookies 发生给用户的 Web 浏览器。</p><p>3、用户的浏览器会保存这个 Cookies，后续请求都会携带此 Cookies 发送回服务器。</p><p>4、服务器会读取 Cookies 中的 SessionID，通过它找到 Session 数据，里面包含了用户的状态信息，如登录凭证、购物车内存等。</p><p>5、当用户退出登录或 Session 过期后，服务器会销毁 Session 数据。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>池化思想：线程池、字符串常量池、数据库连接池</p><p>提高资源的利用率</p><p>1、手动创建线程对象</p><p>2、执行任务</p><p>3、执行完毕，释放线程对象</p><p>线程池在系统中开辟一块区域，存放一些待命的线程，这些线程会等待任务的到来。一旦有任务需要执行，线程池会从这些待命的线程中选取一个来执行任务，任务执行完毕后，线程会返回线程池等待下一次的任务分配。</p><p><strong>资源重用</strong>：手动创建线程的话用完就销毁了，线程池显著降低了线程创建和销毁所带来的资源消耗。</p><p><strong>提高响应速度</strong>：由于线程池已经预先存在，任务到达可以立即执行，不需要等待线程创建。</p><p><strong>控制并发数</strong>：线程池可以有效地控制并发执行的任务数量，通过设置线程池的核心线程数、最大线程数以及队列大小等参数，根据系统的承载能力限制并发级别。</p><h3 id="线程池的7个参数和工作原理"><a href="#线程池的7个参数和工作原理" class="headerlink" title="线程池的7个参数和工作原理"></a>线程池的7个参数和工作原理</h3><pre><code class="highlight java"><span class="type">int</span> corePoolSize,    <span class="comment">// 核心线程数，创建后不会被回收</span><span class="type">int</span> maximumPoolSize,   <span class="comment">// 最大线程数，当核心线程数已满、最大线程数未满，就创建一个新线程</span><span class="type">long</span> keepAliveTime,  <span class="comment">// 空闲线程存活时间，当可被回收的线程大于keepAliveTime被回收</span>TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 工作队列，当提交的任务超过核心线程数，再提交的任务就放到工作队列</span>ThreadFactory threadFactory,  <span class="comment">// 线程工厂，可以设定线程名、线程编号等</span>RejectedExecutionHandler handler <span class="comment">// 拒绝策略</span></code></pre><h3 id="怎么关闭线程池？"><a href="#怎么关闭线程池？" class="headerlink" title="怎么关闭线程池？"></a>怎么关闭线程池？</h3><p>shutdown()：会在当前运行的线程执行完任务后关闭它们。</p><p>shutdownNow()：会试图停止所有正在执行的任务，并返回还没有开始执行的任务。并不保证每个任务都能成功停止，因为这个方法本质是对线程池每个线程调用了 interrupt() 方法来尝试取消线程的执行，但中断一个线程是非强制性的，也就是它只是给线程发送了一个取消的信号，而线程能否响应，怎样响应是取决于线程本身的。</p><h2 id="Java-线程通信的主要方式"><a href="#Java-线程通信的主要方式" class="headerlink" title="Java 线程通信的主要方式"></a>Java 线程通信的主要方式</h2><p><strong>volatile关键字</strong>：</p><ul><li>所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存</li><li>所有volatile修饰的变量在使用之前必须重新读取主内存的值</li></ul><p><strong>等待&#x2F;通知机制</strong>：等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h3><ul><li>安全性：HashMap 是线程不安全的，HashTable 是线程安全的</li><li>HashMap 可以使用null作为key，Hashtable则不允许null作为key</li><li>扩容：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:<code>capacity</code> *<code>2</code><strong>，Hashtable扩容时是容量翻倍+1即:</strong><code>capacity</code>* <code>(2+1)</code>。</li></ul><h3 id="HashMap-1-7-和-1-8"><a href="#HashMap-1-7-和-1-8" class="headerlink" title="HashMap 1.7 和 1.8"></a>HashMap 1.7 和 1.8</h3><p>1.7 底层是数组加链表，1.8底层是数组+链表+红黑树。</p><p>当 put 一个 Node 时，会计算 key 的 hashcode， 再通过将 hashcode 与 (n - 1) 进行与运算，有两种情况：</p><p>1、数组索引的元素是空的，这种情况很简单，直接将元素放进去就好了。</p><p>2、已经有元素占据了索引位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。<strong>如果两者相等则直接覆盖</strong>，<strong>如果不等则在原元素下面使用链表的结构存储该元素</strong></p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240320110614657.png" alt="image-20240320110614657"></p><p>当链表的元素个数达到8并且数组长度超过64的时候使用链表存储就转变成了使用红黑树存储。</p><p>HashMap中有两个重要的参数：<strong>初始容量大小和加载因子</strong>。初始容量大小为 16，默认加载因子为 0.75。</p><h3 id="HashMap-的扩容"><a href="#HashMap-的扩容" class="headerlink" title="HashMap 的扩容"></a>HashMap 的扩容</h3><p>在 1.8 中，对原数组的容量 &lt;&lt; 2，如果没超过最大容量，对原数组每个元素重新计算 hash 值：</p><p>1、如果元素只有自己，直接放进新数组。</p><p>2、如果是树结点，分成两个链表。</p><p>3、如果是链表，就对链表遍历，</p><h3 id="为什么加载因子设置为-0-75？"><a href="#为什么加载因子设置为-0-75？" class="headerlink" title="为什么加载因子设置为 0.75？"></a>为什么加载因子设置为 0.75？</h3><p>往哈希表中放数据类似骰硬币，01分布。做个假设：扔 k 次骰子，没有一次是相同的概率。</p><p>二项分布 Cn^0 </p><h3 id="为什么-HashMap-不安全"><a href="#为什么-HashMap-不安全" class="headerlink" title="为什么 HashMap 不安全?"></a>为什么 HashMap 不安全?</h3><ul><li>多线程下扩容会死循环</li><li>多线程下 put 会导致元素丢失</li><li>put 和 get 并发时会导致 get 到 null</li></ul><p>CopyonWriteArraylist：读写、读读都不互斥，只有写写互斥。多个线程可以同时读。</p><pre><code class="highlight java"><span class="comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 加锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 获取原来的数组</span>        Object[] elements = getArray();        <span class="comment">// 原来数组的长度</span>        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;        <span class="comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);        <span class="comment">// 元素放在新数组末尾</span>        newElements[len] = e;        <span class="comment">// array指向新数组</span>        setArray(newElements);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">// 解锁</span>        lock.unlock();    &#125;&#125;</code></pre><p>也就是对数组进行增加元素时，会复制出一份新的数组，并将元素加到新的数组。</p><p>对数组进行修改时，会分段复制，index 前的和 index 后的分别复制到新数组。</p><h1 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h1><h2 id="介绍下-Spring-IOC-和-Spring-Aop"><a href="#介绍下-Spring-IOC-和-Spring-Aop" class="headerlink" title="介绍下 Spring IOC 和 Spring Aop"></a>介绍下 Spring IOC 和 Spring Aop</h2><p>ioc 是控制反转，ioc 可以看作一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系。</p><p>aop 是面向切面编程，当类中的方法有大量冗余的且与业务无关的代码，我们可以将它们通过注解方式抽离出来，让开发者只关心业务逻辑。</p><p>Spring AOP 的实现原理是基于<strong>动态代理</strong>和<strong>字节码操作</strong>实现的。在编译时，Spring 会使用 AspectJ 编译器将切面代码编译成字节码文件。在运行时，Spring 会使用 <strong>Java 动态代理或 CGLIB 代理</strong>生成代理类。代理类会在目标对象方法执行前后插入切面代码，从而实现 AOP。</p><p>Spring AOP 可以使用两种代理方式：JDK动态代理和 CGLIB 代理。如果目标对象实现了至少一个接口，则使用JDK动态代理；否则，使用 CGLIB 代理。</p><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240326162005596.png" alt="image-20240326162005596"></p><ul><li><p>实例化、属性赋值、初始化、销毁。</p></li><li><p>初始化的具体操作：Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及InitializingBean 和 init-method 的初始化操作。</p></li><li><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p></li></ul><h2 id="Bean-会被垃圾回收吗"><a href="#Bean-会被垃圾回收吗" class="headerlink" title="Bean 会被垃圾回收吗"></a>Bean 会被垃圾回收吗</h2><p><strong>Bean没有被其他Bean引用，且容器也没有任何引用指向它时</strong>，会变成一个不可达对象，就会被垃圾回收。但在 Spring 中的 Bean 是单例的，一直存活在应用程序的整个生命周期中，所以除非应用程序结束或 Spring 容器被销毁，否则是不会被 GC 的。</p><h2 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h2><p>@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</p><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p><p>@ComponentScan：扫描被<code>@Component</code> (<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240326105137278.png" alt="image-20240326105137278"></p><p>Spring Boot 通过 <strong><code>@EnableAutoConfiguration</code></strong> 开启自动装配，通过 <strong><code>SpringFactoriesLoader</code></strong> 最终加载 <strong><code>META-INF/spring.factories</code></strong> 中的自动配置类实现自动装配，自动配置类其实就是通过 <strong><code>@Conditional</code></strong> 按需加载的配置类，想要其生效必须引入 <strong><code>spring-boot-starter-xxx</code></strong> 包实现起步依赖。</p><h2 id="Spring-常见的一些模块"><a href="#Spring-常见的一些模块" class="headerlink" title="Spring 常见的一些模块"></a>Spring 常见的一些模块</h2><p>Spring Core：供 ioc 容器</p><p>Spring AOP</p><p>Spring DAO：JDBC的抽象层</p><p>Spring ORM：实体关系映射</p><p>Spring Web</p><p>Spring Web MVC</p><h4 id="Spring-Test：单元测试"><a href="#Spring-Test：单元测试" class="headerlink" title="Spring Test：单元测试"></a>Spring Test：单元测试</h4><h2 id="动态获取spring容器里面的bean"><a href="#动态获取spring容器里面的bean" class="headerlink" title="动态获取spring容器里面的bean"></a>动态获取spring容器里面的bean</h2><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);</code></pre><h2 id="Autowired-和-Resource"><a href="#Autowired-和-Resource" class="headerlink" title="@Autowired 和 @Resource"></a>@Autowired 和 @Resource</h2><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240325135256785.png" alt="image-20240325135256785"></p><p>springmvc 流程：</p><p>1、客户端发起请求，DispatchServlet 拦截请求。</p><p>2、DispatchServlet 调用 HandlerMapping，去查找对应的 handler (也就是 controller)。</p><p>3、DispatchServlet 调用 HanderAdapter 执行 handler。</p><p>4、handler 执行完毕后返回 ModelAndView，视图解析器 ViewResolver 会查找实际的 view，DispatchServlet 会把 model 渲染到 view 上。</p><p>5、把 view 返回给浏览器。</p><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h2><p>#{} 方式是先用占位符代替参数将SQL语句先进行预编译，再将参数中的内容替换进来。由于SQL语句已经被预编译过，其SQL意图将无法通过非法的参数内容实现更改，其参数中的内容，无法变为SQL命令的一部分。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="join-和-left-join"><a href="#join-和-left-join" class="headerlink" title="join 和 left  join"></a>join 和 left  join</h2><p>JOIN：返回两个表中都有匹配的行</p><p>left JOIN：返回左表的所有行，如果在右表没有为 null。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试常见知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot小记</title>
      <link href="/2024/02/21/SpringBoot%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/21/SpringBoot%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1、在 Controller 中注入 Repository 的接口：</p><pre><code class="highlight java"><span class="meta">@Autowired</span><span class="keyword">private</span> StudentRepository studentRepository;</code></pre><p>注意在 studentRepositoryImpl 中添加 @Repository 注解。</p><p>2、@RequestBody 接收一个 JSON 格式的数据，可以用 postman 发送 JSON 格式数据，但如果前端是 JSP，使用的是 <code>application/x-www-form-urlencoded</code> 或者 <code>multipart/form-data</code>，则前端不需要添加注解。</p><pre><code class="highlight java"><span class="meta">@PostMapping(&quot;/save&quot;)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;    studentRepository.saveOrUpdate(student);&#125;</code></pre><h2 id="SpringBoot-整合-Mybatis"><a href="#SpringBoot-整合-Mybatis" class="headerlink" title="SpringBoot 整合 Mybatis"></a>SpringBoot 整合 Mybatis</h2><p>1、建表</p><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY auto_increment,name <span class="type">VARCHAR</span>(<span class="number">11</span>),score <span class="keyword">DOUBLE</span>,birthday <span class="type">DATE</span>)</code></pre><p>2、创建实体类</p><p>3、创建 StudentRepository 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.repository;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> &#123;    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Student student)</span>;    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student student)</span>;    <span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">(Long id)</span>;&#125;</code></pre><p>4、创建 Mapper 接口</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.repository.StudentRepository&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        select * from student    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span>        select * from student where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        insert into student(name, score, birthday) values (#&#123;name&#125;, #&#123;score&#125;, #&#123;birthday&#125;)    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        update student set name = #&#123;name&#125;, score = #&#123;score&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">update</span>&gt;</span>    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span>        delete from student where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><p>6、创建 StudentHandler，注入 StudentRepository</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> com.ai.repository.StudentRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    StudentRepository studentRepository;    <span class="meta">@PostMapping(&quot;/add&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        studentRepository.add(student);    &#125;    <span class="meta">@DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;        studentRepository.deleteById(id);    &#125;    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span>    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> studentRepository.findAll();    &#125;    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="keyword">return</span> studentRepository.findById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        studentRepository.update(student);    &#125;&#125;</code></pre><p>7、创建配置文件 yml</p><pre><code class="highlight yaml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span><span class="attr">mybatis:</span>  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapping/*.xml</span>  <span class="attr">type-aliases-package:</span> <span class="string">com.ai.entity</span></code></pre><p>8、创建启动类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai;<span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="meta">@SpringBootApplication</span><span class="meta">@MapperScan(&quot;com.ai.repository&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span>    &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;</code></pre><h2 id="SpringBoot-整合-Spring-Data-JPA"><a href="#SpringBoot-整合-Spring-Data-JPA" class="headerlink" title="SpringBoot 整合 Spring Data JPA"></a>SpringBoot 整合 Spring Data JPA</h2><p>1、添加依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-jpa<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、实体类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> javax.persistence.*;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="meta">@Entity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="keyword">private</span> Long id;    <span class="meta">@Column</span>    <span class="keyword">private</span> String name;    <span class="meta">@Column</span>    <span class="keyword">private</span> Double score;    <span class="meta">@Column</span>    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、创建 StudentRepository 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.repository;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student, Long&gt; &#123;&#125;</code></pre><p>4、创建 StudentHandler，注入 StudentRepository</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> com.ai.repository.StudentRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    StudentRepository studentRepository;    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span>    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> studentRepository.findAll();    &#125;    <span class="meta">@GetMapping(&quot;findById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="keyword">return</span> studentRepository.findById(id).get();    &#125;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">save</span><span class="params">(Student student)</span> &#123;        <span class="keyword">return</span> studentRepository.save(student);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">update</span><span class="params">(Student student)</span> &#123;        <span class="keyword">return</span> studentRepository.save(student);    &#125;    <span class="meta">@DeleteMapping(&quot;/delete&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long id)</span> &#123;        studentRepository.deleteById(id);    &#125;&#125;</code></pre><p>5、配置文件</p><pre><code class="highlight yaml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306?mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>  <span class="attr">jpa:</span>    <span class="attr">show-sql:</span> <span class="literal">true</span>    <span class="attr">properties:</span>      <span class="attr">hibernate:</span>        <span class="attr">format_sql:</span> <span class="literal">true</span></code></pre><h2 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h2><p>1、导入依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-redis<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、创建实体类，实现序列化接口，否则无法写入 redis 数据库。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.io.Serializable;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、控制器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RedisTemplate redisTemplate;    <span class="meta">@PostMapping(&quot;/set&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        redisTemplate.opsForValue().set(<span class="string">&quot;student&quot;</span>, student);    &#125;&#125;</code></pre><p>4、配置文件 application.yml</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">redis:</span>    <span class="attr">host:</span> <span class="string">localhost</span>    <span class="attr">database:</span> <span class="number">0</span>    <span class="attr">port:</span> <span class="number">6379</span></code></pre><h3 id="Redis-5-种数据类型"><a href="#Redis-5-种数据类型" class="headerlink" title="Redis 5 种数据类型"></a>Redis 5 种数据类型</h3><ul><li>字符串</li><li>列表</li><li>集合</li><li>有序集合</li><li>哈希</li></ul><h2 id="SpringBoot-整合-SpringSecurity"><a href="#SpringBoot-整合-SpringSecurity" class="headerlink" title="SpringBoot 整合 SpringSecurity"></a>SpringBoot 整合 SpringSecurity</h2><p>1、导入依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、创建 Handler</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> &#123;    <span class="meta">@GetMapping(&quot;/index&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;    &#125;&#125;</code></pre><p>3、创建 application.yml 并设置自定义密码</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">thymeleaf:</span>    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span>    <span class="attr">suffix:</span> <span class="string">.html</span>  <span class="attr">security:</span>    <span class="attr">user:</span>      <span class="attr">name:</span> <span class="string">admin</span>      <span class="attr">password:</span> <span class="number">1314</span></code></pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>定义两个 HTML 资源：index.html、admin.html，同时定义两个角色：admin,  user，admin 拥有访问这两个资源的权限，user 只能访问 index.html。</p><p>权限给角色，角色赋给用户（账号）。账户有多个角色，也就用了多种权限。</p><p>7、创建 SecurityConfig 类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.config;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="meta">@Configuration</span><span class="meta">@EnableWebSecurity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 角色和权限的关系</span>        http.authorizeRequests().antMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)                .antMatchers(<span class="string">&quot;/index&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) or hasRole(&#x27;USER&#x27;)&quot;</span>)                .anyRequest().authenticated()                .and()                .formLogin()                .loginPage(<span class="string">&quot;/login&quot;</span>)                .permitAll()                .and()                .logout()                .permitAll()                .and()                .csrf()                .disable();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 账户和角色的关系</span>        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>())                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>().encode(<span class="string">&quot;123&quot;</span>)).roles(<span class="string">&quot;USER&quot;</span>)                .and()                .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>().encode(<span class="string">&quot;123&quot;</span>)).roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>);    &#125;&#125;</code></pre><p>8、修改 Handler </p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> &#123;    <span class="meta">@GetMapping(&quot;/index&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/admin&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/login&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;    &#125;&#125;</code></pre><p>9、login.html</p><pre><code class="highlight html"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/html&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span>    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 有三种方式初始化：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;    Object[] a = c.toArray();    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;            elementData = a;        &#125; <span class="keyword">else</span> &#123;            elementData = Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// replace with empty array.</span>        elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><ul><li>无参方式创建时，初始化为空数组，等到第一个元素 add 时，数组才扩容到默认值 10。</li></ul><p>先从 add 方法入手：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>第一次 add 时，size 为 0，我们进入 ensureCapacityInternal 方法：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>在 calculateCapacity 这个方法中，如果当前数组为空（第一次 add 时），就返回默认容量和最小容量中的较大值作为所需容量。否则直接返回 minCapacity。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="keyword">return</span> minCapacity;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    modCount++;    <span class="comment">// overflow-conscious code</span>    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)        grow(minCapacity);&#125;</code></pre><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    <span class="comment">// overflow-conscious code</span>    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)        newCapacity = minCapacity;    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>到这里为止，我们添加第一个元素，数组容量由 空数组 扩容到容量为 10 的数组。如何扩容的呢？ 核心实现在 grow 方法中，此时 minCapacity &#x3D; 10， newCapacity &#x3D; 0，第一个 if 满足条件，newCapacity 赋值为 10。数组被复制到一个扩容后的新数组。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;  <span class="comment">// 申请一个新的数组</span>    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,                     Math.min(original.length, newLength));    <span class="keyword">return</span> copy;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList扩容机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传图片</title>
      <link href="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>今天在使用 typora 写好笔记后，上传至 hexo 服务器，发现图片还是读取的本地路径。通过参考其他人的经验找到一种解决方法。</p><p>1、在 typora 设置中勾选如下选项，作用是图片使用相对路径。</p><p><img src="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20240106172757156.png" alt="image-20240106172757156"></p><p>2、安装插件即可，不需要再设置<code>图片根目录</code>。</p><pre><code class="highlight javascript">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></code></pre><p>至此在浏览器就可以正常显示图片了。（ps: 前提是根目录下的_config.yml文件中的post_asset_folder字段已经设置为true）</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2023/12/15/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/15/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架两大核心机制-IOC、AOP"><a href="#Spring框架两大核心机制-IOC、AOP" class="headerlink" title="Spring框架两大核心机制(IOC、AOP)"></a>Spring框架两大核心机制(IOC、AOP)</h2><ul><li>IOC（控制反转）&#x2F; DI （依赖注入）</li><li>AOP （面向切面编程）</li></ul><p>Spring是一个企业级的开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p><p>MVC：Struts2、Spring MVC</p><p>ORMapping：Hibernate、Mybatis、Spring Data</p><p>什么是控制反转：对象由调用者主动new出来。而在Spring中创建对象由IOC容器创建，再推送给调用者，整个流程完成反转，就称作控制反转。</p><h2 id="如何使用IOC"><a href="#如何使用IOC" class="headerlink" title="如何使用IOC"></a>如何使用IOC</h2><ul><li>创建Maven工程，添加pom.xml依赖</li></ul><pre><code class="highlight java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;<span class="number">5.3</span><span class="number">.29</span>&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li><p>创建实体类Student</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;&#125;</code></pre></li><li><p>传统的开发方式  手动new</p></li><li><p>通过IOC创建对象，在XML配置文件中添加需要管理的对象</p></li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><ul><li>从IOC中获取对象</li></ul><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) applicationContext.getBean(<span class="string">&quot;student&quot;</span>);System.out.println(student);</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>通过配置<code>bean</code>标签完成对象的管理</p><ul><li>id : 对象名</li><li>class：对象的模版类（所有交给IOC构建的对象都要有无参构造，因为Spring底层是通过反射机制创建对象的，反射机制调用的是无参构造）</li></ul></li><li><p>成员变量通过<code>property</code> 标签完成赋值</p><ul><li><code>name</code>：成员变量名</li><li><code>value</code>：成员变量的值（基本数据类型，Spring可以直接赋值，其他类型不能通过value赋值）</li><li><code>ref</code>：将IOC中的另外一个bean赋值给当前变量（DI 依赖注入）</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ul><li>读取配置文件，解析XML</li><li>通过反射机制实例化配置文件中所配置的所有bean。</li></ul><h3 id="通过运行时类获取bean"><a href="#通过运行时类获取bean" class="headerlink" title="通过运行时类获取bean"></a>通过运行时类获取bean</h3><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);System.out.println(st);</code></pre><p>这种方式存在问题，配置文件中一个数据类型对象只能有一个实例，因为是通过Class中获取的，Class中数据类型是一样的。</p><h3 id="通过有参构造创建对象"><a href="#通过有参构造创建对象" class="headerlink" title="通过有参构造创建对象"></a>通过有参构造创建对象</h3><ul><li><p>在实体类中创建有参函数</p></li><li><p>配置文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="给bean注入集合"><a href="#给bean注入集合" class="headerlink" title="给bean注入集合"></a>给bean注入集合</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span> &gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="scope作用域"><a href="#scope作用域" class="headerlink" title="scope作用域"></a>scope作用域</h3><p>Spring管理的bean是根据bean来生成的，表示bean的作用域，共4种，默认是singleton。</p><ul><li>singleton：单例，表示通过Spring容器获取的bean是唯一的。</li><li>prototype：原型，表示通过Spring容器获取的bean是不同的。</li><li>request：请求，表示在一次HTTP请求内有效。</li><li>session：会话，表示在一个用户会话内有效。</li></ul><p>request 和 session 只适用于Web项目，大多数情况下，使用单例和原型较多。</p><p>request模式在加载配置文件时就创建了xml中所有的bean。</p><p>prototype模式当业务代码获取IOC容器中的bean时，Spring才去调用无参构造创建对应的bean。</p><h3 id="Spring的继承"><a href="#Spring的继承" class="headerlink" title="Spring的继承"></a>Spring的继承</h3><p>与JAVA中的继承不同，JAVA是类层面的继承，子类可以继承父类的结构和信息；Spring是对象层面的继承，子对象可以继承父对象的属性值。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lala&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;student2&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><ul><li>不同类型的对象某些情况也是可以继承的，需要子对象的属性包含父对象的属性。</li></ul><h3 id="Spring的依赖"><a href="#Spring的依赖" class="headerlink" title="Spring的依赖"></a>Spring的依赖</h3><p>与继承类似，依赖也是描述bean和bean之间的一种关系，配置依赖后，被依赖的bean先创建，再创建依赖的bean。如A依赖于B，则先创建B，再创建A。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.User&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="Spring的-p-命名空间"><a href="#Spring的-p-命名空间" class="headerlink" title="Spring的 p 命名空间"></a>Spring的 p 命名空间</h3><p>p 命名空间是对IOC &#x2F; DI的简化操作，使用 p 命名空间可以更加方便的完成bean的配置以及bean之间的依赖注入。</p><h3 id="Spring的工厂方法"><a href="#Spring的工厂方法" class="headerlink" title="Spring的工厂方法"></a>Spring的工厂方法</h3><p>IOC通过工厂模式创建 bean 的方式有两种：</p><ul><li>静态工厂模式</li><li>实例工厂方法</li></ul><p>静态工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.AllArgsConstructor;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> lombok.NoArgsConstructor;<span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructor</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCarFactory</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Car&gt; carMap;    <span class="keyword">static</span> &#123;        carMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        carMap.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大G&quot;</span>));        carMap.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;宝马&quot;</span>));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> carMap.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java">&lt;!--配置静态工厂创建bean--&gt;    &lt;bean id=<span class="string">&quot;car&quot;</span> class=<span class="string">&quot;com.study.factory.StaticCarFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;        &lt;constructor-arg value=<span class="string">&quot;1&quot;</span>&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>实例工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCarFactory</span> &#123;    <span class="keyword">private</span> Map&lt;Long, Car&gt; map;    <span class="keyword">public</span> <span class="title function_">InstanceCarFactory</span><span class="params">()</span> &#123;        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大奔&quot;</span>));        map.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;沃尔沃&quot;</span>));    &#125;    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> map.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-factory.xml&quot;</span>);<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) applicationContext.getBean(<span class="string">&quot;car2&quot;</span>);System.out.println(car);</code></pre><pre><code class="highlight java">&lt;!--实例工厂创建bean--&gt;&lt;bean id=<span class="string">&quot;carFactory&quot;</span> class=<span class="string">&quot;com.study.factory.InstanceCarFactory&quot;</span>&gt;&lt;/bean&gt;&lt;bean id=<span class="string">&quot;car2&quot;</span> class=<span class="string">&quot;com.study.entity.Car&quot;</span> factory-bean=<span class="string">&quot;carFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;    &lt;constructor-arg value=<span class="string">&quot;2&quot;</span>&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="IOC自动装载（Autowire）"><a href="#IOC自动装载（Autowire）" class="headerlink" title="IOC自动装载（Autowire）"></a>IOC自动装载（Autowire）</h3><p>IOC负责创建对象，DI完成对象的依赖注入，通过配置property标签的 ref 属性完成，同时Spring提供了更加简便的依赖注入方式：自动装载，不需要手动配置property，IOC容器会自动选择 bean 完成注入。</p><p>自动装载有两种方式：</p><ul><li>byName：通过属性名自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><ul><li>byType：通过属性的类型自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><p>byType需要注意，如果同时存在两个及以上的bean时，会抛出异常。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP：Aspect Oriented Programming 面向切面编程</p><p>AOP的优点：</p><ul><li>降低模块的耦合度</li><li>使系统更容易扩展</li><li>更好的代码服用</li><li>非业务代码更加集中，便于统一管理</li><li>业务代码更加简洁，不掺杂其他代码影响</li></ul><p>AOP是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定对象上的编程思想就是面向切面编程。将不同方法的同一位置抽象成一个切面对象，对该切面对象进行编程就是AOP。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>创建Maven工程，pom.xml添加</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre></blockquote><ul><li>创建一个计算器接口，创建加减乘除方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;add方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;sub方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;mul方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;div方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用AOP可以进行优化，如何实现AOP？使用动态代理的方式来实现。</p><p>给业务代码找一个代理，打印日志信息的工作交给代理来做，这样的话业务代码只需关注自身业务即可。</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.utils;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Method;<span class="keyword">import</span> java.lang.reflect.Proxy;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  <span class="comment">// 这不是代理类，这个类帮助我们去创建动态代理类</span>  <span class="comment">// 接收委托对象</span>  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 返回代理对象</span>  <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object object)</span> &#123;      <span class="built_in">this</span>.object = object;      <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="built_in">this</span>);  &#125;  <span class="meta">@Override</span>  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;      <span class="comment">// 这里将业务代码和日志代码进行解耦</span>      System.out.println(method.getName() + <span class="string">&quot;方法的参数是&quot;</span> + Arrays.toString(args));      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.object, args);  <span class="comment">// 业务代码</span>      System.out.println(method.getName() + <span class="string">&quot;的结果是&quot;</span> + res);      <span class="keyword">return</span> res;  &#125;&#125;</code></pre><p>以上是通过动态代理实现AOP的过程，不好理解，Spring框架对AOP进行了封装，使用Spring框架可以用面向对象的思想实现AOP。</p><p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring 框架底层会根据切面类以及目标类生成一个代理对象。</p><p>LoggerAspect</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.aop;<span class="keyword">import</span> org.aspectj.lang.JoinPoint;<span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="keyword">import</span> org.aspectj.lang.annotation.Before;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Arrays;<span class="meta">@Aspect</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerAspect</span> &#123;    <span class="comment">// 非业务代码</span>    <span class="meta">@Before(&quot;execution(public int com.study.impl.CalImpl.*(..))&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;        <span class="comment">// 获取方法名</span>        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();        <span class="comment">// 获取参数</span>        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());        System.out.println(name + <span class="string">&quot;方法的参数是&quot;</span> + args);    &#125;&#125;</code></pre><p>LoggerAspect两个注解：</p><ul><li>@Aspect 表示该类是切面类</li><li>@Component 将该类的对象注入到 IOC 容器</li></ul><p>具体方法处添加的注解：</p><ul><li>@Before 表示方法执行的具体位置和时机</li></ul><p>CalImpl 也需要添加 @Component，交给 IOC 管理</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.impl;<span class="keyword">import</span> com.study.utils.Cal;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>Spring.xml 也需要配置 AOP</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 自动扫描 --&gt;</span>        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 使Aspect注解生效 为目标类自动生成代理对象--&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p><code>context:component-scan</code> 将 <code>com.study</code> 包中所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类添加到 IOC 容器中，让 IOC 管理它的对象。</p><p><code>aop:aspectj-autoproxy</code> 让Spring框架结合切面类和目标类自动生成动态代理对象。</p><ul><li>切面：横切关注点被模块化的抽象对象。</li><li>通知：切面对象完成的工作。（非业务代码）</li><li>目标：被通知的对象，即被横切的对象。</li><li>代理：切面、通知、目标混合之后的对象。</li><li>连接点：通知要插入代码的具体位置。</li><li>切点：AOP 通过切点定位到连接点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
