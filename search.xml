<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/12/11/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/11/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架两大核心机制-IOC、AOP"><a href="#Spring框架两大核心机制-IOC、AOP" class="headerlink" title="Spring框架两大核心机制(IOC、AOP)"></a>Spring框架两大核心机制(IOC、AOP)</h2><ul><li>IOC（控制反转）&#x2F; DI （依赖注入）</li><li>AOP （面向切面编程）</li></ul><p>Spring是一个企业级的开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p><p>MVC：Struts2、Spring MVC</p><p>ORMapping：Hibernate、Mybatis、Spring Data</p><p>什么是控制反转：对象由调用者主动new出来。而在Spring中创建对象由IOC容器创建，再推送给调用者，整个流程完成反转，就称作控制反转。</p><h2 id="如何使用IOC"><a href="#如何使用IOC" class="headerlink" title="如何使用IOC"></a>如何使用IOC</h2><ul><li>创建Maven工程，添加pom.xml依赖</li></ul><pre><code class="highlight java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;<span class="number">5.3</span><span class="number">.29</span>&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li><p>创建实体类Student</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;&#125;</code></pre></li><li><p>传统的开发方式  手动new</p></li><li><p>通过IOC创建对象，在XML配置文件中添加需要管理的对象</p></li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><ul><li>从IOC中获取对象</li></ul><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) applicationContext.getBean(<span class="string">&quot;student&quot;</span>);System.out.println(student);</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>通过配置<code>bean</code>标签完成对象的管理</p><ul><li>id : 对象名</li><li>class：对象的模版类（所有交给IOC构建的对象都要有无参构造，因为Spring底层是通过反射机制创建对象的，反射机制调用的是无参构造）</li></ul></li><li><p>成员变量通过<code>property</code> 标签完成赋值</p><ul><li><code>name</code>：成员变量名</li><li><code>value</code>：成员变量的值（基本数据类型，Spring可以直接赋值，其他类型不能通过value赋值）</li><li><code>ref</code>：将IOC中的另外一个bean赋值给当前变量（DI 依赖注入）</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ul><li>读取配置文件，解析XML</li><li>通过反射机制实例化配置文件中所配置的所有bean。</li></ul><h3 id="通过运行时类获取bean"><a href="#通过运行时类获取bean" class="headerlink" title="通过运行时类获取bean"></a>通过运行时类获取bean</h3><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);System.out.println(st);</code></pre><p>这种方式存在问题，配置文件中一个数据类型对象只能有一个实例，因为是通过Class中获取的，Class中数据类型是一样的。</p><h3 id="通过有参构造创建对象"><a href="#通过有参构造创建对象" class="headerlink" title="通过有参构造创建对象"></a>通过有参构造创建对象</h3><ul><li><p>在实体类中创建有参函数</p></li><li><p>配置文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="给bean注入集合"><a href="#给bean注入集合" class="headerlink" title="给bean注入集合"></a>给bean注入集合</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span> &gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="scope作用域"><a href="#scope作用域" class="headerlink" title="scope作用域"></a>scope作用域</h3><p>Spring管理的bean是根据bean来生成的，表示bean的作用域，共4种，默认是singleton。</p><ul><li>singleton：单例，表示通过Spring容器获取的bean是唯一的。</li><li>prototype：原型，表示通过Spring容器获取的bean是不同的。</li><li>request：请求，表示在一次HTTP请求内有效。</li><li>session：会话，表示在一个用户会话内有效。</li></ul><p>request 和 session 只适用于Web项目，大多数情况下，使用单例和原型较多。</p><p>request模式在加载配置文件时就创建了xml中所有的bean。</p><p>prototype模式当业务代码获取IOC容器中的bean时，Spring才去调用无参构造创建对应的bean。</p><h3 id="Spring的继承"><a href="#Spring的继承" class="headerlink" title="Spring的继承"></a>Spring的继承</h3><p>与JAVA中的继承不同，JAVA是类层面的继承，子类可以继承父类的结构和信息；Spring是对象层面的继承，子对象可以继承父对象的属性值。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lala&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;student2&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><ul><li>不同类型的对象某些情况也是可以继承的，需要子对象的属性包含父对象的属性。</li></ul><h3 id="Spring的依赖"><a href="#Spring的依赖" class="headerlink" title="Spring的依赖"></a>Spring的依赖</h3><p>与继承类似，依赖也是描述bean和bean之间的一种关系，配置依赖后，被依赖的bean先创建，再创建依赖的bean。如A依赖于B，则先创建B，再创建A。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.User&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="Spring的-p-命名空间"><a href="#Spring的-p-命名空间" class="headerlink" title="Spring的 p 命名空间"></a>Spring的 p 命名空间</h3><p>p 命名空间是对IOC &#x2F; DI的简化操作，使用 p 命名空间可以更加方便的完成bean的配置以及bean之间的依赖注入。</p><h3 id="Spring的工厂方法"><a href="#Spring的工厂方法" class="headerlink" title="Spring的工厂方法"></a>Spring的工厂方法</h3><p>IOC通过工厂模式创建 bean 的方式有两种：</p><ul><li>静态工厂模式</li><li>实例工厂方法</li></ul><p>静态工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.AllArgsConstructor;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> lombok.NoArgsConstructor;<span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructor</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCarFactory</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Car&gt; carMap;    <span class="keyword">static</span> &#123;        carMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        carMap.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大G&quot;</span>));        carMap.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;宝马&quot;</span>));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> carMap.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java">&lt;!--配置静态工厂创建bean--&gt;    &lt;bean id=<span class="string">&quot;car&quot;</span> class=<span class="string">&quot;com.study.factory.StaticCarFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;        &lt;constructor-arg value=<span class="string">&quot;1&quot;</span>&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>实例工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCarFactory</span> &#123;    <span class="keyword">private</span> Map&lt;Long, Car&gt; map;    <span class="keyword">public</span> <span class="title function_">InstanceCarFactory</span><span class="params">()</span> &#123;        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大奔&quot;</span>));        map.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;沃尔沃&quot;</span>));    &#125;    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> map.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-factory.xml&quot;</span>);<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) applicationContext.getBean(<span class="string">&quot;car2&quot;</span>);System.out.println(car);</code></pre><pre><code class="highlight java">&lt;!--实例工厂创建bean--&gt;&lt;bean id=<span class="string">&quot;carFactory&quot;</span> class=<span class="string">&quot;com.study.factory.InstanceCarFactory&quot;</span>&gt;&lt;/bean&gt;&lt;bean id=<span class="string">&quot;car2&quot;</span> class=<span class="string">&quot;com.study.entity.Car&quot;</span> factory-bean=<span class="string">&quot;carFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;    &lt;constructor-arg value=<span class="string">&quot;2&quot;</span>&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="IOC自动装载（Autowire）"><a href="#IOC自动装载（Autowire）" class="headerlink" title="IOC自动装载（Autowire）"></a>IOC自动装载（Autowire）</h3><p>IOC负责创建对象，DI完成对象的依赖注入，通过配置property标签的 ref 属性完成，同时Spring提供了更加简便的依赖注入方式：自动装载，不需要手动配置property，IOC容器会自动选择 bean 完成注入。</p><p>自动装载有两种方式：</p><ul><li>byName：通过属性名自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><ul><li>byType：通过属性的类型自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><p>byType需要注意，如果同时存在两个及以上的bean时，会抛出异常。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP：Aspect Oriented Programming 面向切面编程</p><p>AOP的优点：</p><ul><li>降低模块的耦合度</li><li>使系统更容易扩展</li><li>更好的代码服用</li><li>非业务代码更加集中，便于统一管理</li><li>业务代码更加简洁，不掺杂其他代码影响</li></ul><p>AOP是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定对象上的编程思想就是面向切面编程。将不同方法的同一位置抽象成一个切面对象，对该切面对象进行编程就是AOP。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>创建Maven工程，pom.xml添加</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre></blockquote><ul><li>创建一个计算器接口，创建加减乘除方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;add方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;sub方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;mul方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;div方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用AOP可以进行优化，如何实现AOP？使用动态代理的方式来实现。</p><p>给业务代码找一个代理，打印日志信息的工作交给代理来做，这样的话业务代码只需关注自身业务即可。</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.utils;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Method;<span class="keyword">import</span> java.lang.reflect.Proxy;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  <span class="comment">// 这不是代理类，这个类帮助我们去创建动态代理类</span>  <span class="comment">// 接收委托对象</span>  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 返回代理对象</span>  <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object object)</span> &#123;      <span class="built_in">this</span>.object = object;      <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="built_in">this</span>);  &#125;  <span class="meta">@Override</span>  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;      <span class="comment">// 这里将业务代码和日志代码进行解耦</span>      System.out.println(method.getName() + <span class="string">&quot;方法的参数是&quot;</span> + Arrays.toString(args));      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.object, args);  <span class="comment">// 业务代码</span>      System.out.println(method.getName() + <span class="string">&quot;的结果是&quot;</span> + res);      <span class="keyword">return</span> res;  &#125;&#125;</code></pre><p>以上是通过动态代理实现AOP的过程，不好理解，Spring框架对AOP进行了封装，使用Spring框架可以用面向对象的思想实现AOP。</p><p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring 框架底层会根据切面类以及目标类生成一个代理对象。</p><p>LoggerAspect</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.aop;<span class="keyword">import</span> org.aspectj.lang.JoinPoint;<span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="keyword">import</span> org.aspectj.lang.annotation.Before;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Arrays;<span class="meta">@Aspect</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerAspect</span> &#123;    <span class="comment">// 非业务代码</span>    <span class="meta">@Before(&quot;execution(public int com.study.impl.CalImpl.*(..))&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;        <span class="comment">// 获取方法名</span>        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();        <span class="comment">// 获取参数</span>        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());        System.out.println(name + <span class="string">&quot;方法的参数是&quot;</span> + args);    &#125;&#125;</code></pre><p>LoggerAspect两个注解：</p><ul><li>@Aspect 表示该类是切面类</li><li>@Component 将该类的对象注入到 IOC 容器</li></ul><p>具体方法处添加的注解：</p><ul><li>@Before 表示方法执行的具体位置和时机</li></ul><p>CalImpl 也需要添加 @Component，交给 IOC 管理</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.impl;<span class="keyword">import</span> com.study.utils.Cal;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>Spring.xml 也需要配置 AOP</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 自动扫描 --&gt;</span>        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 使Aspect注解生效 为目标类自动生成代理对象--&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p><code>context:component-scan</code> 将 <code>com.study</code> 包中所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类添加到 IOC 容器中，让 IOC 管理它的对象。</p><p><code>aop:aspectj-autoproxy</code> 让Spring框架结合切面类和目标类自动生成动态代理对象。</p><ul><li>切面：横切关注点被模块化的抽象对象。</li><li>通知：切面对象完成的工作。（非业务代码）</li><li>目标：被通知的对象，即被横切的对象。</li><li>代理：切面、通知、目标混合之后的对象。</li><li>连接点：通知要插入代码的具体位置。</li><li>切点：AOP 通过切点定位到连接点。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
