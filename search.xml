<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2023/12/01/test/"/>
      <url>/2023/12/01/test/</url>
      
        <content type="html"><![CDATA[<p>时空数据预测分支一：交通流量预测</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 时空数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/11/30/hello-world/"/>
      <url>/2023/11/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E9%9B%86%E5%92%8C/"/>
      <url>/2023/11/10/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%AD%90%E9%9B%86%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="title-子集和"><a href="#title-子集和" class="headerlink" title="title:子集和"></a>title:子集和</h1><h1 id="adssad子集和问题SUBSET-SUM"><a href="#adssad子集和问题SUBSET-SUM" class="headerlink" title="adssad子集和问题SUBSET-SUM"></a>adssad子集和问题SUBSET-SUM</h1><p>给定整数集合S和一个整数t，判定是否存在S的一个子集S′⊆S，使得S′中整数的和为t。</p><p>例如，若S＝ ｛1，4，16，64，256，1040，1041，1093，1284，1344｝且t＝3754，则子集S′＝ ｛1，16，64，256，1040，1093，1284｝是它的一个解。</p><p> 动态规划法避免了重复求解子问题的步骤，是一种空间换时间的方式。</p><p>我们先来简单介绍动态规划的思想，比如A &#x3D; {1, 2, 5, 9}中是否存在sum &#x3D; 6的子集，可以求解{2, 5, 9}这个集合中是否有sum &#x3D; 5的子集。总之，动态规划就是将问题划分为小问题。动态规划的难点是如何列出递推关系式，也就是如何填表。</p><p>动态规划与递归的区别：对于此题，我们介绍过递归的解法，那为何还衍生出动态规划呢？递归需要重复求解子问题，也就是程序计算当前值时需要把之前所有的子问题全部求解一遍，而其中的子问题我们在算前一个值时就已经求解过了，程序没有将这些子问题的值保存下来，而动态规划使用数组就是为了保存计算过的值而出现。</p><p>为了解决这个问题，我们构建一个二维数组subset，其中subset[i] [j]表示前i个元素的子集是否存在和为j，我们将subset的第一列初始化为True，因为空集的和总是0。动态规划最重要的列出递推关系式，这里给出这道题的公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subset[i][j] = subset[i-1][j] or subset[i-1][j - nums[i-1]]</span><br></pre></td></tr></table></figure><p>画个表格来说明此公式：</p><table><thead><tr><th align="left"></th><th>0</th><th>1</th><th>2</th><th align="left">3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td align="left">{}</td><td>1</td><td>0</td><td>0</td><td align="left">0</td><td>0</td><td>0</td><td>0</td></tr><tr><td align="left">{1}</td><td>1</td><td>1</td><td>0</td><td align="left">0</td><td>0</td><td>0</td><td>0</td></tr><tr><td align="left">{1, 4}</td><td>1</td><td>1</td><td>0</td><td align="left">0</td><td>1</td><td>1</td><td>0</td></tr><tr><td align="left">{1, 4, 5}</td><td>1</td><td>1</td><td>0</td><td align="left">0</td><td>1</td><td>1</td><td>1</td></tr><tr><td align="left">{1, 4, 5, 9}</td><td>1</td><td>1</td><td>0</td><td align="left">0</td><td>1</td><td>1</td><td>1</td></tr></tbody></table><p>![image-20231110160554379](&#x2F;Users&#x2F;lei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110160554379.png)</p><p> 拿上图中红色圈举个例子，{1, 4}中的4为nums[i-1]</p><ol><li>不包含当前元素，即上一格的结果为0</li><li>包含当前元素，需要检查subset[1] [5-4]的值 &#x3D; 1，说明如果包含当前元素后，结果就是1，因此这个格子被标注为1</li></ol><p>最后运行下题目的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_subset_with_sum</span>(<span class="params">nums, target_sum</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个二维数组，subset[i][j]表示是否存在子集的和等于j，其中子集包含前i个元素</span></span><br><span class="line">    subset = [[<span class="literal">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target_sum + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化第一列，表示空集的和为0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">        subset[i][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录路径信息的数组，用于还原子集</span></span><br><span class="line">    path = [[<span class="literal">None</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(target_sum + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 填充二维数组</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, target_sum + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 如果当前数字大于目标和，直接继承上一行的结果</span></span><br><span class="line">            <span class="keyword">if</span> nums[i - <span class="number">1</span>] &gt; j:</span><br><span class="line">                subset[i][j] = subset[i - <span class="number">1</span>][j]</span><br><span class="line">                path[i][j] = (i-<span class="number">1</span>, j)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则，考虑包含或不包含当前数字的两种情况</span></span><br><span class="line">                subset[i][j] = subset[i - <span class="number">1</span>][j] <span class="keyword">or</span> subset[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">                path[i][j] = (i-<span class="number">1</span>, j) <span class="keyword">if</span> subset[i - <span class="number">1</span>][j] <span class="keyword">else</span> (i - <span class="number">1</span>, j - nums[i - <span class="number">1</span>])</span><br><span class="line">        </span><br><span class="line">    subset_elements = []</span><br><span class="line">    i, j = n, target_sum <span class="comment"># 从右下角开始</span></span><br><span class="line">    <span class="keyword">while</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> j &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> path[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            i, j = path[i][j]</span><br><span class="line">            <span class="keyword">if</span> i &gt;= <span class="number">0</span> <span class="keyword">and</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">                subset_elements.append(nums[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回最终结果</span></span><br><span class="line">    <span class="comment"># return subset[n][target_sum]</span></span><br><span class="line">    <span class="keyword">return</span> subset_elements</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">16</span>, <span class="number">64</span>, <span class="number">256</span>, <span class="number">1040</span>, <span class="number">1041</span>, <span class="number">1093</span>, <span class="number">1284</span>, <span class="number">1344</span>]</span><br><span class="line">target_sum = <span class="number">3754</span></span><br><span class="line"></span><br><span class="line">result = has_subset_with_sum(nums, target_sum)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>这是result的结果![image-20231110165004397](&#x2F;Users&#x2F;lei&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20231110165004397.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/05/%E4%BA%A4%E9%80%9A%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/"/>
      <url>/2023/11/05/%E4%BA%A4%E9%80%9A%E6%B5%81%E9%87%8F%E9%A2%84%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="引言-交通流预测-："><a href="#引言-交通流预测-：" class="headerlink" title="引言(交通流预测)："></a>引言(交通流预测)：</h2><p>wqe交通流预测是一项基础的智能交通任务，它需要预测道路地图中所有交互过程中的交通流。交通流预测包含了一个序列预测任务，路网的流量可以看作是一组节点的时间序列预测任务。因此，由于空间维度的复杂依赖关系，它既需要空间级建模，也需要时间级预测，比时间序列预测更具挑战性。在空间上，附近道路的交通状况是动态相互影响(或相互依赖)的。从时间上看，由于天气、高峰时间、周末和节假日等多种因素，交通状况呈现出难以捉摸的模式。交通指标与路网中的结点密切相关，换句话说，感应到的交通速度和流量只适用于该特定路段。因此，将交通系统中的相关性建模为图形更有意义，最近的研究主要集中在时空图形建模上。交通流量预测是基于道路距离的空间依赖图，是智能交通系统中一个基本而又重要的应用。最近的研究主要集中在时空图形建模上。时空模型利用空间维度和时间维度对数据进行建模，其优异的性能受到越来越多的关注。</p><p>下面呈现的交通流预测中的一个经典模型：Adaptive Graph Convolutional Recurrent Network for Traffic Forecasting（AGCRN），这篇文章抛弃了传统使用预定义图的方式，作者认为认为学习节点特定模式对于流量预测至关重要，而预定义图是可以避免的。</p><p>现有的基于gcn的方法需要通过相似性或距离度量预先定义一个相互连接图，以捕获空间相关性。这进一步需要大量的领域知识，并且对图的质量很敏感。以这种方式生成的图形通常是直观的，不完整的，并且不直接针对预测任务;它们可能包含偏见，并且在没有适当知识的情况下不能适应领域。因为交通流量随着时空动态变化，仅仅使用预定义的图无法捕捉到动态流量交互，从而无法对交通流进行准确的预测。这篇文章通过随机初始化一个可学习结点$E_A$ ，通过$E_A \cdot E_A^T$ 去学习每对结点间的空间依赖性。</p><p>$\boldsymbol{D^{-\frac12}AD^{-\frac12}}&#x3D;softmax(ReLU(\boldsymbol{E_A}\cdot\boldsymbol{E_A^T}))$</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>此外，虽然现有的方法能够有效地模拟时空相关性，但忽略了交通预测问题的两个内在性质，从而阻碍了现有方法成为更高效和准确的交通状况预测器。现有的交通预测方法主要关注于时空相关性建模，忽略了交通预测问题的两个内在特性。首先，上述方法走向另一个极端，它们直接从时间序列模式中学习内在&#x2F;隐式图结构，而忽略了利用从领域专家知识中定义的先验时间序列关系的可能性。虽然显示图虽然无法表示完整的图关系，但它包含空间关系，在网络训练的前期对网络学习是有一定帮助，因此我们也不能丢弃先验知识。此外，不同预测任务的复杂性在不同的空间(例如，郊区与市中心)和时间(例如，高峰时段与非高峰时段)上是不均匀分布的。市区的交通流值比郊区的交通流值更高，模式更复杂。同时，对于某条特定道路，高峰时段流量波动频繁，较非高峰时段流量难以预测，呈现出稳定、简单的模式。而现有的方法为所有任务分配相等的计算负荷，而不考虑其时空复杂性。然而上述方法为所有任务分配相等的计算负荷，而不考虑其时空复杂性。因此，对于复杂的任务，由于计算量有限而忽略了重要的细节，而对于简单的任务，则浪费了过多的计算负荷。</p><h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>既然显示图无法表示完整的流量趋势，不能与数据本身相关联，针对这个问题，可以通过结点嵌入生成可学习图，去训练这些结点并作为网络的参数。虽然显示图虽然无法表示完整的图关系，但它包含空间关系，在网络训练的前期对网络学习是有一定帮助，因此我们也不能丢弃先验知识。为了解决这个问题，针对简化图卷积计算的切比雪夫多项式，提出一种切比雪夫混合多项式，旨在结合先验知识显式图和结点嵌入的隐式图进行融合。混合运算原本是作为一种数据增强方法来更好地约束特征空间的边界，我们在这里运用了“混合”的思想来平衡两种相关性的组成，并约束相邻矩阵的边界。此外，与传统的从beta分布中抽取权重系数不同，我们通过自注意力模块计算权重，这种方法可以动态地为长距离节点之间的高相似性分配更高的权重，从而进一步改进语义挖掘关系。总之，该模型包含一个拉普拉斯矩阵混合模块，可以自动发现隐式时间序列模式，并以动态凸方式融合显式图和隐式图，这种方式提高了图的可解释性，也有助于更有效地捕获复杂的相关性。</p><p>$\boldsymbol{M}^{(m)}(\boldsymbol{X})&#x3D;f_a(\tilde{\boldsymbol{A}}^{(0)}(\boldsymbol{X});\boldsymbol{\theta}_a)+f_a(\tilde{\boldsymbol{A}}^{(l)}(\boldsymbol{X});\boldsymbol{\theta}_a)$</p><p>$f_{a}$ 代表自注意力机制，θ代表注意力参数，利用LM3模块，显式图和学习隐式图的动态凸组合，仔细捕捉两种时间序列的相关性。</p><p>针对第二个问题，我们需要一个动态的、自适应的计算模型来解决上述问题。由于交通流量设计时间、空间依赖关系，我们可以采用Transformer编码器-解码器架构去处理。在每个编码器中维护一个空间自适应transformer去捕获空间依赖性和一个时间自适应transformer去捕获时间依赖性，然后将其纠缠去捕获时空相关性。transformer由多头注意力、残差设计层归一化和过渡函数组成。空间自适应transformer具有与时间自适应transformer相似的结构，但在捕捉交通传感器之间的空间依赖关系方面有两个不同之处。空间自适应变压器和时间自适应变压器分别在各自的模型中捕获空间依赖关系和时间模式。然而，由于交通预测问题的复杂性，空间依赖关系和时间模式往往纠缠在一起，表现出复杂的时空相关性。例如，一条市中心道路的高峰时间将显示出市中心区域在空间上和高峰时间上的共同模式。因此，纠缠模块做的是将经过空间transformer和时间transformer的各自特征去进行组合。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
