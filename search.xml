<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>docker</title>
      <link href="/2024/03/19/Docker/"/>
      <url>/2024/03/19/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-和-虚拟机的区别"><a href="#Docker-和-虚拟机的区别" class="headerlink" title="Docker 和 虚拟机的区别"></a>Docker 和 虚拟机的区别</h2><p>虚拟机需要启动完整的系统，内核、工具等</p><p>Docker 是容器的一种实现方式，镜像是一个模板，容器是模板的实例。</p><p><img src="/2024/03/19/Docker/image-20240319140809181.png" alt="image-20240319140809181"></p><p>查看本地镜像：docker images</p><p>查看正在运行的容器：docker ps</p><p>运行一个容器：docker run –name some-nginx -d -p 8080:80 nginx:1.22</p><p>查看容器的信息：docker inspect 容器名</p><pre><code class="highlight plaintext">将容器连接到网络：docker network (dis)connect 网络名 容器名 之后访问容器 docker run -it --rm mysql:5.7 mysql -h172.17.0.2 -uroot -p=》 docker run -it --rm --network 网络名 mysql:5.7 mysql -hsome-mysql -uroot -p</code></pre><h2 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h2><p><img src="/2024/03/19/Docker/image-20240319153237440.png" alt="image-20240319153237440"></p><p>创建一个卷：docker volume create 卷名</p><h2 id="Docker-部署前后端分离项目-若依"><a href="#Docker-部署前后端分离项目-若依" class="headerlink" title="Docker 部署前后端分离项目-若依"></a>Docker 部署前后端分离项目-若依</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1、创建 mysql 容器</p><pre><code class="highlight linux">docker run -d \  --name mysql \  -p 3307:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=1314 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \   # 映射路径  --network ruoyi    \  mysql:8.0.19</code></pre><p>在启动 mysql 容器后，运行中内存会很大，需要在进入容器内为其配置文件中设置参数：</p><p>&#x2F;etc&#x2F;mysql&#x2F;conf.d 目录执行 vim docker.cnf</p><pre><code class="highlight plaintext">performance_schema_max_table_instances=400  table_definition_cache=400    performance_schema=off    table_open_cache=64    innodb_buffer_pool_chunk_size=64M    innodb_buffer_pool_size=64M</code></pre><p>2、创建 redis 容器</p><pre><code class="highlight linux">docker run  \--name redis \-p 6380:6379 \-v /root/redis/conf:/usr/local/etc/redis \-v /root/redis/data:/data \-d \--network ruoyi   \redis:6.0.8 \redis-server /usr/local/etc/redis/redis.conf</code></pre><p>3、创建 nginx 容器</p><pre><code class="highlight linux">docker run -d \  --name nginx \  -p 81:80 \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \  --network ruoyi  \  nginx:1.22</code></pre><p>由于 nginx 的配置文件容器出错，我们可以先创建一个 nginx 容器复制其配置文件，再删除它。</p><pre><code class="highlight plaintext"># 复制配置docker cp nginx:/etc/nginx/nginx.conf /root/nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d /root/nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html /root/nginx/</code></pre><p>4、部署后端 Dokcerfile</p><pre><code class="highlight linux"># 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 挂载目录VOLUME /home/ruoyi# 创建目录RUN mkdir -p /home/ruoyi# 指定路径WORKDIR /home/ruoyi# 拷贝jar包COPY /root/ruoyi-admin.jar /home/ruoyi/app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</code></pre><p>5、创建项目镜像</p><pre><code class="highlight linux">docker build -t ruoyi:1.0 -f /root/Dockerfile .</code></pre><p>6、创建项目容器</p><pre><code class="highlight linux">docker run -d \--name ruoyi  \-p 8081:8081  \-v /root/ruoyi/uploadPath:/home/ruoyi/uploadPath \--network \ruoyi  \ruoyi:1.0</code></pre><p>7、最后运行容器</p><pre><code class="highlight plaintext">docker run -d \-p 81:80 \-p 443:443 \--name nginx \--restart=always \--network ruoyi \-e TZ=&quot;Asia/Shanghai&quot; \-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /root/nginx/conf/conf.d:/etc/nginx/conf.d \-v /root/nginx:/var/log/nginx \-v /root/nginx/html:/usr/share/nginx/html \-v /root/nginx/cert:/etc/nginx/cert \nginx:1.22</code></pre><p>现在可以通过 服务器id : nginx端口 访问界面了！</p><p><img src="/2024/03/19/Docker/image-20240322095418176.png" alt="image-20240322095418176"></p><p>其中容易出错的点是配置 nginx 时，其配置文件对于后端的映射。</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网小记</title>
      <link href="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><p>TCP：面向连接、可靠、面向字节流</p><p>UDP：无连接、不可靠、面向报文</p><p>TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多</p><p>应用场景：</p><p>TCP：FTP 文件传输、HTTP &#x2F; HTTPS</p><p>UDP：实时应用、游戏</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/image-20240316164317006.png" alt="image-20240316164317006"></p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong>。</p><p><strong>第一次握手：</strong>客户端首先也创建传输运输块，向服务器发出连接请求报文，将标志位 SYN 置为 1，选择一个初始序列号 seq&#x3D;x。SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。</p><p><strong>第二次握手：</strong>服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态。</p><p>第三次握手：TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立。</p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传代码</title>
      <link href="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><blockquote><p>git log：查看提交记录（作者、邮箱）</p><p>git status：查看哪些文件被提交</p><p>git ls-files：查看暂存区的内容 默认是mixed，也就是回退时保留工作区文件，但移除暂存区文件</p><p>git reflog：查看历史记录</p><p>git reset 回退分支</p><p>git diff：比较工作区和暂存区的差别  –cached 比较暂存区和版本库的差异</p><p>git rm：将文件从工作区和暂存区都删除    –cached：把文件从暂存区删除，但保留在工作区</p><p>git checkout – filename    从暂存区恢复文件到工作区</p><p>git commit -am “”  一个命令同时添加到暂存区和提交到本地仓库</p></blockquote><p>.gitignore：忽略加入暂存区的文件</p><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><pre><code class="highlight plaintext">cd .sshssh-keygen -t rsa -b 4096</code></pre><p>git remote -v：查看本地仓库所对应的远程仓库的别名和地址</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建分支：git branch dev</p><p>切换分支：git switch dev</p><p>合并分支：git merge dev 把 dev 分支合并到 main 分支中</p><p><img src="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/image-20240318164945891.png" alt="image-20240318164945891"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/12/JVM%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312160432882.png" alt="image-20240312160432882"></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>作用：加载类的信息到JVM中。当 Java 程序需要使用某个类时，类加载子系统负责找到对应的.class文件，并将其加载到JVM的方法区中。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>加载：将.class文件的二进制字节流读入内存。将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</p><p>验证：确保该类的字节码文件中所包含的信息是否符合当前虚拟机的要求。</p><p>准备：为静态变量分配内存，并设置一个初始值。除了被final修饰的类变量，该类型会在编译期就已经被分配并确定。</p><p>解析</p><p>初始化：为静态变量、静态代码块进行真正初始化</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 在尝试加载一个类时，系统首先判断这个类是否被加载过，已经加载的类直接返回，否则才会尝试加载。类加载器会先委托给它的父加载器去尝试加载这个类，一直到达顶层的类（Bootstrap）只有在父加载器无法加载该类时（找不到对应的类），子加载器才会尝试去加载。</p><h2 id="native、方法区"><a href="#native、方法区" class="headerlink" title="native、方法区"></a>native、方法区</h2><p>方法区：存放已加载的类的信息，常量、静态变量 等。方法区是线程共享的内存区域，它在JVM启动的时候被创建，并且随着类的加载而动态扩展。方法区中包含着常量池。native 关键字的方法会调用底层 C 语言的库，会进入本地方法库，进而调用本地方法接口，</p><h2 id="JVM-虚拟机栈"><a href="#JVM-虚拟机栈" class="headerlink" title="JVM 虚拟机栈"></a>JVM 虚拟机栈</h2><p>每个Java虚拟机线程都有一个私有的Java栈，与线程同时创建。Java栈中保存着帧信息，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>局部变量表、操作数栈、动态链接、方法返回地址。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312192522896.png" alt="image-20240312192522896"></p><p>GC 垃圾回收，主要是在伊甸园区和养老区</p><ul><li><p>新生代：诞生、成长、死亡的地方。分为伊甸园区、From、To 幸存区（0,1）。</p></li><li><p>老年代</p></li></ul><p>大多数情况下，对象在新生代中 Eden 区分配。当Eden区满了之后，会触发一次Minor GC（也就是轻GC）。新生代中的存活对象是从Eden区和当前正在使用的一个Survivor区（我们可以称之为From区）复制到另一个Survivor区（我们可以称之为To区）。复制过程完成后，Eden区和From区将被清空。如果Survivor区容不下Eden区的所有存活对象，那么部分或者全部存活对象将直接被晋升到老年代。</p><p><strong>由于这个互换，保证了在每次垃圾收集结束后，总有一个Survivor区（to）是空的，这是为了下次垃圾收集时有空间来存放从Eden和另一个Survivor（from）区复制过来的存活对象。</strong></p><p>在survivor中，相同年龄的所有对象大小大于survivor的一半空间。年龄大于或等于该年龄的对象可以进入老年代。</p><p>在 jdk8 后，永远存储区改了个名字（元空间）：这个区域在本地内存，存储的是 java 运行时的一些环境或类信息。这个区域不存在垃圾回收。方法区在元空间</p><p>非堆内存：方法区、元空间</p><ul><li>JDK 1.8 之后，无永久代，替代为元空间，不存在于 JVM，使用的是本地内存。</li></ul><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312200859515.png" alt="image-20240312200859515"></p><h2 id="GC：垃圾回收"><a href="#GC：垃圾回收" class="headerlink" title="GC：垃圾回收"></a>GC：垃圾回收</h2><p>GC 的算法有哪些？标记清楚法、引用计数法</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。问题：效率不高、标记清楚后会产生大量内存碎片。</li><li>复制算法：按照容量把堆内存划分二个大小相等的内存区域（From、To），当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</li><li>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</li><li>分代收集算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 有三种方式初始化：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;    Object[] a = c.toArray();    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;            elementData = a;        &#125; <span class="keyword">else</span> &#123;            elementData = Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// replace with empty array.</span>        elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><ul><li>无参方式创建时，初始化为空数组，等到第一个元素 add 时，数组才扩容到默认值 10。</li></ul><p>先从 add 方法入手：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>第一次 add 时，size 为 0，我们进入 ensureCapacityInternal 方法：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>在 calculateCapacity 这个方法中，如果当前数组为空（第一次 add 时），就返回默认容量和最小容量中的较大值作为所需容量。否则直接返回 minCapacity。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="keyword">return</span> minCapacity;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    modCount++;    <span class="comment">// overflow-conscious code</span>    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)        grow(minCapacity);&#125;</code></pre><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    <span class="comment">// overflow-conscious code</span>    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)        newCapacity = minCapacity;    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>到这里为止，我们添加第一个元素，数组容量由 空数组 扩容到容量为 10 的数组。如何扩容的呢？ 核心实现在 grow 方法中，此时 minCapacity &#x3D; 10， newCapacity &#x3D; 0，第一个 if 满足条件，newCapacity 赋值为 10。数组被复制到一个扩容后的新数组。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;  <span class="comment">// 申请一个新的数组</span>    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,                     Math.min(original.length, newLength));    <span class="keyword">return</span> copy;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList扩容机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传图片</title>
      <link href="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>今天在使用 typora 写好笔记后，上传至 hexo 服务器，发现图片还是读取的本地路径。通过参考其他人的经验找到一种解决方法。</p><p>1、在 typora 设置中勾选如下选项，作用是图片使用相对路径。</p><p><img src="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20240106172757156.png" alt="image-20240106172757156"></p><p>2、安装插件即可，不需要再设置<code>图片根目录</code>。</p><pre><code class="highlight javascript">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></code></pre><p>至此在浏览器就可以正常显示图片了。（ps: 前提是根目录下的_config.yml文件中的post_asset_folder字段已经设置为true）</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
