<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redisson分布式锁</title>
      <link href="/2024/05/09/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2024/05/09/Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="使用Redis自带数据结构实现分布式锁和-Redisson-分布式锁"><a href="#使用Redis自带数据结构实现分布式锁和-Redisson-分布式锁" class="headerlink" title="使用Redis自带数据结构实现分布式锁和 Redisson 分布式锁"></a>使用Redis自带数据结构实现分布式锁和 Redisson 分布式锁</h2><blockquote><p>SET NX EX</p></blockquote><p>redis自带的数据结构 set 可以实现简易的分布式锁。但有如下几个缺陷：</p><p>1、无法实现可重试。当线程无法获取锁时就立即返回，不会重试。</p><p>2、无法实现可重入。</p><p>3、无法超时续约。只能通过 EX 设置获取锁后自动过期时间，但这并不安全，当某个业务执行的时间较长时，如果锁自动释放了，存在安全隐患。</p><blockquote><p>Redisson 如何解决这些缺陷的？</p></blockquote><ul><li>可重入：利用 hash 结构记录锁标识和重试次数。</li><li>可重试：利用<code>发布/订阅</code>机制实现等待、唤醒，锁的重试。</li><li>超时续约：利用 watchDog，当锁还被线程占用时，自动更新锁时间以此避免自动释放锁。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java动态代理实现</title>
      <link href="/2024/04/30/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/04/30/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>静态代理主要由一个公共接口，一个具体的类，一个代理类组成。代理类持有具体类的实例。代理的是具体类的实例方法。</p><p>公共接口：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;    <span class="comment">// 上交班费</span>    <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span>;&#125;</code></pre><p>具体类：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;    <span class="keyword">private</span> String name;    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name)</span> &#123;        <span class="built_in">this</span>.name = name;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;        System.out.println(name + <span class="string">&quot;上交班费50元&quot;</span>);    &#125;&#125;</code></pre><p>代理类：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;    Student stu;    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;        <span class="comment">// 只代理学生对象</span>        <span class="keyword">if</span> (stu.getClass() == Student.class) &#123;            <span class="built_in">this</span>.stu = (Student) stu;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;        stu.giveMoney();    &#125;&#125;</code></pre><blockquote><p>为什么要用代理类去调用具体类的方法？引入这种间接性的好处？</p><p>不直接调用实际对象的方法，我们在代理过程中就可以加上一些其他用途。比如，在上交班费前记录下。</p></blockquote><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentsProxy</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;    Student stu;    <span class="keyword">public</span> <span class="title function_">StudentsProxy</span><span class="params">(Person stu)</span> &#123;        <span class="comment">// 只代理学生对象</span>        <span class="keyword">if</span> (stu.getClass() == Student.class) &#123;            <span class="built_in">this</span>.stu = (Student) stu;        &#125;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">giveMoney</span><span class="params">()</span> &#123;        System.out.println(stu.getName() + <span class="string">&quot;学习上有很大进步&quot;</span>);        stu.giveMoney();    &#125;&#125;</code></pre><p>然而静态定理只实现了对特定类的代理，如这里只实现了对<code>Student</code>类的代理，如果还有其他的类呢，都要写一个代理类？而且在多个实现类中如果都要记录下日志，对每个实现类都要多写个日志代码，显得很冗余，且业务逻辑与日志没有解耦，于是动态代理就是解决这个问题。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>在java的java.lang.reflect包下提供了一个Proxy类和一个InvocationHandler接口，通过这个类和这个接口可以生成JDK动态代理类和动态代理对象。</p><p>接口与具体类与静态代理相同</p><p>代理类</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StuInvocationHandler</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;    <span class="comment">// 代理对象</span>    T target;    <span class="keyword">public</span> <span class="title function_">StuInvocationHandler</span><span class="params">(T target)</span> &#123;        <span class="built_in">this</span>.target = target;    &#125;    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span>&#123;        <span class="comment">//创建代理对象</span>        <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[]&#123;clazz&#125;, <span class="built_in">this</span>);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;        System.out.println(<span class="string">&quot;代理执行&quot;</span> +method.getName() + <span class="string">&quot;方法&quot;</span>);        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>测试</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;        <span class="type">Student</span> <span class="variable">wdcp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;wdcp&quot;</span>);        StuInvocationHandler&lt;Person&gt; stuInvocationHandler = <span class="keyword">new</span> <span class="title class_">StuInvocationHandler</span>&lt;Person&gt;(wdcp);        <span class="comment">// 创建代理对象</span>        <span class="type">Person</span> <span class="variable">stuProxy</span> <span class="operator">=</span> stuInvocationHandler.getProxy(Person.class);        stuProxy.giveMoney();    &#125;&#125;</code></pre><p>如此一来，就可以解决上面静态代理的两个问题：</p><p>1、不必为每个实现类编写一个代理类，通过泛型动态创建具体类的代理对象。</p><p>2、当多个实现类中都需要添加日志或者其他信息时，不需要在每个实现类中添加，在invoke方法中添加一条后即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BIO、NIO</title>
      <link href="/2024/04/30/Netty/"/>
      <url>/2024/04/30/Netty/</url>
      
        <content type="html"><![CDATA[<h2 id="RPC框架整个的流程"><a href="#RPC框架整个的流程" class="headerlink" title="RPC框架整个的流程"></a>RPC框架整个的流程</h2><p>1、服务端扫描目录，查找是否有自定义注解，有的话就知道是一个服务，会把服务实现类与接口名放入一个Map，把接口名与服务端地址注册到注册中心。之后，服务端初始化ChannelPipeline，定义各种监听事件。</p><p>2、客户端启动，通过反向代理调用接口的方法，先会进行服务发现，从Nacos获取对应服务的服务端地址，再与服务端进行连接并初始化客户端，就准备发送消息了，同时客户端会做一个负载均衡，如果当前这个接口名在多个服务端有实现， 就通过负载均衡算法选一个进行发送。</p><p>3、服务端收到消息后，到自己的本地注册表中查找对应接口的实现类，通过反射执行对应的方法，将结果返回。</p><blockquote><p>如果发送到服务端，服务端发生了异常怎么处理</p></blockquote><h2 id="NIO比BIO效率高的原因"><a href="#NIO比BIO效率高的原因" class="headerlink" title="NIO比BIO效率高的原因"></a>NIO比BIO效率高的原因</h2><ul><li>面向流和面向缓存区</li><li>阻塞IO和非堵塞IO</li><li>零拷贝</li></ul><h2 id="面向流与面向缓冲区"><a href="#面向流与面向缓冲区" class="headerlink" title="面向流与面向缓冲区"></a>面向流与面向缓冲区</h2><p>BIO是面向流的，NIO是面向缓冲区的。</p><h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>最传统的IO模型，也被称为同步堵塞IO。客户端每发出一个连接，服务端就需要启动一个线程进行处理，在整个IO期间会被堵塞直到拿到结果。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p><img src="/2024/04/30/Netty/image-20240430154933821.png" alt="image-20240430154933821"></p><p>称为同步非堵塞IO，基于事件驱动来处理IO。NIO由三部分组成：selector、channel、buffer。</p><p>流程如下：当客户端发出一个连接，服务端将其注册到selector，也就是channel，这个连接是非堵塞的，当没有数据读写时不会占用资源。Selector会不断轮询注册在其上的所有channel，如果某个channel发生了注册时指定的事件，那么selector就让服务端程序处理这个事件。</p><p>数据的读写会在Buffer中，这可以减少上下文切换的开销。</p><blockquote><p>为什么NIO中一个线程可以管理多个Channel？</p></blockquote><h2 id="堵塞IO与非堵塞IO"><a href="#堵塞IO与非堵塞IO" class="headerlink" title="堵塞IO与非堵塞IO"></a>堵塞IO与非堵塞IO</h2><p>BIO的各种流是堵塞的。当一个线程调用read()或write()时，该线程会被堵塞，直到有数据读入或数据写入。而NIO的非堵塞是指当通道中没有东西可读或不可写，读写函数会马上返回，不会堵塞，这个线程就可以去做其他事情。线程将非堵塞的IO空闲时间用在其他通道执行IO操作，这就是为什么一个线程可以管理多个通道，即IO复用的原理。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><p>零拷贝是指避免在用户态与内核态之间来回拷贝数据。</p><h2 id="select-poll-epoll"><a href="#select-poll-epoll" class="headerlink" title="select&#x2F;poll&#x2F;epoll"></a>select&#x2F;poll&#x2F;epoll</h2><p>这三个是用来实现<code>多路复用</code>的。也就是线程不会被任何一个连接堵塞，且任何一个连接有数据时要通知 select&#x2F;poll&#x2F;epoll 线程。</p><ul><li><p>select采取主动轮询的方式，每次调用时需要向内核传递所有的socket文件描述符，当某个fd有消息时，会把fd集合全部拷贝到用户态进行遍历，因为用户态并不知道哪些文件描述符要进行处理。</p></li><li><p>epoll：采用事件回调机制。会在cache中创建一颗红黑树和一个就绪链表。红黑树存储所有注册的socket的文件描述符。当文件描述符有读写操作时，就将这个fd放入就绪链表。epoll只需要观察就绪链表中有无数据即可。有的话就传递到用户态，并且这里不需要像select那样进行拷贝，因为epoll使用了mmap共享用户态和内核态内存。</p></li></ul><p>ET &amp; LT：</p><p>ET：边缘触发，</p><p>LT：水平触发，epoll 遍历 ready_list 的时候，会把 socket 从 ready_list 里面移除，但如果这个 socket 仍然有数据未读取，又会被加入到 ready_list 中。</p><h2 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h2><p>基于事件驱动。</p><ul><li>单Reactor单线程模型：I&#x2F;O操作和非I&#x2F;O操作都在一个线程上处理。当有多个请求时会延迟响应速度，因此应该把非I&#x2F;O的操作从线程中卸载。</li><li>单Reactor多线程模型：与上面不同的是，添加了个工作者线程池，将非I&#x2F;O操作从Reactor线程中转移到线程池中处理。</li><li>主从多线程模型：将“接受客户端的连接请求”和“与该客户端的通信”分在了两个Reactor线程来完成。主Reactor完成与客户端的连接请求，但它不负责与客户端通信。它把建立好的连接转交给从Reactor完成与客户端的通信。还可以通过实现subReactor线程池来将海量的连接分发给多个subReactor线程。</li></ul><h2 id="Netty重要的组件"><a href="#Netty重要的组件" class="headerlink" title="Netty重要的组件"></a>Netty重要的组件</h2><ul><li>Channel：Netty网络操作类，包括基本的 I&#x2F;O 操作，如 bind、connect、read、write 等。</li><li>EventLoop：事件调度，通过Reactor 线程模型将事件交给handler。</li><li>ChannelHandler：处理各种事件。</li><li><strong>ChannelPipeline</strong>：为ChannelHandler提供了链式容器，组装各种 ChannelHandler。</li><li>ChannelFuture：Netty 框架中所有的 I&#x2F;O 操作都为异步的，因此我们需要 ChannelFuture 的 addListener()注册一个 ChannelFutureListener 监听事件，当操作执行成功或者失败时，监听就会自动触发返回结果。</li></ul><h2 id="为什么需要注册中心"><a href="#为什么需要注册中心" class="headerlink" title="为什么需要注册中心"></a>为什么需要注册中心</h2><p>1、没有注册中心，客户端是通过固定的服务端地址进行访问的，如果服务端换了地址或服务挂了，客户端就无法访问了。而服务中心可以保存服务提供者的信息，每个服务提供者向注册中心注册自己的服务。这样客户端就可以直接向注册中心调用服务，如果拿到的服务挂了，还可以重新调用服务。</p><p>2、当服务端这边的服务更新了，通过注册中心可以及时通知给客户端，客户端就会重新订阅服务，得到最新的服务。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2024/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2024/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h2><p>TCP特性：</p><ul><li>面向连接，传输数据前要先建立连接。</li><li>一对一的两点服务，保证可靠连接</li><li>因为要建立连接，对系统资源的消耗大。</li><li>保证数据的完整性和有序</li></ul><p>应用：HTTP、FTP、SMTP 对应 Web浏览器、文件传输、邮件传输</p><p>UDP特性：</p><ul><li>无连接。</li><li>支持一对一、一对多、多对多。</li></ul><p>应用：</p><h2 id="TCP如何保证可靠性的"><a href="#TCP如何保证可靠性的" class="headerlink" title="TCP如何保证可靠性的"></a>TCP如何保证可靠性的</h2><ol><li>序列号和确认应答。TCP为每个字节分配一个序列号，按序列化将数据分为多个报文段。接受方通过确认应答（ACK）来确认已收到。</li><li>超时重传。TCP发送数据后启动一个定时器，如果超过时间没有得到接收方的确认，则重发该数据。</li><li>通过三次握手和四次挥手，保证数据的完整传输。</li><li>拥塞控制和滑动窗口（在窗口范围内一次发送多个报文段）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap的扩容</title>
      <link href="/2024/04/13/HashMap%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"/>
      <url>/2024/04/13/HashMap%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>谈到HashMap，本质是一个散列表，重点是三大问题：散列函数、哈希冲突、扩容方案。</p><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><pre><code class="highlight java"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span><span class="params">               <span class="type">boolean</span> evict)</span> &#123;    ...<span class="comment">// 与数组长度-1进行位与运算，得到下标</span>    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)        ...&#125;</code></pre><p>在putVal中，将key的hash值与数组长度-1 进行与运算，得到的 p 就是数组下标。</p><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><ul><li>如果不存在元素，直接存入该位置</li><li>如果存在元素，则判断桶位上的元素是否与要插入的相同，如果相同，执行替换操作</li></ul><p>如果不同，判断是链表还是红黑树。</p><p>如果是链表，就遍历链表上的元素，查找是否有与key相同的元素；如果没有，就插入链尾，并判断是否要树化。</p><p>Jdk1.8之前是数组+链表</p><p>jdk1.8之后是数组+链表+红黑树，在数组长度大于64且链表长度大于8转化为红黑树。</p><ul><li>为什么要大于等于8转化为红黑树，而不是7或9？</li></ul><p>数结点比普通结点更大，链表较短时用红黑树没有优势。在装载因子为0.75，链表长度达到8的概率极低。</p><h2 id="JDK1-8-扩容优化"><a href="#JDK1-8-扩容优化" class="headerlink" title="JDK1.8 扩容优化"></a>JDK1.8 扩容优化</h2><p>扩容时机由装载因子决定，在 1.8 之前，扩容时是把原来的每个节点重新计算 hash 值，对应到新数组的下标。在 1.8 中 HashMap 对扩容机制做了优化，对于结点在新数组的下标只有两种：原数组下标或 原数组下标 + 原数组长度。</p><p>回忆下计算 Hashmap 索引下标：索引 &#x3D; hashCode &amp; (数组长度 -1)。</p><p>比如当数组长度是 16 时，长度 - 1 就是 15，二进制为 1111。当数组长度是 32 时，长度 - 1 就是 31，二进制为 11111。从 16 扩容到 32 时，只是在 1111 前面多加了个 1。</p><p>这样做有什么好处？在计算新的索引时，只需判断原来的 hashCode 第五位是 0 还是 1。</p><ul><li>如果第五位是 0，那么这个元素在新数组中的位置不变。（0进行 &amp; 运算还是为 0）</li><li>如果第五位是 1，那么新数组索引是 旧索引加上 16（二进制 10000），也就是 旧索引加上原来数组长度。</li></ul><p>通过这种方式，不需要重新计算每个元素的索引，只需判断第五位，就能快速定位新数组的索引。</p><h2 id="为什么HashMap不安全"><a href="#为什么HashMap不安全" class="headerlink" title="为什么HashMap不安全"></a>为什么HashMap不安全</h2><ol><li>在1.7时多线程同时扩容可能造成链表形成环。</li><li>put 和 get并发时，可能导致 get 为 null。因为一个线程在进行 put 时触发扩容，此时另一个线程来 get，新数组还没有初始化，当然 get 为 null 了。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2024/04/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/04/13/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在 Java 中的线程池中，在核心线程数已满的情况下，为什么要先判断等待队列是否已满，未满放到队列中。而不是先判断最大线程数是否已满？    线程池的目的应该尽可能创建多个线程。</p></blockquote><p>原因有很多，可能等待队列充当了个缓存区，允许系统在流量高峰时有更多弹性，避免不必要的资源消耗。</p><p>另外，在 <a href="https://zhuanlan.zhihu.com/p/92632090">https://zhuanlan.zhihu.com/p/92632090</a> 中也提到了这点，每当需要创建线程时，都会调用 addWorker() 方法，在这个方法中需要获取锁，而多个线程获取锁会造成资源的争抢。如果在最大线程数未满的情况下，直接创建新的线程，这样每次都需要多获取一次锁。</p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>AbortPolicy：直接抛出异常。</p><p>DiscardPolicy：直接丢弃，也不通知。</p><p>DiscardOldestPolicy：丢弃队列最前面的任务。</p><p>CallerRunsPolicy：哪个线程提交的任务，哪个线程复制执行，也不丢弃。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>IO</title>
      <link href="/2024/04/09/IO/"/>
      <url>/2024/04/09/IO/</url>
      
        <content type="html"><![CDATA[<p>从传输方式看，Java 的 IO 分为 字符流和字节流。</p><p>字符流：InputStream、OutputStream</p><p>字节流：Reader、Writer</p><h2 id="字符流和字节流区别"><a href="#字符流和字节流区别" class="headerlink" title="字符流和字节流区别"></a>字符流和字节流区别</h2><ul><li>字节流读取单个字节，字符流读取单个字符</li><li>字节流用来处理二进制文件（图片、视音频），字符流处理文本文件。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java中异常机制</title>
      <link href="/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/04/09/Java%E4%B8%AD%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/image-20240409150132405.png" alt="image-20240409150132405"></p><blockquote><p>Error：一般是 JVM 出现了问题，如空间不足等。</p></blockquote><blockquote><p>Exception：异常分为运行时异常 (RunTimeException) 和编译时异常。</p></blockquote><p>Checked Exception 受检查异常：编译器要求处理，除了 RunTimeException 及其子类，其他 Exception 都是 受检查异常。</p><p>UnChecked Exception 不受检查异常：包括 RunTimeException及其子类 和 Error。</p><p>RunTimeException 及其子类</p><ul><li>NullPointerException</li><li>ArithmeticException 算术错误</li><li>ArrayIndexOutOfBoundsException 数组越界</li><li>IllegalArgumentException 参数类型异常</li><li>并发修改异常</li></ul><h2 id="执行的顺序"><a href="#执行的顺序" class="headerlink" title="执行的顺序"></a>执行的顺序</h2><p>当 try 捕获到异常，且 catch 中也有处理该异常的情况：try 按顺序执行，当执行到某一条语句出现异常时，程序将跳到 catch 语句块中找到对应的处理代码块，处理完后执行 finally 的代码即结束。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>记项目上线</title>
      <link href="/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/"/>
      <url>/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="前后端分离的线上域名部署"><a href="#前后端分离的线上域名部署" class="headerlink" title="前后端分离的线上域名部署"></a>前后端分离的线上域名部署</h2><p>背景：基于 SpringBoot 与 Vue 的前后端分离项目，前台页面有两个：分别是前台展示页面、后台管理页面。</p><p>对于后端而言需要注意的点：数据库改成服务器 IP，中间件的地址（redis、elasticsearch、rabbitmq等）。设置好后就可以打包成 jar 包，放到服务器目录中，在宝塔中有个很方便的点是选择 jar 包后自动填充执行命令，一键部署。<img src="/2024/04/07/%E8%AE%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF/image-20240407212903208.png" alt="image-20240407212903208"></p><p>后端部署完毕后，如何判断部署成功呢？其实可以借助 Postman 等工具测试个接口，看能否得到响应数据。或者直接在浏览器上输入 GET 请求地址，得到响应后说明后端可以正常访问。</p><p>两个前端部署：如果要用域名部署，最好先用 IP:端口 部署好后，再在宝塔的域名管理添加域名就可以了。前台-web页面默认的 publicPath: ‘&#x2F;‘，而后台管理页面是 publicPath: ‘&#x2F;admin’。因此二者放到服务器文件夹后，只需建一个站点，在配置文件（nginx）中如下配置：</p><pre><code class="highlight nginx"><span class="section">location</span><span class="regexp"> ^~</span> /admin&#123;<span class="attribute">alias</span> /www/wwwroot/blog-admin/dist;<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;&#125;<span class="section">location</span> /&#123;<span class="attribute">root</span> /www/wwwroot/blog-web/dist;<span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java的锁</title>
      <link href="/2024/04/06/Java%E7%9A%84%E9%94%81/"/>
      <url>/2024/04/06/Java%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><blockquote><p>本质在于是否单独占有内存地址空间和其他系统资源(如 I&#x2F;O)。</p></blockquote><p>进程是操作系统资源分配的基本单位，线程是操作系统调度的基本单位。</p><p>进程拥有独立的内存地址空间，拥有资源。</p><p>进程创建和销毁要保存寄存器和栈信息，还要进行资源回收。</p><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><p>这是一种广义上的概念。悲观锁认为在自己使用数据的时候中一定有其他的线程来修改数据，因此在获取数据前都会上锁。像 Lock 的实现类、synchronized 都是悲观锁。</p><p>乐观锁是乐观派，认为不会有其他线程来修改，因此不会上锁，只是在更新数据时判断这个数据在自己使用的时候，有没有别的线程修改过。常用的算法是 CAS 算法。</p><p>从上面我们得出结论：悲观锁用于写较多的场景，乐观锁用于读较多的场景。</p><p>CAS 是一个原子操作，因此不需要对其加锁。其包含三个操作数：要更新的变量V、预期原值A、新值B。先判断 V 是否等于 A，则可以将A更新为B。否则取消。</p><blockquote><p>预期值 A 本质是旧值</p></blockquote><h2 id="为什么有自旋锁？"><a href="#为什么有自旋锁？" class="headerlink" title="为什么有自旋锁？"></a>为什么有自旋锁？</h2><p>阻塞或唤醒一个线程需要切换上下文，这花费的时间可能比用户代码执行的时间还长。而且许多同步场景中，同步资源的锁定时间很长，不妨让线程等一等，不用挂起，这就是自旋。而且当今多核CPU，完全可以让一个核等一会，其他核去忙。</p><p>如果等待时间很短，则自旋很好。但如果时间很长，一直自旋也会让CPU白白消耗资源，于是自旋有个上限，默认是10次。</p><h2 id="Synchronized-锁原理分析"><a href="#Synchronized-锁原理分析" class="headerlink" title="Synchronized 锁原理分析"></a>Synchronized 锁原理分析</h2><p>monitorenter 和 monitorexit 指令。每个对象在同一时间只能与一个 monitor 关联，而一个 monitor 在同一时间只能被一个线程获得。当一个对象获取 monitor 时，会发生以下几种情况：1、 monitor 计数器为0，对象一旦获得锁则 monitor 加一。2、monitor 不为0，判断该线程是否为重入锁，是的话计数器加一，否则线程会被堵塞。</p><p>由于 monitorenter 和 monitorexit 是依赖于底层的操作系统实现的，这会将用户态变为内核态，影响性能。</p><h2 id="volatile-详解"><a href="#volatile-详解" class="headerlink" title="volatile 详解"></a>volatile 详解</h2><p>对修饰了 volatile 变量修改时，JVM 会向处理器插入一条 lock 前缀指令，具体如下：</p><ul><li><p>将当前处理器缓存的值立即刷新到主存</p></li><li><p>将其他处理器的缓存值置为无效</p></li></ul><p>因此，其他处理器在发现本地缓存失效时，会重新到主存中读取该值，也就是最新的值。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>概念：对象头 Mark Word：有 HashCode、GC Age、锁标记位。</p><p>当一个线程尝试获取轻量级锁时，会先在自己的栈帧中创建一个锁记录(Lock Record)，然后使用 CAS 将 Mark Word 拷贝到锁记录中，并且将 Mark Word 更新为指向 Lock Record 的指针。如果失败，看是否指向已经是当前栈帧，是的话已经获取锁了，否则会自旋。</p><h2 id="synchronized-和-ReentrantLock-的区别"><a href="#synchronized-和-ReentrantLock-的区别" class="headerlink" title="synchronized 和 ReentrantLock 的区别"></a>synchronized 和 ReentrantLock 的区别</h2><p>1、synchronized 是Java 的关键字，ReentrantLock 是一个类。</p><p>2、使用 synchronized 时，JVM 会自动加锁释放锁。而 Lock 时需要调用方法，在 finally 块中释放锁。</p><p>3、ReentrantLock 可以绑定多个 Condition，进行多路通知。而 synchronized 只能唤醒一个或全部线程。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS 的两个核心：资源 state、未获取到资源的等待队列 CLH，使用的自旋锁。</p><p>流程如下：</p><p>1、t1 时刻，线程 a 持有资源 state（持有资源的线程在 head 节点）</p><p>2、t1 时刻，线程 b 尝试获取锁失败，则封装为 Node 节点并插入 CLH 队列队尾。</p><p>3、挂起 b 线程，并告知 a 线程释放锁时通知下 b。</p><p>4、t2 时刻，a 线程释放锁并通知 b。</p><p>5、t3 时刻，b 尝试获取锁。</p><p>来看看 ReentrantLock 公平锁的tryAcquire：</p><pre><code class="highlight java"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;    <span class="comment">//获取当前线程</span>    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();    <span class="comment">//获取AQS中的state</span>    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();    <span class="comment">//如果state等于0说明此时没有线程占有锁</span>    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;        <span class="comment">//hasQueuedPredecessors 判断有没有别的线程排在了当前线程的前面。</span>        <span class="comment">//此方法返回true，代表当前线程需要排队，返回false，表示当前线程不用排队</span>        <span class="comment">//不用排队的话 直接cas尝试将state占位己有</span>        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(<span class="number">0</span>, acquires)) &#123;            <span class="comment">//设置AQS中的独占线程字段 为当前线程</span>            setExclusiveOwnerThread(current);            <span class="comment">//返回true 代表获取锁成功</span>            <span class="keyword">return</span> <span class="literal">true</span>;        &#125;    &#125;    <span class="comment">//如果state不是0 则判断当前占有锁的线程是否是当前线程，如果是，</span>    <span class="comment">//表示此线程重入抢锁，对state进行+1 </span>    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);        setState(nextc);        <span class="comment">//重入线程，只需将state+1， head信息不需要变，也不许要到等待队列排队，</span>        <span class="comment">//直接返回true加锁成功</span>        <span class="keyword">return</span> <span class="literal">true</span>;    &#125;    <span class="comment">//抢锁失败 返回false</span>    <span class="keyword">return</span> <span class="literal">false</span>;&#125;</code></pre><p>非公平锁就是少了 hasQueuedPredecessors 的判断。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>泛型机制</title>
      <link href="/2024/04/06/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/04/06/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>泛型就是为了方法的复用，不必再搞个方法重载了，其实就是为了跳过方法重载，因为方法重载冗余代码太多。</p><h2 id="证明泛型擦除"><a href="#证明泛型擦除" class="headerlink" title="证明泛型擦除"></a>证明泛型擦除</h2><p>泛型擦除在编译阶段发生。</p><pre><code class="highlight java">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list1.add(<span class="string">&quot;a&quot;</span>);ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list2.add(<span class="number">1</span>);System.out.println(list1.getClass() == list2.getClass()); <span class="comment">// true</span></code></pre><h2 id="通过反射绕过编译类型检查"><a href="#通过反射绕过编译类型检查" class="headerlink" title="通过反射绕过编译类型检查"></a>通过反射绕过编译类型检查</h2><pre><code class="highlight java">ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();list1.getClass().getMethod(<span class="string">&quot;add&quot;</span>, Object.class).invoke(list1, <span class="string">&quot;wd&quot;</span>);System.out.println(list1.get(<span class="number">0</span>));</code></pre><p>反射得到 可以接收Object类型的add方法，invoke调用此方法。</p><h2 id="泛型的编译期检查"><a href="#泛型的编译期检查" class="headerlink" title="泛型的编译期检查"></a>泛型的编译期检查</h2><p>泛型的检查是在编译之前的，如果是在编译之后，在执行下面这段代码时应该是能加入的：</p><pre><code class="highlight java">ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  list.add(<span class="string">&quot;123&quot;</span>);  list.add(<span class="number">123</span>);<span class="comment">//编译错误  </span></code></pre><p>但报错，说明是在编译之前的。</p><h2 id="类型检查是检查什么？"><a href="#类型检查是检查什么？" class="headerlink" title="类型检查是检查什么？"></a>类型检查是检查什么？</h2><p>检查的是引用。</p><pre><code class="highlight java">ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();  list1.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span>list1.add(<span class="number">1</span>); <span class="comment">//编译错误  </span><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> list1.get(<span class="number">0</span>); <span class="comment">//返回类型就是String  </span><span class="type">ArrayList</span> <span class="variable">list2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  list2.add(<span class="string">&quot;1&quot;</span>); <span class="comment">//编译通过  </span>list2.add(<span class="number">1</span>); <span class="comment">//编译通过  </span><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> list2.get(<span class="number">0</span>); <span class="comment">//返回类型就是Object  </span><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="string">&quot;11&quot;</span>); <span class="comment">//编译通过  </span><span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().add(<span class="number">22</span>); <span class="comment">//编译错误  </span><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().get(<span class="number">0</span>); <span class="comment">//返回类型就是String </span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker容器中的vim</title>
      <link href="/2024/03/30/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84vim/"/>
      <url>/2024/03/30/docker%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84vim/</url>
      
        <content type="html"><![CDATA[<p>在 docker 容器中没有安装 vim 编辑器，需要使用 apt 命令安装，在更新 apt 软件包时遇到了一些坑，便记录下来。</p><p>遇到的坑主要是使用 apt 安装 vim 时，使用镜像为 163 的，总是报 ‘E: Sub-process &#x2F;usr&#x2F;bin&#x2F;dpkg returned an error code (1)’ 错误，后来重新换了个阿里云的源解决了问题。</p><p>cd &#x2F;etc&#x2F;apt 里面有个 sources.list，执行下面代码使用阿里云镜像源。</p><pre><code class="highlight plaintext">echo &quot;&quot; &gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse&quot; &gt;&gt; sources.list; \echo &quot;deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse&quot; &gt;&gt; sources.list</code></pre><p>如果出现了 The following signatures couldn’t be verified because the public key is not available，则按照下面代码执行</p><pre><code class="highlight plaintext">apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 此处为错误信息的字符串</code></pre><p>之后执行 apt-get update、apt-get install vim 都成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GitHub搜索trick</title>
      <link href="/2024/03/28/GitHub%E6%90%9C%E7%B4%A2trick/"/>
      <url>/2024/03/28/GitHub%E6%90%9C%E7%B4%A2trick/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub-精确搜索"><a href="#GitHub-精确搜索" class="headerlink" title="GitHub 精确搜索"></a>GitHub 精确搜索</h2><pre><code class="highlight markdown"><span class="section"># 按照项目名/仓库名搜索</span>in:name xxx<span class="section"># 按照README搜索</span>in:readme xxx<span class="section"># 按照 description 搜索</span>in:description xxx<span class="section"># stars数大于xxx</span>stars:&gt;xxx<span class="section"># 编程语言为xxx</span>language:xxx</code></pre>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习</title>
      <link href="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="ES-核心概念"><a href="#ES-核心概念" class="headerlink" title="ES 核心概念"></a>ES 核心概念</h2><p>ElasticSearch：简称 es，分布式全文搜索引擎。实时的存储、检索数据。</p><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240329152019163.png" alt="image-20240329152019163"></p><p>索引就是数据库，文档就是一条条数据</p><blockquote><p>倒排索引</p></blockquote><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240329153835659.png" alt="image-20240329153835659"></p><p>将文章中的标签都取出来，有该标签的文章则记录下来。以后查询时，只需要查看标签，获取掉对应的文章，过滤掉无关的文章。</p><h2 id="IK-分词器"><a href="#IK-分词器" class="headerlink" title="IK 分词器"></a>IK 分词器</h2><p>IK 提供了两个分词算法：ik_smart 和 ik_max_word，前者为最少切分，后者为最细粒度切分。</p><p>ik_smart 会讲句子切分成词语，词语不会彼此重叠。</p><p>ik_max_word 会按细粒度切分，也就是前后只要能组成词语就切分，不在乎是否重叠。</p><h2 id="Rest-分格"><a href="#Rest-分格" class="headerlink" title="Rest 分格"></a>Rest 分格</h2><h3 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h3><blockquote><p>基础测试</p></blockquote><p>1、创建一个索引</p><pre><code class="highlight plaintext">PUT /索引名/类型名/文档id&#123;键值对形式&#125;</code></pre><p>添加数据</p><pre><code class="highlight json">PUT /test3/_doc/<span class="number">1</span><span class="punctuation">&#123;</span>  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;wdcp&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="string">&quot;13&quot;</span><span class="punctuation">,</span>  <span class="attr">&quot;birth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2001-01-05&quot;</span><span class="punctuation">&#125;</span></code></pre><p>更新数据</p><pre><code class="highlight json"># 使用 POST 更新数据<span class="punctuation">,</span> 使用_updatePOST /test3/_doc/<span class="number">1</span>/_update<span class="punctuation">&#123;</span>  <span class="attr">&quot;doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span>    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;大盘&quot;</span>  <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></code></pre><p>如果不使用 _update，改动一个数据需要把其他的值也写上，否则更新后为空。</p><h3 id="关于文档的基本操作-重点"><a href="#关于文档的基本操作-重点" class="headerlink" title="关于文档的基本操作(重点)"></a>关于文档的基本操作(重点)</h3><blockquote><p>基本操作</p></blockquote><pre><code class="highlight json">GET test3/_doc/_search?q=name<span class="punctuation">:</span>大盘</code></pre><p>模糊查询</p><pre><code class="highlight json'">GET test3/_doc/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;:&#123;      &quot;name&quot;: &quot;大盘&quot;    &#125;  &#125;&#125;</code></pre><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330155320334.png" alt="image-20240330155320334"></p><ul><li>gt 大于</li><li>gte 大于等于</li><li>lt 小于</li></ul><blockquote><p>精确查询</p></blockquote><p>term 是通过倒排索引精确的查找！</p><p><strong>关于分词：</strong></p><ul><li>term</li><li>match：会进行分词，再查询</li></ul><p><strong>两个类型 text keyword</strong></p><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330161850615.png" alt="image-20240330161850615"></p><p>对于 keyword，查询时不会被分词，因此只有全局匹配才查到。对于 text 会被分词。</p><blockquote><p>高亮</p></blockquote><p><img src="/2024/03/28/ElasticSearch%E5%AD%A6%E4%B9%A0/image-20240330162859502.png" alt="image-20240330162859502"></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>倒排索引：比如某个文档经过分词，提取了 20 个关键词，为每一个词建立一个索引，指明该词在文章中出现的次数和位置。倒排索引就是关键词到文档ID的映射。</p><blockquote><p>index：类似于 MySQL 的表。</p><p>document：类似于 MySQL 的记录。</p></blockquote><p>text与keyword：keyword的类型是不会分词的，只能通过精确匹配查询到。text会先分词，根据分词的内容建立倒排索引。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL复盘</title>
      <link href="/2024/03/23/SQL%E5%A4%8D%E7%9B%98/"/>
      <url>/2024/03/23/SQL%E5%A4%8D%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><blockquote><p> 存储大量文本数据：text、mediumtext、longtext</p></blockquote><p>分别可以存储 $2^{16}-1$ 、$2^{24}-1$ 、$2^{32}-1$ 个字符。</p><blockquote><p>金额计算：用 decimal(M, N)     M：最大存几位数(不包括小数点)   N：小数点后的位数</p></blockquote><p>如 decimal(5, 2)  存储范围是 -999.99 - 999.99。</p><blockquote><p> 日期数据类型：Date、DateTime、<strong>timestamp</strong></p></blockquote><p>计算两个日期之间的时间差：TIMEDIFF</p><p>DateTime 可以显示到秒级别。</p><p>timestamp 和时区有关。</p><h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><blockquote><p>outer join：分别 left join 和 right join。</p></blockquote><h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2><blockquote><p>UNION：将两个或多个的查询结果组合起来，并消除重复的行。</p><p>UNION ALL：包含重复的行。</p></blockquote><p>组合查询的规则：</p><ul><li>多个查询的字段类型、个数需要相同。</li><li>对于 order by，需要放到最后一条 select 之后。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2024/03/19/Docker/"/>
      <url>/2024/03/19/Docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker-和-虚拟机的区别"><a href="#Docker-和-虚拟机的区别" class="headerlink" title="Docker 和 虚拟机的区别"></a>Docker 和 虚拟机的区别</h2><p>虚拟机需要启动完整的系统，内核、工具等</p><p>Docker 是容器的一种实现方式，镜像是一个模板，容器是模板的实例。</p><p><img src="/2024/03/19/Docker/image-20240319140809181.png" alt="image-20240319140809181"></p><p>查看本地镜像：docker images</p><p>查看正在运行的容器：docker ps</p><p>运行一个容器：docker run –name some-nginx -d -p 8080:80 nginx:1.22</p><p>查看容器的信息：docker inspect 容器名</p><pre><code class="highlight plaintext">将容器连接到网络：docker network (dis)connect 网络名 容器名 之后访问容器 docker run -it --rm mysql:5.7 mysql -h172.17.0.2 -uroot -p=》 docker run -it --rm --network 网络名 mysql:5.7 mysql -hsome-mysql -uroot -p</code></pre><h2 id="Docker-存储"><a href="#Docker-存储" class="headerlink" title="Docker 存储"></a>Docker 存储</h2><p><img src="/2024/03/19/Docker/image-20240319153237440.png" alt="image-20240319153237440"></p><p>创建一个卷：docker volume create 卷名</p><h2 id="Docker-网络"><a href="#Docker-网络" class="headerlink" title="Docker 网络"></a>Docker 网络</h2><p><img src="/2024/03/19/Docker/image-20240415165528783.png" alt="image-20240415165528783"></p><p><img src="/2024/03/19/Docker/image-20240415191928794.png" alt="image-20240415191928794"></p><p>如果容器不指定网络情况下，都是 Docker0 路由的，Docker0 会给容器分配一对 veth-pair。</p><p>通过 <code>docker network inspect 网络id</code> 查看</p><p><img src="/2024/03/19/Docker/image-20240415192837156.png" alt="image-20240415192837156"></p><h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><ul><li>桥接 (bridge) ：默认</li><li>none ：不配置网络</li><li>host ：和宿主机共享网络</li></ul><pre><code class="highlight dockerfile">-- 创建自定义网络docker network create --driver bridge --subnet <span class="number">192.168</span>.<span class="number">0.0</span>/<span class="number">16</span> --gateway <span class="number">192.168</span>.<span class="number">0.1</span> mynet-- 创建容器到指定网络docker <span class="keyword">run</span><span class="language-bash"> -d -P --name tomcat01 --net mynet tomcat</span></code></pre><p>自定义网络可以直接通过容器名 ping</p><h3 id="网络连通"><a href="#网络连通" class="headerlink" title="网络连通"></a>网络连通</h3><p><img src="/2024/03/19/Docker/image-20240415201510604.png" alt="image-20240415201510604"></p><p>现在创建一个新的容器到 docker0 网段</p><p><img src="/2024/03/19/Docker/image-20240415201820589.png" alt="image-20240415201820589"></p><p>连通命令</p><p><img src="/2024/03/19/Docker/image-20240415202812841.png" alt="image-20240415202812841"></p><h2 id="Docker-部署前后端分离项目-若依"><a href="#Docker-部署前后端分离项目-若依" class="headerlink" title="Docker 部署前后端分离项目-若依"></a>Docker 部署前后端分离项目-若依</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1、创建 mysql 容器</p><pre><code class="highlight linux">docker run -d \  --name mysql \  -p 3307:3306 \  -e TZ=Asia/Shanghai \  -e MYSQL_ROOT_PASSWORD=1314 \  -v ./mysql/data:/var/lib/mysql \  -v ./mysql/conf:/etc/mysql/conf.d \  -v ./mysql/init:/docker-entrypoint-initdb.d \   # 映射路径  --network ruoyi    \  mysql:8.0.19</code></pre><p>在启动 mysql 容器后，运行中内存会很大，需要在进入容器内为其配置文件中设置参数：</p><p>&#x2F;etc&#x2F;mysql&#x2F;conf.d 目录执行 vim docker.cnf</p><pre><code class="highlight plaintext">performance_schema_max_table_instances=400  table_definition_cache=400    performance_schema=off    table_open_cache=64    innodb_buffer_pool_chunk_size=64M    innodb_buffer_pool_size=64M</code></pre><p>2、创建 redis 容器</p><pre><code class="highlight linux">docker run  \--name redis \-p 6380:6379 \-v /root/redis/conf:/usr/local/etc/redis \-v /root/redis/data:/data \-d \--network ruoyi   \redis:6.0.8 \redis-server /usr/local/etc/redis/redis.conf</code></pre><p>3、创建 nginx 容器</p><pre><code class="highlight linux">docker run -d \  --name nginx \  -p 81:80 \  -v /root/nginx/html:/usr/share/nginx/html \  -v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \  --network ruoyi  \  nginx:1.22</code></pre><p>由于 nginx 的配置文件容器出错，我们可以先创建一个 nginx 容器复制其配置文件，再删除它。</p><pre><code class="highlight plaintext"># 复制配置docker cp nginx:/etc/nginx/nginx.conf /root/nginx/conf/nginx.confdocker cp nginx:/etc/nginx/conf.d /root/nginx/conf/conf.ddocker cp nginx:/usr/share/nginx/html /root/nginx/</code></pre><p>4、部署后端 Dokcerfile</p><pre><code class="highlight linux"># 基础镜像FROM openjdk:11.0-jre-buster# 设定时区ENV TZ=Asia/ShanghaiRUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;&amp; echo $TZ &gt; /etc/timezone# 挂载目录VOLUME /home/ruoyi# 创建目录RUN mkdir -p /home/ruoyi# 指定路径WORKDIR /home/ruoyi# 拷贝jar包COPY /root/ruoyi-admin.jar /home/ruoyi/app.jar# 入口ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]</code></pre><p>5、创建项目镜像</p><pre><code class="highlight linux">docker build -t ruoyi:1.0 -f /root/Dockerfile .</code></pre><p>6、创建项目容器</p><pre><code class="highlight linux">docker run -d \--name ruoyi  \-p 8081:8081  \-v /root/ruoyi/uploadPath:/home/ruoyi/uploadPath \--network \ruoyi  \ruoyi:1.0</code></pre><p>7、最后运行容器</p><pre><code class="highlight plaintext">docker run -d \-p 81:80 \-p 443:443 \--name nginx \--restart=always \--network ruoyi \-e TZ=&quot;Asia/Shanghai&quot; \-v /root/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \-v /root/nginx/conf/conf.d:/etc/nginx/conf.d \-v /root/nginx:/var/log/nginx \-v /root/nginx/html:/usr/share/nginx/html \-v /root/nginx/cert:/etc/nginx/cert \nginx:1.22</code></pre><p>现在可以通过 服务器id : nginx端口 访问界面了！</p><p><img src="/2024/03/19/Docker/image-20240322095418176.png" alt="image-20240322095418176"></p><p>其中容易出错的点是配置 nginx 时，其配置文件对于后端的映射。</p>]]></content>
      
      
      <categories>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网小记</title>
      <link href="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="TCP-与-UDP-区别"><a href="#TCP-与-UDP-区别" class="headerlink" title="TCP 与 UDP 区别"></a>TCP 与 UDP 区别</h2><p>TCP：面向连接、可靠、面向字节流</p><p>UDP：无连接、不可靠、面向报文</p><p>TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多</p><p>应用场景：</p><p>TCP：FTP 文件传输、HTTP &#x2F; HTTPS</p><p>UDP：实时应用、游戏</p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="/2024/03/16/%E8%AE%A1%E7%BD%91%E5%B0%8F%E8%AE%B0/image-20240316164317006.png" alt="image-20240316164317006"></p><p>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong>。</p><p><strong>第一次握手：</strong>客户端首先也创建传输运输块，向服务器发出连接请求报文，将标志位 SYN 置为 1，选择一个初始序列号 seq&#x3D;x。SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。</p><p><strong>第二次握手：</strong>服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK&#x3D;1，SYN&#x3D;1，确认号是ack&#x3D;x+1，同时也要为自己初始化一个序列号 seq&#x3D;y，此时，TCP服务器进程进入了 SYN-RCVD 同步收到状态。</p><p>第三次握手：TCP客户端收到确认后，还要向服务器给出确认。确认报文的ACK&#x3D;1，ack&#x3D;y+1，自己的序列号seq&#x3D;x+1，此时，TCP连接建立。</p><p><strong>第三次握手是可以携带数据的，前两次握手是不可以携带数据的</strong></p>]]></content>
      
      
      <categories>
          
          <category> 408 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git上传代码</title>
      <link href="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/"/>
      <url>/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>git add .  提交当前工作目录的文件到暂存区</p><p>git commit -m ‘提交注释’ ：将暂存区的文件提交到当前分支。</p><p>git push：将当前分支的内容同步到远程仓库。</p></blockquote><p>有了暂存区，可以很方便的进行回滚</p><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><blockquote><p>git status：显示工作目录和索引的状态</p><p>git diff：比较工作目录和索引的差异      –cached：比较索引和对象数据库的差异</p><p>git restore：从索引将文件恢复到工作目录中     –staged 从对象数据库将文件恢复到索引</p></blockquote><p>.gitignore：忽略加入暂存区的文件</p><h2 id="生成秘钥"><a href="#生成秘钥" class="headerlink" title="生成秘钥"></a>生成秘钥</h2><pre><code class="highlight plaintext">cd .sshssh-keygen -t rsa -b 4096</code></pre><p>git remote -v：查看本地仓库所对应的远程仓库的别名和地址</p><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>创建分支：git branch dev</p><p>切换分支：git switch dev</p><p>合并分支：git merge dev 把 dev 分支合并到 main 分支中</p><p><img src="/2024/03/15/git%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81/image-20240318164945891.png" alt="image-20240318164945891"></p><h2 id="Git-clone-协议"><a href="#Git-clone-协议" class="headerlink" title="Git clone 协议"></a>Git clone 协议</h2><p>SSH 协议、HTTPS 协议</p><h2 id="git-add-和-git-commit"><a href="#git-add-和-git-commit" class="headerlink" title="git add 和 git commit"></a>git add 和 git commit</h2><blockquote><p>为什么要分开设计？不能一次性提交吗？</p></blockquote><p><code>git add</code> 命令允许收集下一次提交需要的全部内容，因为Git只会为增加到索引（暂存区）的变更建立快照。</p><p>这样设计是为了选择将哪些变更作为下一次提交的内容。比如有下面的场景：</p><p>项目中有一个文件录入错误，你改正了这个错误。但这个修正与你原来的任务无关。如何将这个修正与原来的任务分开呢？</p><p>你可以使用 <code>git add</code> 暂存这个修正后的文件，并使用<code>git commit -m &#39;&#39;</code> 来提交这个修正。这次提交只包含了那个特定的修正，与你原来的任务没有关系。</p><p>在提交了修正后，可以继续处理原任务，再次使用<code>git add</code> 暂存这些变更，使用<code>git commit -m &#39;&#39;</code> 来提交，确保这次提交只与你的原任务相关。</p><p>工作目录 -&gt; 索引 -&gt; 对象数据库</p><blockquote><p>链</p></blockquote><p>Git提交（commit）会记录你做出并增加到索引的变更。除了存储库中第一个提交，之后的提交会指向它之前的提交，构成一个有向无环图（DAG）。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL知识点</title>
      <link href="/2024/03/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2024/03/15/MySQL%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>排除记录时用 where，join on 是进行笛卡尔连接的。</p><p>当想要获得某个列(如工资)的排序，可以考虑表自连接。 </p><pre><code class="highlight sql">(<span class="keyword">select</span> s1.salary <span class="keyword">from</span> salaries s1, salaries s2 <span class="keyword">where</span> s1.salary <span class="operator">&lt;=</span> s2.salary <span class="keyword">group</span> <span class="keyword">by</span> s1.salary <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span>(s2.salary)) <span class="operator">=</span> <span class="number">2</span>)</code></pre><h2 id="B-树和B树的区别"><a href="#B-树和B树的区别" class="headerlink" title="B+树和B树的区别"></a>B+树和B树的区别</h2><ul><li><p>B+ 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</p></li><li><p>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</p></li></ul><p>B+ 树只有叶子存放数据：一方面，查找数据时要到叶子才能找到；另一方面，由于非叶子结点不存放数据，只存放索引，降低了树的高度。</p><h2 id="InnoDB-物理结构"><a href="#InnoDB-物理结构" class="headerlink" title="InnoDB 物理结构"></a>InnoDB 物理结构</h2><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。使用辅助索引需要检索两遍索引：首先检索辅助索引获得主键，然后根据主键到主键索引中检索获得数据记录。</li></ul><h2 id="MySQL-索引"><a href="#MySQL-索引" class="headerlink" title="MySQL 索引"></a>MySQL 索引</h2><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>主键索引、唯一索引、普通索引、联合索引、全文索引</p><blockquote><p>唯一索引：索引列的值必须唯一，但可以为空</p></blockquote><p>聚簇索引和非聚簇索引：</p><p>聚簇索引：叶子存放了实际数据，所有完整的用户记录都存放在这里。</p><p>非聚簇索引：叶子存放的是主键值，因此如果想要的数据在二级索引查不到，就需要通过主键索引查到所有的数据，这个过程就是回表。</p><h3 id="联合索引的最左匹配原则"><a href="#联合索引的最左匹配原则" class="headerlink" title="联合索引的最左匹配原则"></a>联合索引的最左匹配原则</h3><p>从左开始向右匹配，当遇到范围查询时就停止匹配。<strong>范围查询的字段还是可以用联合索引的。</strong></p><p>先对第一个字段进行排序，再对第二个字段排序。</p><pre><code class="highlight sql"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_table <span class="keyword">where</span> a <span class="operator">&gt;=</span> <span class="number">1</span> <span class="keyword">and</span> b <span class="operator">=</span> <span class="number">2</span></code></pre><p>这里的 a 和 b 都用到了联合索引。虽然在 a &gt; 1 这个条件中，b 字段的值是无序的。但在 a &#x3D; 1 条件中，b 字段的值是有序的。</p><pre><code class="highlight sql"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_table <span class="keyword">WHERE</span> a <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">8</span> <span class="keyword">AND</span> b <span class="operator">=</span> <span class="number">2</span></code></pre><p>同上，a &#x3D; 2 或 a &#x3D; 8 时，b 字段的值是有序的。</p><h3 id="什么时候用到索引？"><a href="#什么时候用到索引？" class="headerlink" title="什么时候用到索引？"></a>什么时候用到索引？</h3><p>1、字段有唯一性限制的，如商品 ID。</p><p>2、出现在 where、group by、order by 中的字段</p><blockquote><p>不需要索引：</p><p>如果一个字段经常被修改，就不建议对其创建索引，因为修改数据时索引也需要修改。</p><p>表中数据比较少的情况。</p></blockquote><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><blockquote><p>记住，索引保存的是索引字段的原始值，对索引字段进行修改会使索引失效。</p></blockquote><p>1、like 关键字 ‘%xx’ 或 ‘%xx%’ 会让索引失效。</p><p>2、对索引使用函数、对索引使用表达式计算。</p><p>3、索引隐式类型转换。（索引为 varchar，但传入的是 int）</p><p>4、联合索引非最左匹配。 联合索引是指数据先按索引第一列排序，第一列排序相同后才会按照第二列排序。</p><h2 id="并发事物问题"><a href="#并发事物问题" class="headerlink" title="并发事物问题"></a>并发事物问题</h2><blockquote><p>脏读：A事物读取了  未提交事物 B 修改过的数据，就发生了脏读。对于未提交的事物 B 来说，它可能发生回滚，那么 A 中的数据就是脏数据。</p></blockquote><blockquote><p>不可重复读：一个事物多次读取同一个数据，得到的结果不一样。（有其他事物在期间对此数据做了修改）</p></blockquote><blockquote><p>幻读：一个事物多次查询某个符合条件的 记录数量，出现前后两次查询结果不一致。（有其他事物在期间插入符合条件的记录）</p></blockquote><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>读未提交：事物还没有提交时，所做的更改可以被其他事物看到。</li><li>读提交：事物还没有提交时，所做的更改 <strong>不能</strong> 被其他事物看到。</li><li>可重复读：一个事物执行中看到的数据与这个事物启动时看到的数据一致。是 MySQL 默认的隔离级别。因此如果有其他事物插入了记录，是查不出来这条数据的，避免了幻读问题。</li><li>串行化：同一时刻只允许单个事物执行。写会加写锁，读会读读锁</li></ul><p>读提交是在 每个语句执行前 都会生成一个快照</p><p>可重复读是在 启动事物时生成一个快照，在整个事物期间都用这个快照，保证了事物期间读取到的数据都是事物前的。</p><p>串行化是通过 加读写锁 实现的。</p><h2 id="MySQL-日志"><a href="#MySQL-日志" class="headerlink" title="MySQL 日志"></a>MySQL 日志</h2><p>比较常见的重做日志 redo log、归档日志 binlog，还有回滚日志 undo log。</p><blockquote><p>undo log作用：</p><ul><li>实现事物回滚，保障事物的原子性。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM笔记</title>
      <link href="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/03/12/JVM%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312160432882.png" alt="image-20240312160432882"></p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><h3 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h3><p>加载、验证、准备、解析、初始化</p><blockquote><p>准备阶段：为类的 static 变量在方法区分配内存，将其初始值置为 0。被 final 修饰的常量会直接赋值。</p></blockquote><h2 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h2><ul><li>线程私有：Java虚拟栈、程序计数器、本地方法栈</li><li>线程共享：方法区、堆内存</li></ul><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>Java 在尝试加载一个类时，系统首先判断这个类是否被加载过，已经加载的类直接返回，否则才会尝试加载。类加载器会将加载任务先委托给它的父加载器去尝试加载这个类，一直到达顶层的类（Bootstrap）只有在父加载器无法加载该类时（找不到对应的类），子加载器才会尝试去加载。</p><h2 id="JVM-虚拟机栈"><a href="#JVM-虚拟机栈" class="headerlink" title="JVM 虚拟机栈"></a>JVM 虚拟机栈</h2><p>每个Java虚拟机线程都有一个私有的Java栈，与线程同时创建。Java栈中保存着帧信息，每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。</p><p>局部变量表、操作数栈、动态链接、方法返回地址。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312192522896.png" alt="image-20240312192522896"></p><p>GC 垃圾回收，主要是在伊甸园区和养老区</p><ul><li><p>新生代：诞生、成长、死亡的地方。分为伊甸园区、From、To 幸存区（0,1）。</p></li><li><p>老年代</p></li></ul><h3 id="晋升到老年代"><a href="#晋升到老年代" class="headerlink" title="晋升到老年代"></a>晋升到老年代</h3><ul><li>在程序运行过程中，新生代GC会反复发生，长寿对象会在S0和S1之间反复交换，年龄也会越来越大，当对象达到年龄上限时，会被晋升到老年代。这个年龄上限默认是15。</li><li>大对象会跨过年轻代直接分配到老年代。</li><li>某个年龄和以下年龄的对象总大小大于幸存区的一半，年龄大于或等于该年龄的对象可以进入老年代。</li><li>老年代空间担保原则：在做任何一次 Minor GC 时，老年代需要确保自己的内存大于新生代所有对象的总和。如果设置了HandlePromotionFailure参数，还会进一步判断是否大于之前 Minor GC 进入老年代对象的平均大小。没有的话就直接 Full GC。</li></ul><blockquote><p>现在可以尝试 Minor GC 了，如果 Minor GC 后，存活的对象小于幸存区大小，就进入幸存区。如果大于幸存区，但小于老年代空间，就进入老年代。如果既大于幸存区又大于老年区，触发 Full GC。</p></blockquote><p>在 jdk8 后，永久代改了个名字（元空间）：这个区域在本地内存，存储的是 java 运行时的一些环境或类信息。这个区域不存在垃圾回收。方法区在元空间</p><p>非堆内存：方法区、元空间</p><ul><li>JDK 1.8 之后，无永久代，替代为元空间，不存在于 JVM，使用的是本地内存。</li></ul><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240312200859515.png" alt="image-20240312200859515"></p><h2 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h2><ul><li>引用计数算法：两个对象循环依赖导致无法回收。</li><li>可达性分析算法：通过GC Roots 开始找，与它相连接的就是可达对象。</li><li>三色标记算法</li></ul><p>初始标记：寻找所有被 GCRoots 直接引用的对象。这里需要 Stop the World。</p><p>并发标记：对初始标记中标记的对象进行整个引用链的扫描，这里可以与用户线程同步。</p><p>重新标记：并发标记会耗费较长时间，这段时间中对象的引用可能会改变，用来处理这些问题。该过程需要  Stop the World。</p><p>并发清除：将标记为垃圾的对象进行清除，不需要 Stop the World。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ul><li><p>标记-清除：将存活的对象进行标记，然后清除未标记的对象。（会产生内存碎片）<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407112632893.png" alt="image-20240407112632893"></p></li><li><p>标记-整理：让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407112759472.png" alt="image-20240407112759472"></p></li><li><p>复制算法：将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存满了就将存活对象复制到另一块，再把使用过的内存空间一次性清理。<img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240407113408523.png" alt="image-20240407113408523"></p></li><li><p>分代收集：将内存划分为几块，如堆分为新生代和老年代。</p></li></ul><p>新生代一般使用复制算法进行垃圾回收。复制算法将新生代分为 Eden区和两个幸存区（From 区、To 区）。当 Eden 区满时，触发 Minor GC，将存活对象移动到一个幸存区，然后清空 Eden 区。这个过程循环反复，直到一个幸存区满了，再触发 Minor GC，将 Eden 区和 From 区的存活对象移到另一个幸存区，清空这个幸存区。</p><p>老年代一般采用标记-清除和标记-整理算法。</p><h2 id="GC-过程"><a href="#GC-过程" class="headerlink" title="GC 过程"></a>GC 过程</h2><ol><li>新创建的对象大多分配在 Eden 区，当Eden区满了发生 Minor GC。</li><li>GC活下来的对象放到幸存区的S0区，S0区满了触发 Minor GC，S0区存活的对象会放入S1区。</li><li>S1满了之后GC，存活的对象放到S0区，这样反复每GC一次，对象的年龄就增加一，到达某个值后，就晋升到老年代。</li></ol><h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><p><img src="/2024/03/12/JVM%E7%AC%94%E8%AE%B0/image-20240422210101635.png" alt="image-20240422210101635"></p><p>Serial：单线程回收。新生代用复制算法，老年代用标记-整理算法。</p><p>Parallel Scavenge、Parallel Old：新生代用复制算法，老年代用标记-整理算法。</p><blockquote><p>以上两种方式都会导致用户线程暂停，进行垃圾回收。</p></blockquote><p>分代收集器：CMS 使用三色标记算法</p><p>分区收集器：G1、ZGC</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ实战</title>
      <link href="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/"/>
      <url>/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-整合-RabbitMQ-注意："><a href="#SpringBoot-整合-RabbitMQ-注意：" class="headerlink" title="SpringBoot 整合 RabbitMQ 注意："></a>SpringBoot 整合 RabbitMQ 注意：</h2><p>端口 15672：这是 RabbitMQ 管理界面的默认端口，这个端口可以对 RabbitMQ 后台管理。</p><p>端口 5672：这是 RabbitMQ 默认的 AMQP 协议端口。客户端通常使用这个端口与 RabbitMQ 服务器建立连接进行消息传递操作。</p><p>在配置文件 application.yml 进行 RabbitMQ 配置时，连接端口是 5672。</p><h2 id="Work-模型"><a href="#Work-模型" class="headerlink" title="Work 模型"></a>Work 模型</h2><p>多个消费者绑定到一个队列，加快消息处理速度。在消费者服务中，可以配置 prefetch 控制消费者预取的消费数量，处理完一条才处理剩余的，类似负载均衡。</p><h2 id="为什么需要交换机？"><a href="#为什么需要交换机？" class="headerlink" title="为什么需要交换机？"></a>为什么需要交换机？</h2><p>交换机可以实现生产者预消费者解耦，生产者无需关心消息会发送到哪个队列、被哪个消费者消费。生产者只需面向交换机，消费者只需面向队列。</p><h2 id="fanout-交换机"><a href="#fanout-交换机" class="headerlink" title="fanout 交换机"></a>fanout 交换机</h2><p>fanout 交换机会将所有接收到的消息广播给所有与之绑定的队列。</p><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309175129139.png" alt="image-20240309175129139"></p><h2 id="Direct-交换机"><a href="#Direct-交换机" class="headerlink" title="Direct 交换机"></a>Direct 交换机</h2><p>可以指定交换机与哪个队列进行绑定。</p><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309180620965.png" alt="image-20240309180620965"></p><h2 id="Topic-交换机"><a href="#Topic-交换机" class="headerlink" title="Topic 交换机"></a>Topic 交换机</h2><p><img src="/2024/03/09/RabbitMQ%E5%AE%9E%E6%88%98/image-20240309192215485.png" alt="image-20240309192215485"></p><h2 id="确保消息不丢失"><a href="#确保消息不丢失" class="headerlink" title="确保消息不丢失"></a>确保消息不丢失</h2><p>首先要明白三个问题：</p><ul><li>如何知道消息丢失了？ 给每个消息设置一个全局ID</li><li>哪些情况下消息会丢失</li><li>如何确保消息不丢失</li></ul><blockquote><p>生产者 -&gt; MQ：可以使用 confirm 机制。当 MQ 收到消息会返回一个确认 ACK 给生产者。未收到会返回 未确认，这里需要生产者进行处理。</p></blockquote><blockquote><p>MQ 本身：需要使用持久化机制。交换机持久化、队列持久化、消息持久化。</p></blockquote><blockquote><p>MQ -&gt; 接收者：使用手动确认机制。当业务处理完了，再手动确认消息执行完毕。</p></blockquote><p>如何解决消息重复消费？（幂等性）</p><p>为每一条消息分配一个全局ID。消费者监听到消息后获取全局ID，先查询这个ID是否存在数据库或缓存，不存在就存入消息，存在就丢弃消息。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis的应用</title>
      <link href="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-在项目中的应用"><a href="#Redis-在项目中的应用" class="headerlink" title="Redis 在项目中的应用"></a>Redis 在项目中的应用</h1><p>热点数据的缓存、限时业务( 验证码 )、计数器</p><h2 id="1、做缓存"><a href="#1、做缓存" class="headerlink" title="1、做缓存"></a>1、做缓存</h2><p><strong>删除缓存还是更新缓存</strong>：删除缓存。更新缓存有两个问题：在更新了数据库之后，但还没来得及更新缓存，此时用户访问的是脏数据；相比之下，删除缓存机制会将缓存删除，当下次访问时，从数据库查找最新的数据并更新缓存。此外，如果数据频繁更新，缓存也要频繁更新，只有最后一次更新才有效，这就导致性能开销，很多都是无效更新。</p><p><strong>先操作缓存，还是先操作数据库？</strong> 先操作数据库，再删除缓存。如果先删除缓存，再操作数据库，在多线程情况下，线程 A 删除缓存后，数据库更新很慢；在数据库未更新完成时，线程 B 趁虚而入，读取数据库的脏数据并写入缓存。而先更新数据库，再删除缓存，出现数据不一致的概率小。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240227211712815.png" alt="image-20240227211712815"></p><p>一般有两种情况：</p><ul><li>缓存中的数据或数据库中的数据被误删除了。</li><li>恶意攻击</li></ul><blockquote><p>设置空值</p></blockquote><p>解决方案：缓存 null 并设置空值。</p><p>缺点：可能造成短期的不一致。可以当插入一条数据时，主动将这条数据插入到缓存中覆盖之前的null。</p><blockquote><p>布隆过滤</p></blockquote><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>某个热点数据过期了，在这个数据缓存重建之前，有大量请求同时查询这个数据，这些请求就直接打到数据库上，给数据库带来巨大的冲击。</p><p>解决方案：1、互斥锁   2、设计逻辑过期</p><p><strong>互斥锁实现逻辑：</strong>先根据 key 在缓存中查找，找到直接返回。如果是空值，说明发生了缓存穿透，返回空。这里起初用的是自定义的锁：SETNX。只有当 key 不存在时才会成功，如下</p><pre><code class="highlight java"><span class="comment">//    private boolean tryLock(String key) &#123;</span><span class="comment">//        Boolean aBoolean = stringRedisTemplate.opsForValue().setIfAbsent(key, &quot;1&quot;, LOCK_SHOP_TTL, TimeUnit.SECONDS);</span><span class="comment">//        return BooleanUtil.isTrue(aBoolean);</span><span class="comment">//    &#125;</span><span class="comment">//    private void unLock(String key) &#123;</span><span class="comment">//        stringRedisTemplate.delete(key);</span><span class="comment">//    &#125;</span></code></pre><p>如果获取锁失败，休眠一段时间，重新查询。获取锁成功后，在数据库查询，如果未查到则发生了缓存穿透，插入空值。如果查到了则存入 redis，最后释放锁。</p><p><strong>互斥锁解决缓存击穿主要在于先让一个线程获取锁，将其他线程阻止在外，此线程在数据库查询一次后存入缓存，外面的线程就可以从缓存中取数据，不用都来访问数据库。</strong></p><p><strong>逻辑过期实现逻辑：</strong>缓存过期策略意思是在商品中添加一个逻辑过期时间字段，在查询之前就预加载到了缓存，如果没有查到，说明该商品不是活动商品。如果查到的话，将其转化为对应的 Bean 对象，判断其逻辑时间是否过期（缓存过期时间在当前时间之后则尚未过期），如果未过期直接返回这个对象；否则需要开启独立线程获取锁查询数据库，并重新写入缓存，而主线程直接返回旧的缓存。</p><p><strong>这样做是为了保证响应速度，缓存数据虽然可能稍微落后于数据库的最新数据，但是在大多数情况下，这个小小的延迟并不会影响系统的功能和用户的体验。逻辑过期一定要先进行数据预热，将我们热点数据加载到缓存中。</strong></p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>大量的缓存在同一时间失效或 redis 服务宕机，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</p><p>解决方案：</p><ul><li><p>避免将大量数据设置为同一个缓存时间（加个随机数）。</p></li><li><p>互斥锁</p></li></ul><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240507203026393.png" alt="image-20240507203026393"></p><h2 id="2、分布式锁"><a href="#2、分布式锁" class="headerlink" title="2、分布式锁"></a>2、分布式锁</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>SET 命令有个 NX 选项，用来实现分布式锁。当 key 不存在时，插入成功；存在则插入失败。</p><p>解锁时为了区分当前线程是否为获取锁的线程，需要先判断，再释放锁。这是两个操作，需要 Lua 脚本保证解锁的原子性。</p><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><blockquote><p>一开始判断逻辑与创建订单是放到一起的，且没有加锁。这样就会出现超卖。</p><p>使用乐观锁解决。</p></blockquote><p>为什么会发生超卖问题？多个线程在同时执行时，对库存的判断和扣减并不是原子性操作，可能导致同一时刻多个线程判断库存都是足够的，然后都执行了扣减库存的操作，从而导致超卖。</p><p>解决方案：</p><p>悲观锁：认为一定会有线程安全问题，每次操作数据库前都要获取锁。常见的悲观锁有：<code>synchronized</code>、<code>lock</code>。</p><p>乐观锁：认为不一定会有线程安全问题，因此不加锁，只是更新数据时判断有没有其他线程对数据做了修改。常见的有版本号、CAS。</p><p>CAS：不用额外对表加个版本号，用库存代替版本。首先读取当前的值，在执行 SQL 时，将要修改的字段值与读取的值进行比较，如果不同，说明这期间有其他线程修改了。说明有其他线程涉入修改，于是当前线程放弃修改。</p><p>但在项目中修改库存时，按理说只要库存大于 0 就可以减一，但在并发操作下用了 CAS 后，很多个请求都没有执行 SQL，为什么？ 举个例子：库存初始为 100，线程1和线程2先后查询到库存为 100，线程1先买，库存减一，此时为 99。线程2此时买，发现库存不为原来查询的 100，就不更新了。改进：只要库存大于0，就可以更改。</p><h3 id="一人一单"><a href="#一人一单" class="headerlink" title="一人一单"></a>一人一单</h3><blockquote><p>开始只是在判断逻辑中加了个订单的判断，但在并发情况下多个线程同时判断成立，于是就下了多次单。</p></blockquote><p>上面的超卖问题是针对单体项目的，也就是单个用户进行购买，但实际需求中是一个用户只能限购一单，如何实现呢？</p><p>起初是多加了个判断：判断当前用户是否在数据库表中有记录了，有说明已经下过单了，但这样还是会一个人下多个单，为什么？还是并发问题，多个线程可能同时判断当前用户未下过单，于是同时操作数据库减库存。我们需要的是判断和操作数据库是一个原子操作。</p><p>单体模式下的解决方案：使用悲观锁，锁的是用户的 id.toString().intern()，不能直接锁 id，每次得到 id 都是新的对象，intern() 表示从常量池中寻找与字符串值一致的对象，这样就能保证同一用户请求时，只有一个用户进入锁中。但这种方式锁住的是当前 JVM 中的对象，集群下有多个 JVM，因此我们需要分布式锁。</p><p>我们通过 nginx 的负载均衡启动 2 台服务器模拟，本地锁 synchronized 会失效，我们需要使用分布式锁。分布式锁的实现用 redis 的 setnx 实现，也就是我们自定义锁替换掉 synchronized。但还有几个问题，1、多个线程如何判断释放的锁是否是自己的呢？</p><p>这里可以给锁拼接上 uuid，增加锁标识的复杂性，释放锁时需要先判断锁存在，再删除锁。2、如果获取锁成功后发生了堵塞，锁超时释放了，此时有其他线程获取了锁，而之前的那个线程堵塞完成，又把锁释放了。</p><p>问题：判断锁后如果发生了堵塞，其他线程获得锁，堵塞完后之前的线程直接释放锁了。这是因为判断锁和释放锁中间的堵塞。</p><p>这里我们将判断锁和释放锁打包为 lua 脚本，具有原子性。</p><p>但我们自定义的锁总有缺陷，如锁不可重入、不可重试等，我们使用 Redssion 框架。</p><p> 最终优化：将库存判断、用户是否下单 这些逻辑判断写到一个 lua 脚本中，只有都通过了再使用消息队列 插入订单，执行库存减一。实现解耦合。</p><h3 id="Redission-原理"><a href="#Redission-原理" class="headerlink" title="Redission 原理"></a>Redission 原理</h3><p><strong>可重入锁</strong>：用 hash 结构存储   key：锁   field：线程标识   value：重入次数。</p><p><strong>锁重试：</strong>释放时间如果没有指定，则设置为看门狗（30s），执行 lua 脚本：如果当前线程第一次来，记录标识，锁重入次数为 1；如果已经存在锁标识了，那么锁重入次数加 1；否则返回剩余时间。这是一个异步的过程，函数结束后返回，如果得到 null，获取锁成功，否则计算剩余时间，如果小于 0，则剩余时间不够获取锁失败；否则等待一个订阅（其他线程释放锁的信号），得到订阅后才会再次获取锁，在等待过程中如果等待时间大于剩余时间，则取消订阅，返回 false。</p><p><strong>自动续约：</strong>获取锁成功后，判断是否设置了释放时间，没有的话默认是 -1，如果第一次来，添加个定时任务：10s 后更新有效期为 30s，永不过期。释放锁时才会取消。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240308205339316.png" alt="image-20240308205339316"></p><h2 id="3、lua脚本异步操作"><a href="#3、lua脚本异步操作" class="headerlink" title="3、lua脚本异步操作"></a>3、lua脚本异步操作</h2><p>之前的业务是判断库存后通过分布式锁实现一人一单，这是串行操作，效率不高，其实判断库存、一人一单与操作数据库可以隔离开，如果用户有资格下单，就可以返回订单号了，用户不需要等待数据库操作完成即可获得反馈。</p><p>此外，我们在保存优惠券时就可以把优惠券信息存入缓存，在查询用户是否有资格下单时，直接从缓存中查库存就好，并且将购买的用户写入缓存，避开了直接访问数据库。</p><h2 id="4、Sorted-Set-维护点赞排行榜"><a href="#4、Sorted-Set-维护点赞排行榜" class="headerlink" title="4、Sorted Set 维护点赞排行榜"></a>4、Sorted Set 维护点赞排行榜</h2><ul><li>在首页如何判断当前用户是否给某个博客点过赞？这是用 redis 实现的，用户点赞都放到了缓存中，为了实现点赞排行榜，使用的是 zset 数据结构。每次访问首页时，查询缓存中是否有用户点赞的缓存，有的话就设置 isLike 为 true，在前端就会高亮显示。</li><li></li></ul><h1 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h1><h2 id="数据结构的应用场景"><a href="#数据结构的应用场景" class="headerlink" title="数据结构的应用场景"></a>数据结构的应用场景</h2><p>1、String：存对象、分布式锁、计数器、验证码</p><p>2、hash：对象、购物车</p><p>3、List：存储热点数据</p><p>4、Set：点赞、共同关注</p><p>5、ZSet：排序，排行榜</p><p>hash和String存储对象：当只需要读取对象的某一个字段，String会将整个对象反序列化再读取，hash就很方便。</p><h2 id="Zset的底层如何实现"><a href="#Zset的底层如何实现" class="headerlink" title="Zset的底层如何实现"></a>Zset的底层如何实现</h2><p>使用 <strong>ziplist</strong>（压缩链表）和 <strong>skiplist</strong>（跳表）两种。</p><p>当保存的元素少于 128 个，且保存的所有元素都小于 64 字节 -&gt; 使用 ziplist。</p><ul><li><strong>ziplist</strong></li></ul><p>每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。压缩列表内的集合元素按分值从小到大的顺序进行排列。</p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240317150803917.png" alt="image-20240317150803917"></p><ul><li><h5 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h5></li></ul><p>skiplist 编码的有序集合对象使用 zet 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳表。</p><p><strong>跳表我们完全可以理解为在原始链表基础上，建立多级索引，通过多级索引检索定位将增删改查的时间复杂度变为O(log n)</strong></p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240317151640081.png" alt="image-20240317151640081"></p><p>为什么用跳表而不用平衡树、红黑树、B+ 树？</p><p>AVG 每次插入、删除之后要保证左右子数的平衡</p><p>B+ 树：</p><h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><ul><li><strong>AOF 日志</strong>：每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里；</li><li><strong>RDB 快照</strong>：将某一时刻的内存数据，以二进制的方式写入磁盘；</li><li><strong>混合持久化方式</strong>：Redis 4.0 新增的方式，集成了 AOF 和 RBD 的优点；</li></ul><h3 id="AOF-日志"><a href="#AOF-日志" class="headerlink" title="AOF 日志"></a>AOF 日志</h3><p>执行完一条写操作后，将写命令以追加的方式写入文件，然后Redis重启时就会读取这个文件目录的命令，逐一执行命令的方式来数据恢复。</p><h2 id="Redis-过期删除和内存淘汰"><a href="#Redis-过期删除和内存淘汰" class="headerlink" title="Redis 过期删除和内存淘汰"></a>Redis 过期删除和内存淘汰</h2><p>redis 使用的是惰性删除策略和定期删除策略。</p><blockquote><p>内存淘汰策略</p></blockquote><p>1、不进行淘汰，当内存满了直接返回错误</p><p>2、进行内存淘汰的策略，又分为 在设置了过期时间的数据中淘汰 和 在所有数据范围内淘汰。</p><p>在设置了过期时间的数据中淘汰：</p><h2 id="Redisson-原理"><a href="#Redisson-原理" class="headerlink" title="Redisson 原理"></a>Redisson 原理</h2><blockquote><p>可重入原理</p></blockquote><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240508215548502.png" alt="image-20240508215548502"></p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240509094208707.png" alt="image-20240509094208707"></p><p><img src="/2024/03/07/redis%E7%9A%84%E5%BA%94%E7%94%A8/image-20240509094500689.png" alt="image-20240509094500689"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis的应用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal在多线程下的应用</title>
      <link href="/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/03/07/ThreadLocal%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal-定义"><a href="#ThreadLocal-定义" class="headerlink" title="ThreadLocal 定义"></a>ThreadLocal 定义</h2><p>以空间换时间的方式解决多线程安全问题。当用ThreadLocal修饰变量时，会为每一个使用该变量的线程创建一个独立的变量副本，这样就能让各线程相互隔离，保证线程安全。</p><h2 id="四个主要方法"><a href="#四个主要方法" class="headerlink" title="四个主要方法"></a>四个主要方法</h2><p>get()、set()、remove()、initialValue()；在进行get之前，必须先set，否则会报空指针异常，如果想在get之前不需要调用set就能正常访问的话，必须重写initialValue()方法。如下</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadLocalCount = ThreadLocal.withInitial(() -&gt; <span class="number">0</span>);</code></pre><p>这意味着每个线程访问这个变量时都会得到一个初始值<code>0</code>。</p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>当多个线程使用被ThreadLocal修饰的变量时，每个线程都会有一个自己的<code>ThreadLocalMap</code>，ThreadLocalMap有一个Entry数组，数组中的每个<code>Entry</code>存储了一个<code>ThreadLocal</code>对象（作为键）和与对象关联的私有值（作为值）。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2024/02/23/MybatisPlus/"/>
      <url>/2024/02/23/MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-查询"><a href="#MyBatis-查询" class="headerlink" title="MyBatis 查询"></a>MyBatis 查询</h2><p>1、创建表与实体类之间的映射文件 xml。里面编写 SQL 语句</p><p>2、创建和映射文件对应的接口 Mapper。</p><p>3、通过 SqlSessionFactory 获取 SqlSession。</p><h2 id="MybatisPlus-快速入门"><a href="#MybatisPlus-快速入门" class="headerlink" title="MybatisPlus 快速入门"></a>MybatisPlus 快速入门</h2><p>1、pom.xml 中引入 MybatisPlus 依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre><p>2、创建实体类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、创建 Mapper 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;&#125;</code></pre><p>4、启动类需要添加 @MapperScan(“mapper所在的包”)</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> org.junit.jupiter.api.Test;<span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="keyword">import</span> java.util.List;<span class="meta">@SpringBootTest</span><span class="meta">@MapperScan(&quot;com.ai.mybatisplus.mapper&quot;)</span><span class="keyword">class</span> <span class="title class_">StudentMapperTest</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> StudentMapper studentMapper;    <span class="meta">@Test</span>    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;        studentMapper.selectList(<span class="literal">null</span>).forEach(System.out::println);    &#125;&#125;</code></pre><p>5、配置</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span><span class="attr">mybatis-plus:</span>  <span class="attr">configuration:</span>    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></code></pre><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><blockquote><p>@TableName</p></blockquote><p>映射数据库的表名</p><pre><code class="highlight java"><span class="meta">@Data</span><span class="meta">@TableName(value = &quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><blockquote><p>@TableId  主键映射</p></blockquote><p>type 设置主键类型，主键的生成策略</p><pre><code class="highlight java">AUTO(<span class="number">0</span>),数据库自增NONE(<span class="number">1</span>),MP set 主键，雪花算法实现INPUT(<span class="number">2</span>),需要开发者手动赋值ASSIGN_ID(<span class="number">3</span>),MP 分配 ID：Long、Integer、String<span class="title function_">ASSIGN_UUID</span><span class="params">(<span class="number">4</span>)</span>;分配一个 uuid：String</code></pre><blockquote><p>@TableField  其他字段映射</p></blockquote><p>exist 表示是否为数据库字段，如果实体类中的成员变量在数据库中没有对应字段，则可以使用 exist，VO、DTO。</p><p>select 表示是否查询该字段</p><p>fill 表示是否自动化填充，将对象存入数据库时，由 MP 自动给某些字段赋值，例如订单 create_time, update_time。</p><ul><li>如果数据库字段名是 create_time，则在 JavaBean 中 变量名为 createTime，MP 会自动二者进行绑定。</li></ul><p>1、给表添加创建、更新时间</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.*;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="meta">@TableName(value = &quot;student&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="meta">@TableId(type = IdType.AUTO)</span>    <span class="keyword">private</span> Long id;    <span class="meta">@TableField(select = false)</span>    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;    <span class="meta">@TableField(fill = FieldFill.INSERT)</span>    <span class="keyword">private</span> Date createTime;    <span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span>    <span class="keyword">private</span> Date updateTime;    <span class="meta">@TableField(exist = false)</span>    <span class="keyword">private</span> String gender;&#125;</code></pre><p>2、创建自动填充的处理器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.handler;<span class="keyword">import</span> com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;<span class="keyword">import</span> org.apache.ibatis.reflection.MetaObject;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Date;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), metaObject);    &#125;&#125;</code></pre><p>3、测试</p><pre><code class="highlight java"><span class="meta">@Test</span><span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    student.setName(<span class="string">&quot;奥尼尔&quot;</span>);    student.setScore(<span class="number">99d</span>);    student.setBirthday(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;2024-02-23&quot;</span>));    studentMapper.insert(student);&#125;<span class="meta">@Test</span><span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectById(<span class="string">&quot;1760860280444715012&quot;</span>);    student.setScore(<span class="number">80d</span>);    studentMapper.updateById(student);</code></pre><blockquote><p>@Version</p></blockquote><p>标记乐观锁，通过 version 字段来保证数据的安全性，当修改数据时，会以 version 为条件，当条件成立才修改成功。</p><p>线程 1：update … set version &#x3D; 2 where version &#x3D; 1</p><p>线程 2：update … set version &#x3D; 2 where version &#x3D; 1</p><p>代码测试：</p><p>1、数据库表添加 version 字段，默认值为1</p><p>2、实体类添加 version 成员变量，并且添加 @Version</p><p>3、注册配置类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.config;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());        <span class="keyword">return</span> mybatisPlusInterceptor;    &#125;&#125;</code></pre><blockquote><p>@EnumValue</p></blockquote><p>通用枚举类注解，将数据库字段映射成实体类的枚举成员变量</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.EnumValue;<span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumStatus</span> &#123;    WORK(<span class="number">1</span>, <span class="string">&quot;上班&quot;</span>),    REST(<span class="number">0</span>, <span class="string">&quot;休息&quot;</span>);    <span class="meta">@EnumValue</span>    <span class="keyword">private</span> Integer code;    <span class="keyword">private</span> String msg;    EnumStatus(Integer code, String msg) &#123;        <span class="built_in">this</span>.code = code;        <span class="built_in">this</span>.msg = msg;    &#125;&#125;</code></pre><p>在实体类添加字段</p><pre><code class="highlight java"><span class="keyword">private</span> EnumStatus status;</code></pre><p>application.yml</p><blockquote></blockquote><pre><code class="highlight yml"><span class="attr">mybatis-plus:</span>  <span class="attr">configuration:</span>    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span>  <span class="attr">type-enums-package:</span> <span class="string">com.ai.mybatisplus.enums</span></code></pre><blockquote><p>@TableLogic</p></blockquote><p>映射逻辑删除</p><p>1、数据表添加 deleted 字段</p><p>2、实体类添加注解</p><pre><code class="highlight java"><span class="meta">@TableLogic</span><span class="keyword">private</span> Integer deleted;</code></pre><p>3、application.yml 添加配置</p><pre><code class="highlight yml"><span class="attr">global-config:</span>  <span class="attr">db-config:</span>    <span class="attr">logic-delete-value:</span> <span class="number">1</span>    <span class="attr">logic-not-delete-value:</span> <span class="number">0</span></code></pre><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><pre><code class="highlight java"><span class="comment">//        studentMapper.selectBatchIds(Arrays.asList(7, 8)).forEach(System.out::println);</span>        <span class="comment">// Map 只能做等值判断，逻辑判断用 Wrapper</span><span class="comment">//        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><span class="comment">//        map.put(&quot;id&quot;, 7);</span><span class="comment">//        studentMapper.selectByMap(map);</span>        <span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();        wrapper.eq(<span class="string">&quot;id&quot;</span>, <span class="number">3</span>);<span class="comment">//        System.out.println(studentMapper.selectCount(wrapper));</span>        <span class="comment">// 将查询的结果封装到Map中</span><span class="comment">//        studentMapper.selectMaps(wrapper).forEach(System.out::println);</span>        <span class="comment">// 分页查询</span><span class="comment">//        Page&lt;Student&gt; page = new Page&lt;&gt;(1, 2);</span><span class="comment">//        Page&lt;Student&gt; result = studentMapper.selectPage(page, null);</span><span class="comment">//        System.out.println(result.getSize());</span><span class="comment">//        System.out.println(result.getTotal());</span><span class="comment">//        result.getRecords().forEach(System.out::println);</span><span class="comment">//        Page&lt;Map&lt;String, Object&gt;&gt; page = new Page&lt;&gt;(1, 2);</span><span class="comment">//        Page&lt;Map&lt;String, Object&gt;&gt; result = studentMapper.selectMapsPage(page, null);</span><span class="comment">//        result.getRecords().forEach(System.out::println);</span>        <span class="comment">// 拿到主键</span><span class="comment">//        studentMapper.selectObjs(null).forEach(System.out::println);</span>        <span class="comment">// 查询一条数据</span>        System.out.println(studentMapper.selectOne(wrapper));</code></pre><ul><li>分页查询</li></ul><p>1、添加分页拦截器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.config;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.OptimisticLockerInnerInterceptor;<span class="keyword">import</span> com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;<span class="keyword">import</span> org.springframework.context.annotation.Bean;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="meta">@Configuration</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisPlusConfig</span> &#123;    <span class="meta">@Bean</span>    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span> &#123;        <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();        <span class="comment">// 乐观锁</span>        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());        <span class="comment">// 分页</span>        mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());        <span class="keyword">return</span> mybatisPlusInterceptor;    &#125;&#125;</code></pre><p>2、测试</p><pre><code class="highlight java"><span class="comment">// 分页查询</span>Page&lt;Student&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>&lt;&gt;(<span class="number">1</span>, <span class="number">2</span>);Page&lt;Student&gt; result = studentMapper.selectPage(page, <span class="literal">null</span>);System.out.println(result.getSize());System.out.println(result.getTotal());result.getRecords().forEach(System.out::println);</code></pre><h2 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h2><pre><code class="highlight java"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();student.setName(<span class="string">&quot;奥尼尔&quot;</span>);student.setScore(<span class="number">99d</span>);student.setBirthday(<span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>).parse(<span class="string">&quot;2024-02-23&quot;</span>));studentMapper.insert(student);</code></pre><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><pre><code class="highlight java"><span class="comment">//        studentMapper.deleteById(4L);</span>        <span class="comment">//        HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();</span><span class="comment">//        map.put(&quot;id&quot;, 4);</span><span class="comment">//        studentMapper.deleteByMap(map);</span></code></pre><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><pre><code class="highlight java"><span class="comment">//        Student student = studentMapper.selectById(&quot;4&quot;);</span><span class="comment">//        student.setName(&quot;麻子&quot;);</span><span class="comment">//        studentMapper.updateById(student);</span>        QueryWrapper&lt;Student&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();        wrapper.eq(<span class="string">&quot;score&quot;</span>, <span class="number">90</span>);        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> studentMapper.selectById(<span class="number">1</span>);        student.setScore(<span class="number">96d</span>);        studentMapper.update(student, wrapper);</code></pre><h2 id="自定义SQL、多表关联"><a href="#自定义SQL、多表关联" class="headerlink" title="自定义SQL、多表关联"></a>自定义SQL、多表关联</h2><p>productVo:  将两个表的信息整合到 vo 里，由于 vo 不能对应数据库的表，因此不能使用 @FieldValue() 等注解。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.entity;<span class="keyword">import</span> com.baomidou.mybatisplus.annotation.TableField;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductVo</span> &#123;    <span class="keyword">private</span> Integer category;    <span class="keyword">private</span> Integer count;    <span class="keyword">private</span> String description;    <span class="keyword">private</span> Long studentId;    <span class="keyword">private</span> String studentName;&#125;</code></pre><p>studentMapper  添加自定义 SQL 语句，多表关联。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.mybatisplus.mapper;<span class="keyword">import</span> com.ai.mybatisplus.entity.ProductVo;<span class="keyword">import</span> com.ai.mybatisplus.entity.Student;<span class="keyword">import</span> com.baomidou.mybatisplus.core.mapper.BaseMapper;<span class="keyword">import</span> org.apache.ibatis.annotations.Select;<span class="keyword">import</span> java.util.List;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentMapper</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Student&gt; &#123;    <span class="meta">@Select(&quot;select p.*, name studentName from product p, student s where p.student_id = s.id and s.id = #&#123;id&#125;&quot;)</span>    List&lt;ProductVo&gt; <span class="title function_">productList</span><span class="params">(Integer id)</span>;&#125;</code></pre><h2 id="MyBatisPlus-自动生成"><a href="#MyBatisPlus-自动生成" class="headerlink" title="MyBatisPlus 自动生成"></a>MyBatisPlus 自动生成</h2><p>根据数据表自动生成实体类、Mapper、Service、ServiceImpl、Controller</p><p>1、pom.xml 导入MyBatis Plus Generator</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.velocity<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>velocity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础小记</title>
      <link href="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><p>1、一个线程只能属于一个进程，一个进程可以有多个线程。</p><p>2、资源分配给线程，进程不拥有资源，而是共享进程的资源。</p><p>3、处理机分给线程，在处理机运行的是线程。</p><h2 id="Java-包装类"><a href="#Java-包装类" class="headerlink" title="Java 包装类"></a>Java 包装类</h2><p>Integer、Boolean、Byte、Character、Short、Long 都有缓存机制，因此两个变量使用 &#x3D;&#x3D; 做比较时，如果在缓存中，是不会比较地址的。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是指不同的子类对同一种行为有不同的表现形式。多态包括编译时多态（重载）和运行时多态（重写）。重载：方法名相同，参数列表不同（参数个数、类型、顺序），返回值、访问修饰符也可以不同。</p><h3 id="String-的不可变"><a href="#String-的不可变" class="headerlink" title="String 的不可变"></a>String 的不可变</h3><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173405251.png" alt="image-20240222173405251"></p><p>修改 s 变量时，不在原来的地址上修改，而是指向新的引用地址。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222173659994.png" alt="image-20240222173659994"></p><p>value 用 final 修饰，指的是 value 变量的引用不能更改，不能指向其他地址。</p><p>但数组本身是可以修改值的，这并不会对其地址有影响。</p><ul><li>设计成不可变，可以使用字符串常量池。</li></ul><h3 id="String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？"></a>String s1 &#x3D; new String(“abc”); 这句话创建了几个字符串对象？</h3><p>1 个或 2 个。一、如果字符串常量池中没有字符串对象 “abc” 的引用，则它会在堆上创建两个字符串对象，其中一个字符串对象的引用会被保存在字符串常量池中。</p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240222170700469.png" alt="image-20240222170700469"></p><p>2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。</p><blockquote><p>对于 String &#x3D; “abc”，如果常量池中有 “abc” 字符串对象，就直接指向它；否则会在常量池中创建一个 “abc” 字符串对象。</p></blockquote><h3 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><p>三种方式：重写 clone() 方法、<strong>通过序列化实现</strong>、<strong>利用反射方式实现</strong></p><h2 id="可以不重写-hashcode-吗？"><a href="#可以不重写-hashcode-吗？" class="headerlink" title="可以不重写 hashcode 吗？"></a>可以不重写 hashcode 吗？</h2><p>不可以，如果两个对象通过 equals 判断是相等的，但哈希码不同，当用作哈希表的键时，可能不能正常工作。例如，当向 HashSet 中添加两个逻辑上相等的对象时，本应该只有一个被存储，但因为哈希码不同，被存储了两次。这就违反了 Set 集合中唯一性的约束。</p><h2 id="String-类型的变量和常量用-“-”-运算符发生了什么？"><a href="#String-类型的变量和常量用-“-”-运算符发生了什么？" class="headerlink" title="String 类型的变量和常量用 “+” 运算符发生了什么？"></a>String 类型的变量和常量用 “+” 运算符发生了什么？</h2><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span>;<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;str&quot;</span> + <span class="string">&quot;ing&quot;</span>;<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> str1 + str2;<span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;System.out.println(str3 == str4);<span class="comment">//false</span>System.out.println(str3 == str5);<span class="comment">//true</span>System.out.println(str4 == str5);<span class="comment">//false</span></code></pre><ul><li><p>对于 String str3 &#x3D; “str” + “ing”;<code>编译器会优化成</code>String str3 &#x3D; “string”;</p></li><li><p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p></li></ul><pre><code class="highlight java"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(str1).append(str2).toString();</code></pre><p>String str &#x3D; “abc” + new String(“def”); 创建了几个对象？（假设常量池中没有缓存）</p><p>这会被优化为 </p><pre><code class="highlight java"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;def&quot;</span>);<span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(<span class="string">&quot;abc&quot;</span>).append(s).toString();</code></pre><p>创建了 5 个对象  new StringBuilder() -&gt; “abc” -&gt; “def” -&gt; new String() -&gt; toString()</p><h2 id="final-可以加在哪里，有什么作用"><a href="#final-可以加在哪里，有什么作用" class="headerlink" title="final 可以加在哪里，有什么作用"></a>final 可以加在哪里，有什么作用</h2><p>类：这个类不能被继承，<code>final</code> 类中的所有成员方法都隐式地指定为 <code>final</code>，但是字段不自动成为 <code>final</code>。</p><p>方法：这个方法不能被子类覆盖或重写。</p><p>变量：该变量的值一旦被初始化之后就不能被改变。对于基本数据类型，它的值不能被改变。对于引用类型，它的引用不能改变，但对引用的对象本身是可以修改的。</p><h2 id="JMM-内存模型"><a href="#JMM-内存模型" class="headerlink" title="JMM 内存模型"></a>JMM 内存模型</h2><p>每个线程都有一个私有的本地内存，线程可以把变量保存 <strong>本地内存</strong> （比如机器的寄存器）中，而不是直接在主存中进行读写。如果线程间需要通信，必须通过主内存来进行。<img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240313145809511.png" alt="image-20240313145809511"></p><h2 id="Cookies-和-Session-的区别"><a href="#Cookies-和-Session-的区别" class="headerlink" title="Cookies 和 Session 的区别"></a>Cookies 和 Session 的区别</h2><p>1、当用户第一次登录成功后，服务器会创建一个 Session，并为这个 Session 创建唯一的 SessionID。Session 保存在服务器端，保存了用户的状态信息。</p><p>2、服务器将这个唯一的 SessionID 存储到一个 Cookies 中，并通过 HTTP 响应将该 Cookies 发生给用户的 Web 浏览器。</p><p>3、用户的浏览器会保存这个 Cookies，后续请求都会携带此 Cookies 发送回服务器。</p><p>4、服务器会读取 Cookies 中的 SessionID，通过它找到 Session 数据，里面包含了用户的状态信息，如登录凭证、购物车内存等。</p><p>5、当用户退出登录或 Session 过期后，服务器会销毁 Session 数据。</p><h2 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h2><h3 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep() 和 wait()"></a>sleep() 和 wait()</h3><p>sleep() 是 Thread 类的静态方法</p><p>wait() 是 Object 类的方法，直到其他线程调用相同对象的 notify() 方法。wait() 方法通常与 synchronized 关键字一起使用，表示释放锁，从而允许其他线程获取锁。</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="线程池的7个参数和工作原理"><a href="#线程池的7个参数和工作原理" class="headerlink" title="线程池的7个参数和工作原理"></a>线程池的7个参数和工作原理</h3><pre><code class="highlight java"><span class="type">int</span> corePoolSize,    <span class="comment">// 核心线程数，创建后不会被回收</span><span class="type">int</span> maximumPoolSize,   <span class="comment">// 最大线程数，当核心线程数已满、最大线程数未满，就创建一个新线程</span><span class="type">long</span> keepAliveTime,  <span class="comment">// 空闲线程存活时间，当可被回收的线程大于keepAliveTime被回收</span>TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, <span class="comment">// 工作队列，当提交的任务超过核心线程数，再提交的任务就放到工作队列</span>ThreadFactory threadFactory,  <span class="comment">// 线程工厂，可以设定线程名、线程编号等</span>RejectedExecutionHandler handler <span class="comment">// 拒绝策略</span></code></pre><h3 id="怎么关闭线程池？"><a href="#怎么关闭线程池？" class="headerlink" title="怎么关闭线程池？"></a>怎么关闭线程池？</h3><p>shutdown()：会在当前运行的线程执行完任务后关闭它们。</p><p>shutdownNow()：会试图停止所有正在执行的任务，并返回还没有开始执行的任务。并不保证每个任务都能成功停止，因为这个方法本质是对线程池每个线程调用了 interrupt() 方法来尝试取消线程的执行，但中断一个线程是非强制性的，也就是它只是给线程发送了一个取消的信号，而线程能否响应，怎样响应是取决于线程本身的。</p><h2 id="Java-线程通信的主要方式"><a href="#Java-线程通信的主要方式" class="headerlink" title="Java 线程通信的主要方式"></a>Java 线程通信的主要方式</h2><p><strong>volatile关键字</strong>：</p><ul><li>所有volatile修饰的变量一旦被某个线程更改，必须立即刷新到主内存</li><li>所有volatile修饰的变量在使用之前必须重新读取主内存的值</li></ul><p><strong>等待&#x2F;通知机制</strong>：等待通知机制是基于wait和notify方法来实现的，在一个线程内调用该线程锁对象的wait方法，线程将进入等待队列进行等待直到被通知或者被唤醒。</p><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h3 id="HashMap-和-HashTable-的区别"><a href="#HashMap-和-HashTable-的区别" class="headerlink" title="HashMap 和 HashTable 的区别"></a>HashMap 和 HashTable 的区别</h3><ul><li>安全性：HashMap 是线程不安全的，HashTable 是线程安全的</li><li>HashMap 可以使用null作为key，Hashtable则不允许null作为key</li><li>扩容：HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。HashMap扩容时是当前容量翻倍即:<code>capacity</code> *<code>2</code><strong>，Hashtable扩容时是容量翻倍+1即:</strong><code>capacity</code>* <code>(2+1)</code>。</li></ul><h3 id="HashMap-1-7-和-1-8"><a href="#HashMap-1-7-和-1-8" class="headerlink" title="HashMap 1.7 和 1.8"></a>HashMap 1.7 和 1.8</h3><p>1.7 底层是数组加链表，1.8底层是数组+链表+红黑树。</p><p>当 put 一个 Node 时，会计算 key 的 hashcode， 再通过将 hashcode 与 (n - 1) 进行与运算，有两种情况：</p><p>1、数组索引的元素是空的，这种情况很简单，直接将元素放进去就好了。</p><p>2、已经有元素占据了索引位置，这种情况下我们需要判断一下该位置的元素和当前元素是否相等，使用equals来比较。<strong>如果两者相等则直接覆盖</strong>，<strong>如果不等则在原元素下面使用链表的结构存储该元素</strong></p><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240320110614657.png" alt="image-20240320110614657"></p><p>当链表的元素个数达到8并且数组长度超过64的时候使用链表存储就转变成了使用红黑树存储。</p><p>HashMap中有两个重要的参数：<strong>初始容量大小和加载因子</strong>。初始容量大小为 16，默认加载因子为 0.75。</p><h3 id="为什么加载因子设置为-0-75？"><a href="#为什么加载因子设置为-0-75？" class="headerlink" title="为什么加载因子设置为 0.75？"></a>为什么加载因子设置为 0.75？</h3><p>往哈希表中放数据类似骰硬币，01分布。做个假设：扔 k 次骰子，没有一次是相同的概率。</p><p>二项分布 Cn^0 </p><h3 id="为什么-HashMap-不安全"><a href="#为什么-HashMap-不安全" class="headerlink" title="为什么 HashMap 不安全?"></a>为什么 HashMap 不安全?</h3><ul><li>多线程下扩容会死循环</li><li>多线程下 put 会导致元素丢失</li><li>put 和 get 并发时会导致 get 到 null</li></ul><p>CopyonWriteArraylist：读写、读读都不互斥，只有写写互斥。多个线程可以同时读。</p><pre><code class="highlight java"><span class="comment">// 插入元素到 CopyOnWriteArrayList 的尾部</span><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;    <span class="comment">// 加锁</span>    lock.lock();    <span class="keyword">try</span> &#123;        <span class="comment">// 获取原来的数组</span>        Object[] elements = getArray();        <span class="comment">// 原来数组的长度</span>        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;        <span class="comment">// 创建一个长度+1的新数组，并将原来数组的元素复制给新数组</span>        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);        <span class="comment">// 元素放在新数组末尾</span>        newElements[len] = e;        <span class="comment">// array指向新数组</span>        setArray(newElements);        <span class="keyword">return</span> <span class="literal">true</span>;    &#125; <span class="keyword">finally</span> &#123;        <span class="comment">// 解锁</span>        lock.unlock();    &#125;&#125;</code></pre><p>也就是对数组进行增加元素时，会复制出一份新的数组，并将元素加到新的数组。</p><p>对数组进行修改时，会分段复制，index 前的和 index 后的分别复制到新数组。</p><h1 id="Spring-框架"><a href="#Spring-框架" class="headerlink" title="Spring 框架"></a>Spring 框架</h1><h2 id="介绍下-Spring-IOC-和-Spring-Aop"><a href="#介绍下-Spring-IOC-和-Spring-Aop" class="headerlink" title="介绍下 Spring IOC 和 Spring Aop"></a>介绍下 Spring IOC 和 Spring Aop</h2><p>ioc 是控制反转，ioc 可以看作一个对象工厂，我们都把该对象交给工厂，工厂管理这些对象的创建以及依赖关系。</p><p>aop 是面向切面编程，当类中的方法有大量冗余的且与业务无关的代码，我们可以将它们通过注解方式抽离出来，让开发者只关心业务逻辑。</p><p>Spring AOP 的实现原理是基于<strong>动态代理</strong>和<strong>字节码操作</strong>实现的。在编译时，Spring 会使用 AspectJ 编译器将切面代码编译成字节码文件。在运行时，Spring 会使用 <strong>Java 动态代理或 CGLIB 代理</strong>生成代理类。代理类会在目标对象方法执行前后插入切面代码，从而实现 AOP。</p><p>Spring AOP 可以使用两种代理方式：JDK动态代理和 CGLIB 代理。如果目标对象实现了至少一个接口，则使用JDK动态代理；否则，使用 CGLIB 代理。</p><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240326162005596.png" alt="image-20240326162005596"></p><ul><li><p>实例化、属性赋值、初始化、销毁。</p></li><li><p>初始化的具体操作：Aware 接口的依赖注入、BeanPostProcessor 在初始化前后的处理以及InitializingBean 和 init-method 的初始化操作。</p></li><li><p>销毁的具体操作，有注册相关销毁回调接口，最后通过DisposableBean 和 destory-method 进行销毁。</p></li></ul><h2 id="Bean-会被垃圾回收吗"><a href="#Bean-会被垃圾回收吗" class="headerlink" title="Bean 会被垃圾回收吗"></a>Bean 会被垃圾回收吗</h2><p><strong>Bean没有被其他Bean引用，且容器也没有任何引用指向它时</strong>，会变成一个不可达对象，就会被垃圾回收。但在 Spring 中的 Bean 是单例的，一直存活在应用程序的整个生命周期中，所以除非应用程序结束或 Spring 容器被销毁，否则是不会被 GC 的。</p><h2 id="SpringBootApplication-注解"><a href="#SpringBootApplication-注解" class="headerlink" title="@SpringBootApplication 注解"></a>@SpringBootApplication 注解</h2><p>@Configuration：允许在 Spring 上下文中注册额外的 bean 或导入其他配置类</p><p>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</p><p>@ComponentScan：扫描被<code>@Component</code> (<code>@Repository</code>,<code>@Service</code>,<code>@Controller</code>)注解的 bean，注解默认会扫描该类所在的包下所有的类。</p><h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h2><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240326105137278.png" alt="image-20240326105137278"></p><p>Spring Boot 通过 <strong><code>@EnableAutoConfiguration</code></strong> 开启自动装配，通过 <strong><code>SpringFactoriesLoader</code></strong> 最终加载 <strong><code>META-INF/spring.factories</code></strong> 中的自动配置类实现自动装配，自动配置类其实就是通过 <strong><code>@Conditional</code></strong> 按需加载的配置类，想要其生效必须引入 <strong><code>spring-boot-starter-xxx</code></strong> 包实现起步依赖。</p><h2 id="Spring-常见的一些模块"><a href="#Spring-常见的一些模块" class="headerlink" title="Spring 常见的一些模块"></a>Spring 常见的一些模块</h2><p>Spring Core：供 ioc 容器</p><p>Spring AOP</p><p>Spring DAO：JDBC的抽象层</p><p>Spring ORM：实体关系映射</p><p>Spring Web</p><p>Spring Web MVC</p><h4 id="Spring-Test：单元测试"><a href="#Spring-Test：单元测试" class="headerlink" title="Spring Test：单元测试"></a>Spring Test：单元测试</h4><h2 id="动态获取spring容器里面的bean"><a href="#动态获取spring容器里面的bean" class="headerlink" title="动态获取spring容器里面的bean"></a>动态获取spring容器里面的bean</h2><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);</code></pre><h2 id="Autowired-和-Resource"><a href="#Autowired-和-Resource" class="headerlink" title="@Autowired 和 @Resource"></a>@Autowired 和 @Resource</h2><p>一个按类型，一个按名称进行装配。</p><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p><img src="/2024/02/22/Java%E5%9F%BA%E7%A1%80%E5%B0%8F%E8%AE%B0/image-20240325135256785.png" alt="image-20240325135256785"></p><p>springmvc 流程：</p><p>1、客户端发起请求，Servlet会根据根据请求的路径进行解析，DispatchServlet 拦截请求。</p><p>2、DispatchServlet 调用 HandlerMapping，去查找对应的 handler (也就是 controller)。</p><p>3、DispatchServlet 调用 HanderAdapter 执行 handler。</p><p>4、handler 执行完毕后返回 ModelAndView，视图解析器 ViewResolver 会查找实际的 view，DispatchServlet 会把 model 渲染到 view 上。</p><p>5、把 view 返回给浏览器。</p><h2 id="过滤器-和-拦截器"><a href="#过滤器-和-拦截器" class="headerlink" title="过滤器 和 拦截器"></a>过滤器 和 拦截器</h2><ul><li>调用时机：Filter 是在进入容器后，在 servlet 之前进行预处理，结束是在 servlet 处理完后。Interceptor 是在进入 servlet 后，在进入 controller 之前预处理的，在controller中的方法执行完后返回 ModelAndView 后请求结束。</li><li>Filter 一般用于字符编码和 cors 跨域问题，Interceptor 一般作用于业务逻辑的处理，如用户权限等。</li></ul><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{} 和 ${} 的区别"></a>#{} 和 ${} 的区别</h2><p>#{} 方式是先用占位符代替参数将SQL语句先进行预编译，再将参数中的内容替换进来。由于SQL语句已经被预编译过，其SQL意图将无法通过非法的参数内容实现更改，其参数中的内容，无法变为SQL命令的一部分。</p><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="join-和-left-join"><a href="#join-和-left-join" class="headerlink" title="join 和 left  join"></a>join 和 left  join</h2><p>JOIN：返回两个表中都有匹配的行</p><p>left JOIN：返回左表的所有行，如果在右表没有为 null。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试常见知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot小记</title>
      <link href="/2024/02/21/SpringBoot%E5%B0%8F%E8%AE%B0/"/>
      <url>/2024/02/21/SpringBoot%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>1、在 Controller 中注入 Repository 的接口：</p><pre><code class="highlight java"><span class="meta">@Autowired</span><span class="keyword">private</span> StudentRepository studentRepository;</code></pre><p>注意在 studentRepositoryImpl 中添加 @Repository 注解。</p><p>2、@RequestBody 接收一个 JSON 格式的数据，可以用 postman 发送 JSON 格式数据，但如果前端是 JSP，使用的是 <code>application/x-www-form-urlencoded</code> 或者 <code>multipart/form-data</code>，则前端不需要添加注解。</p><pre><code class="highlight java"><span class="meta">@PostMapping(&quot;/save&quot;)</span><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;    studentRepository.saveOrUpdate(student);&#125;</code></pre><h2 id="SpringBoot-整合-Mybatis"><a href="#SpringBoot-整合-Mybatis" class="headerlink" title="SpringBoot 整合 Mybatis"></a>SpringBoot 整合 Mybatis</h2><p>1、建表</p><pre><code class="highlight sql"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> student(id <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY auto_increment,name <span class="type">VARCHAR</span>(<span class="number">11</span>),score <span class="keyword">DOUBLE</span>,birthday <span class="type">DATE</span>)</code></pre><p>2、创建实体类</p><p>3、创建 StudentRepository 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.repository;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> &#123;    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Student student)</span>;    <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Student student)</span>;    <span class="keyword">void</span> <span class="title function_">findAll</span><span class="params">()</span>;    <span class="keyword">void</span> <span class="title function_">findById</span><span class="params">(Long id)</span>;&#125;</code></pre><p>4、创建 Mapper 接口</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.repository.StudentRepository&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        select * from student    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span>        select * from student where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">select</span>&gt;</span>    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        insert into student(name, score, birthday) values (#&#123;name&#125;, #&#123;score&#125;, #&#123;birthday&#125;)    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span>    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span>        update student set name = #&#123;name&#125;, score = #&#123;score&#125;, birthday = #&#123;birthday&#125; where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">update</span>&gt;</span>    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Long&quot;</span>&gt;</span>        delete from student where id = #&#123;id&#125;    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></code></pre><p>6、创建 StudentHandler，注入 StudentRepository</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> com.ai.repository.StudentRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    StudentRepository studentRepository;    <span class="meta">@PostMapping(&quot;/add&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        studentRepository.add(student);    &#125;    <span class="meta">@DeleteMapping(&quot;/deleteById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> &#123;        studentRepository.deleteById(id);    &#125;    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span>    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> studentRepository.findAll();    &#125;    <span class="meta">@GetMapping(&quot;/findById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="keyword">return</span> studentRepository.findById(id);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        studentRepository.update(student);    &#125;&#125;</code></pre><p>7、创建配置文件 yml</p><pre><code class="highlight yaml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span><span class="attr">mybatis:</span>  <span class="attr">mapper-locations:</span> <span class="string">classpath:/mapping/*.xml</span>  <span class="attr">type-aliases-package:</span> <span class="string">com.ai.entity</span></code></pre><p>8、创建启动类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai;<span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;<span class="keyword">import</span> org.springframework.boot.SpringApplication;<span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="meta">@SpringBootApplication</span><span class="meta">@MapperScan(&quot;com.ai.repository&quot;)</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span>&#123;    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">( String[] args )</span>    &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;</code></pre><h2 id="SpringBoot-整合-Spring-Data-JPA"><a href="#SpringBoot-整合-Spring-Data-JPA" class="headerlink" title="SpringBoot 整合 Spring Data JPA"></a>SpringBoot 整合 Spring Data JPA</h2><p>1、添加依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-jpa<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>      <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、实体类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> javax.persistence.*;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="meta">@Entity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="meta">@Id</span>    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>    <span class="keyword">private</span> Long id;    <span class="meta">@Column</span>    <span class="keyword">private</span> String name;    <span class="meta">@Column</span>    <span class="keyword">private</span> Double score;    <span class="meta">@Column</span>    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、创建 StudentRepository 接口</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.repository;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;<span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentRepository</span> <span class="keyword">extends</span> <span class="title class_">JpaRepository</span>&lt;Student, Long&gt; &#123;&#125;</code></pre><p>4、创建 StudentHandler，注入 StudentRepository</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> com.ai.repository.StudentRepository;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.web.bind.annotation.*;<span class="keyword">import</span> java.util.List;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    StudentRepository studentRepository;    <span class="meta">@GetMapping(&quot;/findAll&quot;)</span>    <span class="keyword">public</span> List&lt;Student&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;        <span class="keyword">return</span> studentRepository.findAll();    &#125;    <span class="meta">@GetMapping(&quot;findById/&#123;id&#125;&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;        <span class="keyword">return</span> studentRepository.findById(id).get();    &#125;    <span class="meta">@PostMapping(&quot;/save&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">save</span><span class="params">(Student student)</span> &#123;        <span class="keyword">return</span> studentRepository.save(student);    &#125;    <span class="meta">@PutMapping(&quot;/update&quot;)</span>    <span class="keyword">public</span> Student <span class="title function_">update</span><span class="params">(Student student)</span> &#123;        <span class="keyword">return</span> studentRepository.save(student);    &#125;    <span class="meta">@DeleteMapping(&quot;/delete&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Long id)</span> &#123;        studentRepository.deleteById(id);    &#125;&#125;</code></pre><p>5、配置文件</p><pre><code class="highlight yaml"><span class="attr">spring:</span>  <span class="attr">datasource:</span>    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306?mbtest?useUnicode=true&amp;characterEncoding=utf-8</span>    <span class="attr">username:</span> <span class="string">root</span>    <span class="attr">password:</span> <span class="number">1314</span>    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span>  <span class="attr">jpa:</span>    <span class="attr">show-sql:</span> <span class="literal">true</span>    <span class="attr">properties:</span>      <span class="attr">hibernate:</span>        <span class="attr">format_sql:</span> <span class="literal">true</span></code></pre><h2 id="SpringBoot-整合-Redis"><a href="#SpringBoot-整合-Redis" class="headerlink" title="SpringBoot 整合 Redis"></a>SpringBoot 整合 Redis</h2><p>1、导入依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-redis<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、创建实体类，实现序列化接口，否则无法写入 redis 数据库。</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.entity;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> java.io.Serializable;<span class="keyword">import</span> java.util.Date;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;    <span class="keyword">private</span> Integer id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> Double score;    <span class="keyword">private</span> Date birthday;&#125;</code></pre><p>3、控制器</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> com.ai.entity.Student;<span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;<span class="keyword">import</span> org.springframework.web.bind.annotation.RequestBody;<span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;<span class="meta">@RestController</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentHandler</span> &#123;    <span class="meta">@Autowired</span>    <span class="keyword">private</span> RedisTemplate redisTemplate;    <span class="meta">@PostMapping(&quot;/set&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="meta">@RequestBody</span> Student student)</span> &#123;        redisTemplate.opsForValue().set(<span class="string">&quot;student&quot;</span>, student);    &#125;&#125;</code></pre><p>4、配置文件 application.yml</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">redis:</span>    <span class="attr">host:</span> <span class="string">localhost</span>    <span class="attr">database:</span> <span class="number">0</span>    <span class="attr">port:</span> <span class="number">6379</span></code></pre><h3 id="Redis-5-种数据类型"><a href="#Redis-5-种数据类型" class="headerlink" title="Redis 5 种数据类型"></a>Redis 5 种数据类型</h3><ul><li>字符串</li><li>列表</li><li>集合</li><li>有序集合</li><li>哈希</li></ul><h2 id="SpringBoot-整合-SpringSecurity"><a href="#SpringBoot-整合-SpringSecurity" class="headerlink" title="SpringBoot 整合 SpringSecurity"></a>SpringBoot 整合 SpringSecurity</h2><p>1、导入依赖</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot-springsecurity<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  <span class="tag">&lt;<span class="name">properties</span>&gt;</span>    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  <span class="tag">&lt;<span class="name">parent</span>&gt;</span>    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span><span class="tag">&lt;/<span class="name">project</span>&gt;</span></code></pre><p>2、创建 Handler</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> &#123;    <span class="meta">@GetMapping(&quot;/index&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;    &#125;&#125;</code></pre><p>3、创建 application.yml 并设置自定义密码</p><pre><code class="highlight yml"><span class="attr">spring:</span>  <span class="attr">thymeleaf:</span>    <span class="attr">prefix:</span> <span class="string">classpath:/templates/</span>    <span class="attr">suffix:</span> <span class="string">.html</span>  <span class="attr">security:</span>    <span class="attr">user:</span>      <span class="attr">name:</span> <span class="string">admin</span>      <span class="attr">password:</span> <span class="number">1314</span></code></pre><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><p>定义两个 HTML 资源：index.html、admin.html，同时定义两个角色：admin,  user，admin 拥有访问这两个资源的权限，user 只能访问 index.html。</p><p>权限给角色，角色赋给用户（账号）。账户有多个角色，也就用了多种权限。</p><p>7、创建 SecurityConfig 类</p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.config;<span class="keyword">import</span> org.springframework.context.annotation.Configuration;<span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span class="meta">@Configuration</span><span class="meta">@EnableWebSecurity</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 角色和权限的关系</span>        http.authorizeRequests().antMatchers(<span class="string">&quot;/admin&quot;</span>).hasRole(<span class="string">&quot;ADMIN&quot;</span>)                .antMatchers(<span class="string">&quot;/index&quot;</span>).access(<span class="string">&quot;hasRole(&#x27;ADMIN&#x27;) or hasRole(&#x27;USER&#x27;)&quot;</span>)                .anyRequest().authenticated()                .and()                .formLogin()                .loginPage(<span class="string">&quot;/login&quot;</span>)                .permitAll()                .and()                .logout()                .permitAll()                .and()                .csrf()                .disable();    &#125;    <span class="meta">@Override</span>    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123;        <span class="comment">// 账户和角色的关系</span>        auth.inMemoryAuthentication().passwordEncoder(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>())                .withUser(<span class="string">&quot;user&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>().encode(<span class="string">&quot;123&quot;</span>)).roles(<span class="string">&quot;USER&quot;</span>)                .and()                .withUser(<span class="string">&quot;admin&quot;</span>).password(<span class="keyword">new</span> <span class="title class_">MyPasswordEncoder</span>().encode(<span class="string">&quot;123&quot;</span>)).roles(<span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;USER&quot;</span>);    &#125;&#125;</code></pre><p>8、修改 Handler </p><pre><code class="highlight java"><span class="keyword">package</span> com.ai.controller;<span class="keyword">import</span> org.springframework.stereotype.Controller;<span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<span class="meta">@Controller</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloHandler</span> &#123;    <span class="meta">@GetMapping(&quot;/index&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/admin&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">admin</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;admin&quot;</span>;    &#125;    <span class="meta">@GetMapping(&quot;/login&quot;)</span>    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">()</span> &#123;        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;    &#125;&#125;</code></pre><p>9、login.html</p><pre><code class="highlight html"><span class="meta">&lt;!doctype <span class="keyword">html</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/html&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">head</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span>    <span class="tag">&lt;<span class="name">form</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/login&#125;&quot;</span>  <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span>        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>        密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span>        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span>    <span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot小记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList扩容机制</title>
      <link href="/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/"/>
      <url>/2024/02/06/ArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>ArrayList 有三种方式初始化：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;        <span class="built_in">this</span>.elementData = EMPTY_ELEMENTDATA;    &#125; <span class="keyword">else</span> &#123;        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+                                           initialCapacity);    &#125;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;    <span class="built_in">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;<span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;    Object[] a = c.toArray();    <span class="keyword">if</span> ((size = a.length) != <span class="number">0</span>) &#123;        <span class="keyword">if</span> (c.getClass() == ArrayList.class) &#123;            elementData = a;        &#125; <span class="keyword">else</span> &#123;            elementData = Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; <span class="keyword">else</span> &#123;        <span class="comment">// replace with empty array.</span>        elementData = EMPTY_ELEMENTDATA;    &#125;&#125;</code></pre><ul><li>无参方式创建时，初始化为空数组，等到第一个元素 add 时，数组才扩容到默认值 10。</li></ul><p>先从 add 方法入手：</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span>    elementData[size++] = e;    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</code></pre><p>第一次 add 时，size 为 0，我们进入 ensureCapacityInternal 方法：</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacityInternal</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;</code></pre><p>在 calculateCapacity 这个方法中，如果当前数组为空（第一次 add 时），就返回默认容量和最小容量中的较大值作为所需容量。否则直接返回 minCapacity。</p><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateCapacity</span><span class="params">(Object[] elementData, <span class="type">int</span> minCapacity)</span> &#123;    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);    &#125;    <span class="keyword">return</span> minCapacity;&#125;<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureExplicitCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    modCount++;    <span class="comment">// overflow-conscious code</span>    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)        grow(minCapacity);&#125;</code></pre><pre><code class="highlight java"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grow</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;    <span class="comment">// overflow-conscious code</span>    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;    <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)        newCapacity = minCapacity;    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)        newCapacity = hugeCapacity(minCapacity);    <span class="comment">// minCapacity is usually close to size, so this is a win:</span>    elementData = Arrays.copyOf(elementData, newCapacity);&#125;</code></pre><p>到这里为止，我们添加第一个元素，数组容量由 空数组 扩容到容量为 10 的数组。如何扩容的呢？ 核心实现在 grow 方法中，此时 minCapacity &#x3D; 10， newCapacity &#x3D; 0，第一个 if 满足条件，newCapacity 赋值为 10。数组被复制到一个扩容后的新数组。</p><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copyOf(<span class="type">int</span>[] original, <span class="type">int</span> newLength) &#123;  <span class="comment">// 申请一个新的数组</span>    <span class="type">int</span>[] copy = <span class="keyword">new</span> <span class="title class_">int</span>[newLength];<span class="comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,                     Math.min(original.length, newLength));    <span class="keyword">return</span> copy;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 源码分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ArrayList扩容机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo上传图片</title>
      <link href="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/"/>
      <url>/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>今天在使用 typora 写好笔记后，上传至 hexo 服务器，发现图片还是读取的本地路径。通过参考其他人的经验找到一种解决方法。</p><p>1、在 typora 设置中勾选如下选项，作用是图片使用相对路径。</p><p><img src="/2024/01/06/hexo%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87/image-20240106172757156.png" alt="image-20240106172757156"></p><p>2、安装插件即可，不需要再设置<code>图片根目录</code>。</p><pre><code class="highlight javascript">npm install <span class="attr">https</span>:<span class="comment">//github.com/CodeFalling/hexo-asset-image --save</span></code></pre><p>至此在浏览器就可以正常显示图片了。（ps: 前提是根目录下的_config.yml文件中的post_asset_folder字段已经设置为true）</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring笔记</title>
      <link href="/2023/12/15/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/12/15/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring框架两大核心机制-IOC、AOP"><a href="#Spring框架两大核心机制-IOC、AOP" class="headerlink" title="Spring框架两大核心机制(IOC、AOP)"></a>Spring框架两大核心机制(IOC、AOP)</h2><ul><li>IOC（控制反转）&#x2F; DI （依赖注入）</li><li>AOP （面向切面编程）</li></ul><p>Spring是一个企业级的开发框架，是软件设计层面的框架，优势在于可以将应用程序进行分层，开发者可以自主选择组件。</p><p>MVC：Struts2、Spring MVC</p><p>ORMapping：Hibernate、Mybatis、Spring Data</p><p>什么是控制反转：对象由调用者主动new出来。而在Spring中创建对象由IOC容器创建，再推送给调用者，整个流程完成反转，就称作控制反转。</p><h2 id="如何使用IOC"><a href="#如何使用IOC" class="headerlink" title="如何使用IOC"></a>如何使用IOC</h2><ul><li>创建Maven工程，添加pom.xml依赖</li></ul><pre><code class="highlight java">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;<span class="number">5.3</span><span class="number">.29</span>&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><ul><li><p>创建实体类Student</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.Data;<span class="meta">@Data</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;    <span class="keyword">private</span> <span class="type">int</span> age;&#125;</code></pre></li><li><p>传统的开发方式  手动new</p></li><li><p>通过IOC创建对象，在XML配置文件中添加需要管理的对象</p></li></ul><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><ul><li>从IOC中获取对象</li></ul><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) applicationContext.getBean(<span class="string">&quot;student&quot;</span>);System.out.println(student);</code></pre><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li><p>通过配置<code>bean</code>标签完成对象的管理</p><ul><li>id : 对象名</li><li>class：对象的模版类（所有交给IOC构建的对象都要有无参构造，因为Spring底层是通过反射机制创建对象的，反射机制调用的是无参构造）</li></ul></li><li><p>成员变量通过<code>property</code> 标签完成赋值</p><ul><li><code>name</code>：成员变量名</li><li><code>value</code>：成员变量的值（基本数据类型，Spring可以直接赋值，其他类型不能通过value赋值）</li><li><code>ref</code>：将IOC中的另外一个bean赋值给当前变量（DI 依赖注入）</li></ul><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;wdcp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="IOC底层原理"><a href="#IOC底层原理" class="headerlink" title="IOC底层原理"></a>IOC底层原理</h3><ul><li>读取配置文件，解析XML</li><li>通过反射机制实例化配置文件中所配置的所有bean。</li></ul><h3 id="通过运行时类获取bean"><a href="#通过运行时类获取bean" class="headerlink" title="通过运行时类获取bean"></a>通过运行时类获取bean</h3><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring.xml&quot;</span>);<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> applicationContext.getBean(Student.class);System.out.println(st);</code></pre><p>这种方式存在问题，配置文件中一个数据类型对象只能有一个实例，因为是通过Class中获取的，Class中数据类型是一样的。</p><h3 id="通过有参构造创建对象"><a href="#通过有参构造创建对象" class="headerlink" title="通过有参构造创建对象"></a>通过有参构造创建对象</h3><ul><li><p>在实体类中创建有参函数</p></li><li><p>配置文件</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span>    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></li></ul><h3 id="给bean注入集合"><a href="#给bean注入集合" class="headerlink" title="给bean注入集合"></a>给bean注入集合</h3><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;www&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span> &gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;南京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;address2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Address&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京路&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="scope作用域"><a href="#scope作用域" class="headerlink" title="scope作用域"></a>scope作用域</h3><p>Spring管理的bean是根据bean来生成的，表示bean的作用域，共4种，默认是singleton。</p><ul><li>singleton：单例，表示通过Spring容器获取的bean是唯一的。</li><li>prototype：原型，表示通过Spring容器获取的bean是不同的。</li><li>request：请求，表示在一次HTTP请求内有效。</li><li>session：会话，表示在一个用户会话内有效。</li></ul><p>request 和 session 只适用于Web项目，大多数情况下，使用单例和原型较多。</p><p>request模式在加载配置文件时就创建了xml中所有的bean。</p><p>prototype模式当业务代码获取IOC容器中的bean时，Spring才去调用无参构造创建对应的bean。</p><h3 id="Spring的继承"><a href="#Spring的继承" class="headerlink" title="Spring的继承"></a>Spring的继承</h3><p>与JAVA中的继承不同，JAVA是类层面的继承，子类可以继承父类的结构和信息；Spring是对象层面的继承，子对象可以继承父对象的属性值。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lala&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;19&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;addresses&quot;</span>&gt;</span>        <span class="tag">&lt;<span class="name">list</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;address2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span>        <span class="tag">&lt;/<span class="name">list</span>&gt;</span>    <span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;stu&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;student2&quot;</span>&gt;</span>    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><ul><li>不同类型的对象某些情况也是可以继承的，需要子对象的属性包含父对象的属性。</li></ul><h3 id="Spring的依赖"><a href="#Spring的依赖" class="headerlink" title="Spring的依赖"></a>Spring的依赖</h3><p>与继承类似，依赖也是描述bean和bean之间的一种关系，配置依赖后，被依赖的bean先创建，再创建依赖的bean。如A依赖于B，则先创建B，再创建A。</p><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.User&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre><h3 id="Spring的-p-命名空间"><a href="#Spring的-p-命名空间" class="headerlink" title="Spring的 p 命名空间"></a>Spring的 p 命名空间</h3><p>p 命名空间是对IOC &#x2F; DI的简化操作，使用 p 命名空间可以更加方便的完成bean的配置以及bean之间的依赖注入。</p><h3 id="Spring的工厂方法"><a href="#Spring的工厂方法" class="headerlink" title="Spring的工厂方法"></a>Spring的工厂方法</h3><p>IOC通过工厂模式创建 bean 的方式有两种：</p><ul><li>静态工厂模式</li><li>实例工厂方法</li></ul><p>静态工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.entity;<span class="keyword">import</span> lombok.AllArgsConstructor;<span class="keyword">import</span> lombok.Data;<span class="keyword">import</span> lombok.NoArgsConstructor;<span class="meta">@Data</span><span class="meta">@AllArgsConstructor</span><span class="meta">@NoArgsConstructor</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;    <span class="keyword">private</span> <span class="type">long</span> id;    <span class="keyword">private</span> String name;&#125;</code></pre><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticCarFactory</span> &#123;    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long, Car&gt; carMap;    <span class="keyword">static</span> &#123;        carMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        carMap.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大G&quot;</span>));        carMap.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;宝马&quot;</span>));    &#125;    <span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> carMap.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java">&lt;!--配置静态工厂创建bean--&gt;    &lt;bean id=<span class="string">&quot;car&quot;</span> class=<span class="string">&quot;com.study.factory.StaticCarFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;        &lt;constructor-arg value=<span class="string">&quot;1&quot;</span>&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>实例工厂方法：</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.factory;<span class="keyword">import</span> com.study.entity.Car;<span class="keyword">import</span> java.util.HashMap;<span class="keyword">import</span> java.util.Map;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstanceCarFactory</span> &#123;    <span class="keyword">private</span> Map&lt;Long, Car&gt; map;    <span class="keyword">public</span> <span class="title function_">InstanceCarFactory</span><span class="params">()</span> &#123;        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();        map.put(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">1L</span>, <span class="string">&quot;大奔&quot;</span>));        map.put(<span class="number">2L</span>, <span class="keyword">new</span> <span class="title class_">Car</span>(<span class="number">2L</span>, <span class="string">&quot;沃尔沃&quot;</span>));    &#125;    <span class="keyword">public</span> Car <span class="title function_">getCar</span><span class="params">(<span class="type">long</span> id)</span>&#123;        <span class="keyword">return</span> map.get(id);    &#125;&#125;</code></pre><pre><code class="highlight java"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;spring-factory.xml&quot;</span>);<span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) applicationContext.getBean(<span class="string">&quot;car2&quot;</span>);System.out.println(car);</code></pre><pre><code class="highlight java">&lt;!--实例工厂创建bean--&gt;&lt;bean id=<span class="string">&quot;carFactory&quot;</span> class=<span class="string">&quot;com.study.factory.InstanceCarFactory&quot;</span>&gt;&lt;/bean&gt;&lt;bean id=<span class="string">&quot;car2&quot;</span> class=<span class="string">&quot;com.study.entity.Car&quot;</span> factory-bean=<span class="string">&quot;carFactory&quot;</span> factory-method=<span class="string">&quot;getCar&quot;</span>&gt;    &lt;constructor-arg value=<span class="string">&quot;2&quot;</span>&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;</code></pre><h3 id="IOC自动装载（Autowire）"><a href="#IOC自动装载（Autowire）" class="headerlink" title="IOC自动装载（Autowire）"></a>IOC自动装载（Autowire）</h3><p>IOC负责创建对象，DI完成对象的依赖注入，通过配置property标签的 ref 属性完成，同时Spring提供了更加简便的依赖注入方式：自动装载，不需要手动配置property，IOC容器会自动选择 bean 完成注入。</p><p>自动装载有两种方式：</p><ul><li>byName：通过属性名自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><ul><li>byType：通过属性的类型自动装载</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cars&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Car&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;大奔&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;person&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.study.entity.Person&quot;</span> <span class="attr">p:id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;wdcp&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></code></pre></blockquote><p>byType需要注意，如果同时存在两个及以上的bean时，会抛出异常。</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP：Aspect Oriented Programming 面向切面编程</p><p>AOP的优点：</p><ul><li>降低模块的耦合度</li><li>使系统更容易扩展</li><li>更好的代码服用</li><li>非业务代码更加集中，便于统一管理</li><li>业务代码更加简洁，不掺杂其他代码影响</li></ul><p>AOP是对面向对象编程的一个补充，在运行时，动态地将代码切入到类的指定方法、指定对象上的编程思想就是面向切面编程。将不同方法的同一位置抽象成一个切面对象，对该切面对象进行编程就是AOP。</p><h3 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h3><ul><li>创建Maven工程，pom.xml添加</li></ul><blockquote><pre><code class="highlight xml"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">dependency</span>&gt;</span><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></code></pre></blockquote><ul><li>创建一个计算器接口，创建加减乘除方法</li></ul><pre><code class="highlight java"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;add方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;sub方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;mul方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        System.out.println(<span class="string">&quot;div方法的参数是[&quot;</span> + num1 +<span class="string">&quot;,&quot;</span> + num2+<span class="string">&quot;]&quot;</span> );        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        System.out.println(<span class="string">&quot;结果是&quot;</span> + result);        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>上述代码中，日志信息和业务逻辑的耦合性很高，不利于系统的维护，使用AOP可以进行优化，如何实现AOP？使用动态代理的方式来实现。</p><p>给业务代码找一个代理，打印日志信息的工作交给代理来做，这样的话业务代码只需关注自身业务即可。</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.utils;<span class="keyword">import</span> java.lang.reflect.InvocationHandler;<span class="keyword">import</span> java.lang.reflect.Method;<span class="keyword">import</span> java.lang.reflect.Proxy;<span class="keyword">import</span> java.util.Arrays;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;  <span class="comment">// 这不是代理类，这个类帮助我们去创建动态代理类</span>  <span class="comment">// 接收委托对象</span>  <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">// 返回代理对象</span>  <span class="keyword">public</span> Object <span class="title function_">bind</span><span class="params">(Object object)</span> &#123;      <span class="built_in">this</span>.object = object;      <span class="keyword">return</span> Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), <span class="built_in">this</span>);  &#125;  <span class="meta">@Override</span>  <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;      <span class="comment">// 这里将业务代码和日志代码进行解耦</span>      System.out.println(method.getName() + <span class="string">&quot;方法的参数是&quot;</span> + Arrays.toString(args));      <span class="type">Object</span> <span class="variable">res</span> <span class="operator">=</span> method.invoke(<span class="built_in">this</span>.object, args);  <span class="comment">// 业务代码</span>      System.out.println(method.getName() + <span class="string">&quot;的结果是&quot;</span> + res);      <span class="keyword">return</span> res;  &#125;&#125;</code></pre><p>以上是通过动态代理实现AOP的过程，不好理解，Spring框架对AOP进行了封装，使用Spring框架可以用面向对象的思想实现AOP。</p><p>Spring 框架中不需要创建 InvocationHandler，只需要创建一个切面对象，将所有的非业务代码在切面对象中完成，Spring 框架底层会根据切面类以及目标类生成一个代理对象。</p><p>LoggerAspect</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.aop;<span class="keyword">import</span> org.aspectj.lang.JoinPoint;<span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;<span class="keyword">import</span> org.aspectj.lang.annotation.Before;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="keyword">import</span> java.util.Arrays;<span class="meta">@Aspect</span><span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggerAspect</span> &#123;    <span class="comment">// 非业务代码</span>    <span class="meta">@Before(&quot;execution(public int com.study.impl.CalImpl.*(..))&quot;)</span>    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinPoint)</span>&#123;        <span class="comment">// 获取方法名</span>        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinPoint.getSignature().getName();        <span class="comment">// 获取参数</span>        <span class="type">String</span> <span class="variable">args</span> <span class="operator">=</span> Arrays.toString(joinPoint.getArgs());        System.out.println(name + <span class="string">&quot;方法的参数是&quot;</span> + args);    &#125;&#125;</code></pre><p>LoggerAspect两个注解：</p><ul><li>@Aspect 表示该类是切面类</li><li>@Component 将该类的对象注入到 IOC 容器</li></ul><p>具体方法处添加的注解：</p><ul><li>@Before 表示方法执行的具体位置和时机</li></ul><p>CalImpl 也需要添加 @Component，交给 IOC 管理</p><pre><code class="highlight java"><span class="keyword">package</span> com.study.impl;<span class="keyword">import</span> com.study.utils.Cal;<span class="keyword">import</span> org.springframework.stereotype.Component;<span class="meta">@Component</span><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalImpl</span> <span class="keyword">implements</span> <span class="title class_">Cal</span> &#123;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 - num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 * num2;        <span class="keyword">return</span> result;    &#125;    <span class="meta">@Override</span>    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 / num2;        <span class="keyword">return</span> result;    &#125;&#125;</code></pre><p>Spring.xml 也需要配置 AOP</p><pre><code class="highlight xml"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><span class="tag">&lt;<span class="name">beans</span></span><span class="tag">        <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span><span class="tag">        <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context</span></span><span class="string"><span class="tag">http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span>        <span class="comment">&lt;!-- 自动扫描 --&gt;</span>        <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.study&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span>    <span class="comment">&lt;!-- 使Aspect注解生效 为目标类自动生成代理对象--&gt;</span>    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></code></pre><p><code>context:component-scan</code> 将 <code>com.study</code> 包中所有类进行扫描，如果该类同时添加了 <code>@Component</code>，则将该类添加到 IOC 容器中，让 IOC 管理它的对象。</p><p><code>aop:aspectj-autoproxy</code> 让Spring框架结合切面类和目标类自动生成动态代理对象。</p><ul><li>切面：横切关注点被模块化的抽象对象。</li><li>通知：切面对象完成的工作。（非业务代码）</li><li>目标：被通知的对象，即被横切的对象。</li><li>代理：切面、通知、目标混合之后的对象。</li><li>连接点：通知要插入代码的具体位置。</li><li>切点：AOP 通过切点定位到连接点。</li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>@Bean的作用域</p><blockquote><p>最常用的有prototype 和 singleton。</p><p>singleton：IoC容器中唯一的 bean 实例。</p><p>prototype：每次获取都会创建唯一的 bean。</p></blockquote><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><table><thead><tr><th>事物传播类型</th><th>特性</th></tr></thead><tbody><tr><td>REQUIRED</td><td>当前方法存在事物，子类方法加入事物，这时父子共用同一个事物，此时无论父子哪个发生回滚，整个事物都会一起回滚。即使父类捕捉了子类的异常，也会回滚。而当前方法不存在事务时，子方法新建一个事务。</td></tr><tr><td>REQUIRED_NEW</td><td>无论当前方法是否存在事物，子方法都新建一个事物，此时父子方法的事物是独立的，不会互相影响。但父方法需要注意子类抛出的异常，如果没有处理异常也会导致回滚。</td></tr><tr><td>NESTED</td><td>当前事物存在事物时，子方法加入嵌套事物执行，当父方法回滚时，子方法也跟着回滚。当子方法回滚时，父方法如果没有处理异常也会回滚。</td></tr></tbody></table><h2 id="事物失效"><a href="#事物失效" class="headerlink" title="事物失效"></a>事物失效</h2><ol><li>同一个类中没有 @Transactional 注解的方法调用有 @Transactional 注解的方法。这是因为直接调用不会经过代理，事物管理不会被触发。或者可以通过 AopContext.currentProxy() 去获取当前bean的代理对象。</li><li>只有应用在 public 方法上才生效。</li><li>底层数据库的必须支持事物。</li></ol><p>深入理解：<a href="https://cloud.tencent.com/developer/article/2119692">https://cloud.tencent.com/developer/article/2119692</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Experience getting started with deep learning</title>
      <link href="/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/"/>
      <url>/2023/12/01/Experience%20getting%20started%20with%20deep%20learning/</url>
      
        <content type="html"><![CDATA[<p>暂无~</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
